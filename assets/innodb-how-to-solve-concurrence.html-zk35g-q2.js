const t=JSON.parse('{"key":"v-c4b2ac0a","path":"/interview-shorthand/mysql/transaction/innodb-how-to-solve-concurrence.html","title":"InnoDB如何解决并发引发的问题","lang":"zh-CN","frontmatter":{"title":"InnoDB如何解决并发引发的问题","author":null,"category":"MySQL","tag":"MySQL","description":"脏读的解决方式 InnoDB 通过在每行数据中添加一个隐藏的事务 ID 来实现 MVCC，当一个事务开始时，它会获取一个唯一的事务 ID，该事务 ID 被用来标记该事务所做的修改。当一个事务读取一行数据时，InnoDB 检查该行数据的事务 ID 是否小于当前事务的 ID，只有小于当前事务ID才是已提交的数据。否则，说明该行数据是未提交的数据，InnoDB 将阻止该事务读取该行数据，从而避免了脏读的问题。 不可重复读的解决方式 InnoDB 通过使用 MVCC 来解决不可重复读的问题。在RR这种隔离级别下，当我们使用快照读进行数据读取的时候，只会在第一次读取的时候生成一个Read View，后续的所有快照读都是用的同一个快照，所以就不会发生不可重复读的问题了。","head":[["meta",{"property":"og:url","content":"https://hollowlatte.github.io/Note-Book/Note-Book/interview-shorthand/mysql/transaction/innodb-how-to-solve-concurrence.html"}],["meta",{"property":"og:site_name","content":"Note-Book"}],["meta",{"property":"og:title","content":"InnoDB如何解决并发引发的问题"}],["meta",{"property":"og:description","content":"脏读的解决方式 InnoDB 通过在每行数据中添加一个隐藏的事务 ID 来实现 MVCC，当一个事务开始时，它会获取一个唯一的事务 ID，该事务 ID 被用来标记该事务所做的修改。当一个事务读取一行数据时，InnoDB 检查该行数据的事务 ID 是否小于当前事务的 ID，只有小于当前事务ID才是已提交的数据。否则，说明该行数据是未提交的数据，InnoDB 将阻止该事务读取该行数据，从而避免了脏读的问题。 不可重复读的解决方式 InnoDB 通过使用 MVCC 来解决不可重复读的问题。在RR这种隔离级别下，当我们使用快照读进行数据读取的时候，只会在第一次读取的时候生成一个Read View，后续的所有快照读都是用的同一个快照，所以就不会发生不可重复读的问题了。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Hollow-Latte"}],["meta",{"property":"article:tag","content":"MySQL"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"InnoDB如何解决并发引发的问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hollow-Latte\\",\\"url\\":\\"https://hollowlatte.github.io/Note-Book\\"}]}"]]},"headers":[{"level":2,"title":"脏读的解决方式","slug":"脏读的解决方式","link":"#脏读的解决方式","children":[]},{"level":2,"title":"不可重复读的解决方式","slug":"不可重复读的解决方式","link":"#不可重复读的解决方式","children":[]},{"level":2,"title":"幻读的解决方式","slug":"幻读的解决方式","link":"#幻读的解决方式","children":[]}],"git":{},"readingTime":{"minutes":1.15,"words":345},"filePathRelative":"interview-shorthand/mysql/transaction/innodb-how-to-solve-concurrence.md","excerpt":"<h2> 脏读的解决方式</h2>\\n<p>InnoDB 通过在每行数据中添加一个隐藏的事务 ID 来实现 MVCC，当一个事务开始时，它会获取一个唯一的事务 ID，该事务 ID\\n被用来标记该事务所做的修改。当一个事务读取一行数据时，InnoDB 检查该行数据的事务 ID 是否小于当前事务的\\nID，只有小于当前事务ID才是已提交的数据。否则，说明该行数据是未提交的数据，InnoDB 将阻止该事务读取该行数据，从而避免了脏读的问题。</p>\\n<h2> 不可重复读的解决方式</h2>\\n<p>InnoDB 通过使用 MVCC 来解决不可重复读的问题。在RR这种隔离级别下，当我们使用快照读进行数据读取的时候，只会在第一次读取的时候生成一个Read\\nView，后续的所有快照读都是用的同一个快照，所以就不会发生不可重复读的问题了。</p>","autoDesc":true}');export{t as data};
