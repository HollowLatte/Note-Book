import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as t,c as r,e as o}from"./app-R-jbemKs.js";const a={},s=o('<h2 id="什么是stop-the-world-stw" tabindex="-1"><a class="header-anchor" href="#什么是stop-the-world-stw" aria-hidden="true">#</a> 什么是Stop The World(STW)？</h2><p>Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。 这是Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。</p><p><strong>不管选择哪种GC算法，stop-the-world都是不能彻底避免的，只能尽量降低STW的时长。</strong></p><h2 id="为什么要有stw-不全局暂停可以吗" tabindex="-1"><a class="header-anchor" href="#为什么要有stw-不全局暂停可以吗" aria-hidden="true">#</a> 为什么要有STW？不全局暂停可以吗？</h2><p>首先，如果不暂停用户线程，就意味着GC期间会不断有垃圾产生，会影响标记垃圾，永远也清理不干净。</p><p>其次，用户线程的运行必然会导致对象的引用关系发生改变，这就会导致两种情况：漏标和多标。</p><h3 id="多标和漏标" tabindex="-1"><a class="header-anchor" href="#多标和漏标" aria-hidden="true">#</a> 多标和漏标</h3><p><strong>多标</strong>：其实就是这个对象原本应该被回收掉的垃圾对象，但是被错误的标记成了存活对象。从而导致这个对象没有被GC回收掉。 这种情况还好一点，无非就是产生了一些浮动垃圾，下次GC再清理就好了。</p><blockquote><p>垃圾收集在标记的过程中，其实标记的并不是垃圾对象，而是通过可达性分析标记可达对象。 所以当一个对象本来是垃圾对象（不可达对象），但是错误的标记成非垃圾对象（可达对象）时，就是多标了。就会导致浮动垃圾。</p></blockquote><p><strong>漏标</strong>：一个对象本来应该是存活对象，但是没有被正确的标记上，导致被错误的垃圾回收掉了。</p><h2 id="什么情况会触发stw" tabindex="-1"><a class="header-anchor" href="#什么情况会触发stw" aria-hidden="true">#</a> 什么情况会触发STW？</h2><p>Minor GC 和 Full GC 都会触发STW</p><p>Minor GC（Young GC）：主要针对年轻代垃圾回收，包括Eden区和Survivor区。STW 暂停时间通常较短，因为Minor GC只需要标记年轻代的垃圾 Full GC：对整个堆空间（包括年轻代和老年代）的垃圾回收。STW 暂停时间通常较长，因为需要对整个堆空间进行垃圾回收</p>',13),n=[s];function h(d,i){return t(),r("div",null,n)}const l=e(a,[["render",h],["__file","stop-the-world.html.vue"]]);export{l as default};
