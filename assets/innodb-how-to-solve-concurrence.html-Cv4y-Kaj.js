import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as o,e as n}from"./app-CDroZFTS.js";const a={},r=n('<h2 id="脏读的解决方式" tabindex="-1"><a class="header-anchor" href="#脏读的解决方式"><span>脏读的解决方式</span></a></h2><p>InnoDB 通过在每行数据中添加一个隐藏的事务 ID 来实现 MVCC，当一个事务开始时，它会获取一个唯一的事务 ID，该事务 ID 被用来标记该事务所做的修改。当一个事务读取一行数据时，InnoDB 检查该行数据的事务 ID 是否小于当前事务的 ID，只有小于当前事务ID才是已提交的数据。否则，说明该行数据是未提交的数据，InnoDB 将阻止该事务读取该行数据，从而避免了脏读的问题。</p><h2 id="不可重复读的解决方式" tabindex="-1"><a class="header-anchor" href="#不可重复读的解决方式"><span>不可重复读的解决方式</span></a></h2><p>InnoDB 通过使用 MVCC 来解决不可重复读的问题。在RR这种隔离级别下，当我们使用快照读进行数据读取的时候，只会在第一次读取的时候生成一个Read View，后续的所有快照读都是用的同一个快照，所以就不会发生不可重复读的问题了。</p><h2 id="幻读的解决方式" tabindex="-1"><a class="header-anchor" href="#幻读的解决方式"><span>幻读的解决方式</span></a></h2><p>InnoDB的RR级别中，基于MVCC+间隙锁，是在某种程度上是可以避免幻读的发生的，<strong>但是没有办法完全避免</strong>，当一个事务中发生当前读的时候，会导致幻读的发生。</p>',6),i=[r];function l(c,s){return t(),o("div",null,i)}const d=e(a,[["render",l],["__file","innodb-how-to-solve-concurrence.html.vue"]]),D=JSON.parse('{"path":"/interview-shorthand/mysql/transaction/innodb-how-to-solve-concurrence.html","title":"InnoDB如何解决并发引发的问题","lang":"zh-CN","frontmatter":{"title":"InnoDB如何解决并发引发的问题","author":null,"category":"MySQL","tag":"MySQL","description":"脏读的解决方式 InnoDB 通过在每行数据中添加一个隐藏的事务 ID 来实现 MVCC，当一个事务开始时，它会获取一个唯一的事务 ID，该事务 ID 被用来标记该事务所做的修改。当一个事务读取一行数据时，InnoDB 检查该行数据的事务 ID 是否小于当前事务的 ID，只有小于当前事务ID才是已提交的数据。否则，说明该行数据是未提交的数据，InnoD...","head":[["meta",{"property":"og:url","content":"https://hollowlatte.github.io/Note-Book/Note-Book/interview-shorthand/mysql/transaction/innodb-how-to-solve-concurrence.html"}],["meta",{"property":"og:site_name","content":"Note-Book"}],["meta",{"property":"og:title","content":"InnoDB如何解决并发引发的问题"}],["meta",{"property":"og:description","content":"脏读的解决方式 InnoDB 通过在每行数据中添加一个隐藏的事务 ID 来实现 MVCC，当一个事务开始时，它会获取一个唯一的事务 ID，该事务 ID 被用来标记该事务所做的修改。当一个事务读取一行数据时，InnoDB 检查该行数据的事务 ID 是否小于当前事务的 ID，只有小于当前事务ID才是已提交的数据。否则，说明该行数据是未提交的数据，InnoD..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-21T15:09:08.000Z"}],["meta",{"property":"article:author","content":"Hollow-Latte"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:modified_time","content":"2024-03-21T15:09:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"InnoDB如何解决并发引发的问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-21T15:09:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hollow-Latte\\",\\"url\\":\\"https://hollowlatte.github.io/Note-Book\\"}]}"]]},"headers":[{"level":2,"title":"脏读的解决方式","slug":"脏读的解决方式","link":"#脏读的解决方式","children":[]},{"level":2,"title":"不可重复读的解决方式","slug":"不可重复读的解决方式","link":"#不可重复读的解决方式","children":[]},{"level":2,"title":"幻读的解决方式","slug":"幻读的解决方式","link":"#幻读的解决方式","children":[]}],"git":{"createdTime":1711033748000,"updatedTime":1711033748000,"contributors":[{"name":"hollowlatte","email":"hollowlatte@outlook.com","commits":1}]},"readingTime":{"minutes":1.15,"words":345},"filePathRelative":"interview-shorthand/mysql/transaction/innodb-how-to-solve-concurrence.md","localizedDate":"2024年3月21日","excerpt":"<h2>脏读的解决方式</h2>\\n<p>InnoDB 通过在每行数据中添加一个隐藏的事务 ID 来实现 MVCC，当一个事务开始时，它会获取一个唯一的事务 ID，该事务 ID\\n被用来标记该事务所做的修改。当一个事务读取一行数据时，InnoDB 检查该行数据的事务 ID 是否小于当前事务的\\nID，只有小于当前事务ID才是已提交的数据。否则，说明该行数据是未提交的数据，InnoDB 将阻止该事务读取该行数据，从而避免了脏读的问题。</p>\\n<h2>不可重复读的解决方式</h2>\\n<p>InnoDB 通过使用 MVCC 来解决不可重复读的问题。在RR这种隔离级别下，当我们使用快照读进行数据读取的时候，只会在第一次读取的时候生成一个Read\\nView，后续的所有快照读都是用的同一个快照，所以就不会发生不可重复读的问题了。</p>","autoDesc":true}');export{d as comp,D as data};
