import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as h,e as r}from"./app-R-jbemKs.js";const i={},d=r('<p>有4种常见的策略，但是一般Cache Aside的方式是大多数场景下的常用方案，Cache Aside有又三种方式(变体)来处理缓存/数据库</p><h2 id="cache-aside" tabindex="-1"><a class="header-anchor" href="#cache-aside" aria-hidden="true">#</a> Cache Aside</h2><p>Cache Aside的三种变体都面临两个问题，删除缓存还是更新缓存？先删缓存还是后删缓存？</p><h3 id="删除还是更新缓存" tabindex="-1"><a class="header-anchor" href="#删除还是更新缓存" aria-hidden="true">#</a> 删除还是更新缓存？</h3><p>首先，删除缓存是比较好的做法。</p><p>因为更新缓存的动作，相比于直接删除缓存，操作过程比较的复杂，而且也容易出错。通常缓存业务的一些数据时，都是以JSON的格式放到Redis中，那如果更新缓存的话还需要将该JSON反序列化，然后更新其中的信息，然后再序列化放回Redis，相比于删除操作复杂了很多</p><h3 id="先更新数据库后删缓存" tabindex="-1"><a class="header-anchor" href="#先更新数据库后删缓存" aria-hidden="true">#</a> 先更新数据库后删缓存</h3><p>这种处理方式，一般来说是没问题的，但是在极端情况下还是会出现一致性问题</p><p>场景一：更新数据库成功，但是去删除缓存时，由于网络或者其他原因，删除缓存的操作失败，那么缓存中的数据就一直是以前的旧数据了 场景二：请求1从DB读数据A ---&gt; 请求2更新DB中的数据A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） ---&gt; 请求1将数据A 写入cache</p><p>适用场景：业务量不大，并发不高的情况下，可以选择该方式</p><h3 id="先删缓存后更新数据库" tabindex="-1"><a class="header-anchor" href="#先删缓存后更新数据库" aria-hidden="true">#</a> 先删缓存后更新数据库</h3><p>该方式会无形中放大&quot;读写并发&quot;导致的数据不一致的问题。</p><p>例如该场景：请求1先把Cache中的A数据删除 ---&gt; 请求2从DB中读取数据 ---&gt; 请求1再把DB中的A数据更新</p><p><strong>这种问题的后果也比较严重，那就是缓存中的值一直是错的，就会导致后续的所有命中缓存的查询结果都是错的！</strong></p><h3 id="延迟双删" tabindex="-1"><a class="header-anchor" href="#延迟双删" aria-hidden="true">#</a> 延迟双删</h3><p>TODO</p><h2 id="read-write-through" tabindex="-1"><a class="header-anchor" href="#read-write-through" aria-hidden="true">#</a> Read/Write Through</h2><p>在下面两种模式中，应用程序将缓存作为主要的数据源，不需要感知数据库，更新数据库和从数据库的读取的任务都交给缓存来代理。</p><p>这两种模式下，不需要应用自己去操作数据库，缓存自己就把活干完了。</p><h3 id="read-through" tabindex="-1"><a class="header-anchor" href="#read-through" aria-hidden="true">#</a> Read Through</h3><p>缓存配置一个读模块，它知道如何将数据库中的数据写入缓存</p><ul><li>Cache存在，读到即返回</li><li>Cache不存在，通过读模块从DB读取后写入Cache再返回</li></ul><h3 id="write-through" tabindex="-1"><a class="header-anchor" href="#write-through" aria-hidden="true">#</a> Write Through</h3><p>缓存配置一个写模块，它知道如何将数据写入数据库。</p><ul><li>Cache存在，先更新Cache，再通过写模块更新DB</li><li>Cache不存在，通过写模块直接更新DB</li></ul><h2 id="write-behind" tabindex="-1"><a class="header-anchor" href="#write-behind" aria-hidden="true">#</a> Write Behind</h2><p>只更新缓存，不直接更新 DB，而是定时通过异步批量的方式更新DB</p><p>这种模式的优缺点比较明显，那就是读写速度都很快，但是可能会造成一定的数据丢失。</p><p>这种比较适合用在比如统计文章的访问量、点赞等场景中，允许数据少量丢失，但是速度要快。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>要根据自身业务选择合适的策略</p>',31),t=[d];function c(s,n){return a(),h("div",null,t)}const l=e(i,[["render",c],["__file","redis-database-consistent-strategy.html.vue"]]);export{l as default};
