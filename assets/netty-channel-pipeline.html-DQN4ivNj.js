import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as l,c as s,b as o,a as n,e as p}from"./app-6eIwu4TL.js";const i={},c=n("h2",{id:"channelpipeline",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#channelpipeline"},[n("span",null,"ChannelPipeline")])],-1),r=n("p",null,"ChannelPipeline类是ChannelHandler实例对象的链表，用于处理或截获通道的接收和发送数据。它提供了一种高级的截取过滤模式（类似Servlet中的filter功能），让用户可以在ChannelPipeline中完全控制一个事件以及如何处理ChannelHandler与ChannelPipeline的交互。",-1),u=n("p",null,"对于每个新的通道Channel，都会创建一个新的ChannelPipeline",-1),d=n("p",null,[n("strong",null,"下面是一个ChannelPipeline示意图：")],-1),h=p(`<blockquote><p>Head和Tail是源码内使用的两个特殊节点</p></blockquote><p>代码相当于：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FirstOutbound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SecondOutbound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FirstInbound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SecondInbound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Channel会从Head节点进入，经过一系列入站（Inbound）处理器后到达Tail节点，Tail节点再向前寻找出站处理器（Outbound）进行处理，直到Head节点，再写出数据</p>`,4);function m(k,C){const e=t("Mermaid");return l(),s("div",null,[c,r,u,d,o(e,{id:"mermaid-12",code:"eJxLL0osyFDwCeJSAAJHDY/UxBRNBRtdXTsFJw23zKLiEv/SkqT80rwUTbAKJ4ics0ZwanJ+XgqqpDNE0gWi0TMPScoFIuUK1Yci5wqRc9MISczM0eQCAIZGJ3w="}),h])}const _=a(i,[["render",m],["__file","netty-channel-pipeline.html.vue"]]),b=JSON.parse('{"path":"/notebook/netty/netty-channel-pipeline.html","title":"ChannelPipeline","lang":"zh-CN","frontmatter":{"title":"ChannelPipeline","author":null,"category":"Netty","tag":"Netty","date":"2024-03-16T00:00:00.000Z","description":"ChannelPipeline ChannelPipeline类是ChannelHandler实例对象的链表，用于处理或截获通道的接收和发送数据。它提供了一种高级的截取过滤模式（类似Servlet中的filter功能），让用户可以在ChannelPipeline中完全控制一个事件以及如何处理ChannelHandler与ChannelPipeline的...","head":[["meta",{"property":"og:url","content":"https://hollowlatte.github.io/Note-Book/Note-Book/notebook/netty/netty-channel-pipeline.html"}],["meta",{"property":"og:site_name","content":"Note-Book"}],["meta",{"property":"og:title","content":"ChannelPipeline"}],["meta",{"property":"og:description","content":"ChannelPipeline ChannelPipeline类是ChannelHandler实例对象的链表，用于处理或截获通道的接收和发送数据。它提供了一种高级的截取过滤模式（类似Servlet中的filter功能），让用户可以在ChannelPipeline中完全控制一个事件以及如何处理ChannelHandler与ChannelPipeline的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-18T18:44:17.000Z"}],["meta",{"property":"article:author","content":"Hollow-Latte"}],["meta",{"property":"article:tag","content":"Netty"}],["meta",{"property":"article:published_time","content":"2024-03-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-18T18:44:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ChannelPipeline\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-16T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-18T18:44:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hollow-Latte\\",\\"url\\":\\"https://hollowlatte.github.io/Note-Book\\"}]}"]]},"headers":[{"level":2,"title":"ChannelPipeline","slug":"channelpipeline","link":"#channelpipeline","children":[]}],"git":{"createdTime":1710787457000,"updatedTime":1710787457000,"contributors":[{"name":"hollowlatte","email":"hollowlatte@outlook.com","commits":1}]},"readingTime":{"minutes":0.75,"words":224},"filePathRelative":"notebook/netty/netty-channel-pipeline.md","localizedDate":"2024年3月16日","excerpt":"<h2>ChannelPipeline</h2>\\n<p>ChannelPipeline类是ChannelHandler实例对象的链表，用于处理或截获通道的接收和发送数据。它提供了一种高级的截取过滤模式（类似Servlet中的filter功能），让用户可以在ChannelPipeline中完全控制一个事件以及如何处理ChannelHandler与ChannelPipeline的交互。</p>\\n<p>对于每个新的通道Channel，都会创建一个新的ChannelPipeline</p>\\n<p><strong>下面是一个ChannelPipeline示意图：</strong></p>\\n<blockquote>\\n<p>Head和Tail是源码内使用的两个特殊节点</p>\\n</blockquote>","autoDesc":true}');export{_ as comp,b as data};
