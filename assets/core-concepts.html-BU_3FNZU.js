import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as o,e as n}from"./app-DmUsX9Nr.js";const a="/Note-Book/assets/channel-buffer-selector-BuLadw6s.png",r={},l=n('<h2 id="nio核心组件" tabindex="-1"><a class="header-anchor" href="#nio核心组件"><span>NIO核心组件</span></a></h2><p><strong>NIO 主要包括以下三个核心组件</strong>：</p><ul><li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer中，而写操作时将 Buffer中的数据写入到 Channel 中。</li><li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过Channel来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li><li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到Selector上，由Selector来分配线程来处理事件。</li></ul><figure><img src="'+a+'" alt="Buffer、Channel、Selector关系" tabindex="0"><figcaption>Buffer、Channel、Selector关系</figcaption></figure><h2 id="netty" tabindex="-1"><a class="header-anchor" href="#netty"><span>Netty</span></a></h2><p>Netty是基于Java NIO实现的网络应用框架。</p><p>Netty的核心IO模型是异步非阻塞的,这是建立在Java NIO的非阻塞IO基础之上的。相比于传统的BIO同步阻塞模型,NIO可以大大提高网络应用的性能和扩展能力。</p><p>Netty对Java NIO进行了抽象和封装,实现了Reactor模式来做到异步非阻塞,其主要基于Java NIO的抽象有:</p><ul><li>使用Java NIO的Channel、Selector、ByteBuffer等作为异步IO的基础。</li><li>基于Java NIO的SocketChannel实现了异步客户端和服务端。</li><li>通过ByteBuf抽象了虚拟缓存区,用于高效处理字节数据。</li><li>用Pipeline、ChannelHandler等实现了拦截过滤链模式。</li><li>基于Selector实现了异步非阻塞的事件驱动模型。</li><li>提供了各种协议的编解码器和框架。</li><li>简化和扩展了线程模型的使用。</li></ul><p>综上,Netty对Java NIO的抽象使其更易于使用,并构建了一个灵活强大的异步网络应用框架。所以可以说Netty是基于Java NIO之上进行模块化设计实现的。</p><h2 id="reactor模型" tabindex="-1"><a class="header-anchor" href="#reactor模型"><span>Reactor模型</span></a></h2><p>Reactor 模型是一种设计模式,用于构建高并发和高性能的网络服务器。</p><p>Reactor 模型的核心是事件驱动，使用非阻塞IO实现事件驱动架构, 通过事件与处理分离、队列传递消息实现高并发。 正是因为事件驱动,Reactor才能高效地响应大量客户端、实现高性能服务器。</p><p><strong>应用案例</strong>：</p><ul><li>Nginx</li><li>Tomcat</li><li>Node.js</li><li>Kafka</li></ul><h3 id="reactor模型——主从多线程模型-父子多线程模型" tabindex="-1"><a class="header-anchor" href="#reactor模型——主从多线程模型-父子多线程模型"><span>Reactor模型——主从多线程模型（父子多线程模型）</span></a></h3><p>主从Reactor 模式中，分为主 Reactor 和 从 Reactor，分别处理 新建立的连接、IO读写事件/事件分发</p><p><strong>主Reactor</strong>：只负责接受新连接，不做具体的数据处理。</p><p><strong>从Reactor</strong>：负责处理连接的所有读写和数据操作。</p><ul><li>主Reactor 只关注接受新连接,处理简单,效率高。可以解决同一时间大量新连接</li><li>从Reactor 处理比接收新连接复杂得多的读写和业务,可以支撑很多连接。</li><li>主从多线程模型由多个 Reactor 线程组成，每个 Reactor 线程都有独立的 Selector 对象。MainReactor 仅负责处理客户端连接的 Accept 事件，连接建立成功后将新创建的连接对象注册至 SubReactor。再由 SubReactor 分配线程池中的 I/O 线程与其连接绑定，它将负责连接生命周期内所有的 I/O 事件。</li></ul>',20),i=[l];function c(s,p){return t(),o("div",null,i)}const f=e(r,[["render",c],["__file","core-concepts.html.vue"]]),N=JSON.parse('{"path":"/notebook/network/core-concepts.html","title":"Java NIO核心概念","lang":"zh-CN","frontmatter":{"title":"Java NIO核心概念","author":null,"category":"Netty","tag":"Netty","description":"NIO核心组件 NIO 主要包括以下三个核心组件： Buffer（缓冲区）：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer中，而写操作时将 Buffer中的数据写入到 Channel 中。 Channel（通道）：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过Channel来实...","head":[["meta",{"property":"og:url","content":"https://hollowlatte.github.io/Note-Book/Note-Book/notebook/network/core-concepts.html"}],["meta",{"property":"og:site_name","content":"Note-Book"}],["meta",{"property":"og:title","content":"Java NIO核心概念"}],["meta",{"property":"og:description","content":"NIO核心组件 NIO 主要包括以下三个核心组件： Buffer（缓冲区）：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer中，而写操作时将 Buffer中的数据写入到 Channel 中。 Channel（通道）：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过Channel来实..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-28T19:26:07.000Z"}],["meta",{"property":"article:author","content":"Hollow-Latte"}],["meta",{"property":"article:tag","content":"Netty"}],["meta",{"property":"article:modified_time","content":"2024-03-28T19:26:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java NIO核心概念\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-28T19:26:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hollow-Latte\\",\\"url\\":\\"https://hollowlatte.github.io/Note-Book\\"}]}"]]},"headers":[{"level":2,"title":"NIO核心组件","slug":"nio核心组件","link":"#nio核心组件","children":[]},{"level":2,"title":"Netty","slug":"netty","link":"#netty","children":[]},{"level":2,"title":"Reactor模型","slug":"reactor模型","link":"#reactor模型","children":[{"level":3,"title":"Reactor模型——主从多线程模型（父子多线程模型）","slug":"reactor模型——主从多线程模型-父子多线程模型","link":"#reactor模型——主从多线程模型-父子多线程模型","children":[]}]}],"git":{"createdTime":1711653967000,"updatedTime":1711653967000,"contributors":[{"name":"hollowlatte","email":"hollowlatte@outlook.com","commits":1}]},"readingTime":{"minutes":2.86,"words":858},"filePathRelative":"notebook/network/core-concepts.md","localizedDate":"2024年3月28日","excerpt":"<h2>NIO核心组件</h2>\\n<p><strong>NIO 主要包括以下三个核心组件</strong>：</p>\\n<ul>\\n<li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到\\nBuffer中，而写操作时将 Buffer中的数据写入到 Channel 中。</li>\\n<li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO\\n通过Channel来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li>\\n<li><strong>Selector（选择器）</strong>：允许一个线程处理多个\\nChannel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到Selector上，由Selector来分配线程来处理事件。</li>\\n</ul>","autoDesc":true}');export{f as comp,N as data};
