import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as s,e as i}from"./app-CjdU_M7_.js";const a={},n=i(`<h2 id="zset是怎么实现的" tabindex="-1"><a class="header-anchor" href="#zset是怎么实现的"><span>Zset是怎么实现的？</span></a></h2><p>Redis中的ZSet在实现中，有多种结构，大类的话有两种，分别是ziplist(压缩列表)和skiplist(跳跃表)，但是这只是以前，在Redis 5.0中新增了一个listpack（紧凑列表）的数据结构，这种数据结构就是为了替代ziplist的，而在之后Redis 7.0的发布中，在Zset的实现中，已经彻底不在使用zipList了。</p><p>当ZSet的元素数量比较少时，Redis会采用ZipList（ListPack）来存储ZSet的数据。 ZipList（ListPack）是一种紧凑的列表结构，它通过连续存储元素来节约内存空间。 当ZSet的元素数量增多时，Redis会自动将ZipList（ListPack）转换为SkipList，以保持元素的有序性和支持范围查询操作。</p><p>在这个过程中，Redis会遍历ZipList（ListPack）中的所有元素，按照元素的分数值依次将它们插入到SkipList中，这样就可以保持元素的有序性。</p><p>其中，SkipList用来实现有序集合，其中每个元素按照其分值大小在跳表中进行排序。跳表的插入、删除和查找操作的时间复杂度都是 O(log n)，可以保证较好的性能。</p><p>dict用来实现元素到分值的映射关系，其中元素作为键，分值作为值。哈希表的插入、删除和查找操作的时间复杂度都是 O(1)，具有非常高的性能。</p><h2 id="跳表" tabindex="-1"><a class="header-anchor" href="#跳表"><span>跳表</span></a></h2><p>跳表也是一个有序链表，相当于在链表的基础上加了索引，例如每隔2个元素建立一个索引，每隔3个元素建立一个索引，以此类推</p><p>通过比较大小的方式快速查询到元素</p><h2 id="为什么zset支持高效的范围查询-还可以-o-1-复杂度获取元素权重值" tabindex="-1"><a class="header-anchor" href="#为什么zset支持高效的范围查询-还可以-o-1-复杂度获取元素权重值"><span>为什么ZSet支持高效的范围查询？还可以 O(1) 复杂度获取元素权重值？</span></a></h2><p>支持范围查询，是因为使用了跳表；支持 O(1) 复杂度获取元素权重值，是因为用了哈希表</p><p>zset结构体定义如下：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> 
<span class="token punctuation">{</span> 
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span> 
    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zset<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>dict存储 member-&gt;score 之间的映射关系，所以 ZSCORE 的时间复杂度为 O(1)。</li><li>skiplist 是一个「有序链表 + 多层索引」的结构，查询元素的复杂度是 O(logN)，所以他的查询效率很高。</li></ul>`,14),p=[n];function o(l,c){return e(),s("div",null,p)}const h=t(a,[["render",o],["__file","zset-skiplist.html.vue"]]),u=JSON.parse('{"path":"/interview-shorthand/redis/data-structure/zset-skiplist.html","title":"Zset实现--跳表","lang":"zh-CN","frontmatter":{"title":"Zset实现--跳表","author":null,"category":"Redis","tag":"Redis","description":"Zset是怎么实现的？ Redis中的ZSet在实现中，有多种结构，大类的话有两种，分别是ziplist(压缩列表)和skiplist(跳跃表)，但是这只是以前，在Redis 5.0中新增了一个listpack（紧凑列表）的数据结构，这种数据结构就是为了替代ziplist的，而在之后Redis 7.0的发布中，在Zset的实现中，已经彻底不在使用zip...","head":[["meta",{"property":"og:url","content":"https://hollowlatte.github.io/Note-Book/Note-Book/interview-shorthand/redis/data-structure/zset-skiplist.html"}],["meta",{"property":"og:site_name","content":"Note-Book"}],["meta",{"property":"og:title","content":"Zset实现--跳表"}],["meta",{"property":"og:description","content":"Zset是怎么实现的？ Redis中的ZSet在实现中，有多种结构，大类的话有两种，分别是ziplist(压缩列表)和skiplist(跳跃表)，但是这只是以前，在Redis 5.0中新增了一个listpack（紧凑列表）的数据结构，这种数据结构就是为了替代ziplist的，而在之后Redis 7.0的发布中，在Zset的实现中，已经彻底不在使用zip..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-21T08:07:11.000Z"}],["meta",{"property":"article:author","content":"Hollow-Latte"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:modified_time","content":"2024-03-21T08:07:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Zset实现--跳表\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-21T08:07:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hollow-Latte\\",\\"url\\":\\"https://hollowlatte.github.io/Note-Book\\"}]}"]]},"headers":[{"level":2,"title":"Zset是怎么实现的？","slug":"zset是怎么实现的","link":"#zset是怎么实现的","children":[]},{"level":2,"title":"跳表","slug":"跳表","link":"#跳表","children":[]},{"level":2,"title":"为什么ZSet支持高效的范围查询？还可以 O(1) 复杂度获取元素权重值？","slug":"为什么zset支持高效的范围查询-还可以-o-1-复杂度获取元素权重值","link":"#为什么zset支持高效的范围查询-还可以-o-1-复杂度获取元素权重值","children":[]}],"git":{"createdTime":1711008431000,"updatedTime":1711008431000,"contributors":[{"name":"hollowlatte","email":"hollowlatte@outlook.com","commits":1}]},"readingTime":{"minutes":1.97,"words":592},"filePathRelative":"interview-shorthand/redis/data-structure/zset-skiplist.md","localizedDate":"2024年3月21日","excerpt":"<h2>Zset是怎么实现的？</h2>\\n<p>Redis中的ZSet在实现中，有多种结构，大类的话有两种，分别是ziplist(压缩列表)和skiplist(跳跃表)，但是这只是以前，在Redis\\n5.0中新增了一个listpack（紧凑列表）的数据结构，这种数据结构就是为了替代ziplist的，而在之后Redis\\n7.0的发布中，在Zset的实现中，已经彻底不在使用zipList了。</p>\\n<p>当ZSet的元素数量比较少时，Redis会采用ZipList（ListPack）来存储ZSet的数据。\\nZipList（ListPack）是一种紧凑的列表结构，它通过连续存储元素来节约内存空间。\\n当ZSet的元素数量增多时，Redis会自动将ZipList（ListPack）转换为SkipList，以保持元素的有序性和支持范围查询操作。</p>","autoDesc":true}');export{h as comp,u as data};
