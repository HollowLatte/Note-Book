import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as o,e as a}from"./app-DmUsX9Nr.js";const r={},l=a('<h2 id="什么是stop-the-world-stw" tabindex="-1"><a class="header-anchor" href="#什么是stop-the-world-stw"><span>什么是Stop The World(STW)？</span></a></h2><p>Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。 这是Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。</p><p><strong>不管选择哪种GC算法，stop-the-world都是不能彻底避免的，只能尽量降低STW的时长。</strong></p><h2 id="为什么要有stw-不全局暂停可以吗" tabindex="-1"><a class="header-anchor" href="#为什么要有stw-不全局暂停可以吗"><span>为什么要有STW？不全局暂停可以吗？</span></a></h2><p>首先，如果不暂停用户线程，就意味着GC期间会不断有垃圾产生，会影响标记垃圾，永远也清理不干净。</p><p>其次，用户线程的运行必然会导致对象的引用关系发生改变，这就会导致两种情况：漏标和多标。</p><h3 id="多标和漏标" tabindex="-1"><a class="header-anchor" href="#多标和漏标"><span>多标和漏标</span></a></h3><p><strong>多标</strong>：其实就是这个对象原本应该被回收掉的垃圾对象，但是被错误的标记成了存活对象。从而导致这个对象没有被GC回收掉。 这种情况还好一点，无非就是产生了一些浮动垃圾，下次GC再清理就好了。</p><blockquote><p>垃圾收集在标记的过程中，其实标记的并不是垃圾对象，而是通过可达性分析标记可达对象。 所以当一个对象本来是垃圾对象（不可达对象），但是错误的标记成非垃圾对象（可达对象）时，就是多标了。就会导致浮动垃圾。</p></blockquote><p><strong>漏标</strong>：一个对象本来应该是存活对象，但是没有被正确的标记上，导致被错误的垃圾回收掉了。</p><h2 id="什么情况会触发stw" tabindex="-1"><a class="header-anchor" href="#什么情况会触发stw"><span>什么情况会触发STW？</span></a></h2><p>Minor GC 和 Full GC 都会触发STW</p><p>Minor GC（Young GC）：主要针对年轻代垃圾回收，包括Eden区和Survivor区。STW 暂停时间通常较短，因为Minor GC只需要标记年轻代的垃圾 Full GC：对整个堆空间（包括年轻代和老年代）的垃圾回收。STW 暂停时间通常较长，因为需要对整个堆空间进行垃圾回收</p>',13),p=[l];function n(s,h){return e(),o("div",null,p)}const c=t(r,[["render",n],["__file","stop-the-world.html.vue"]]),T=JSON.parse('{"path":"/notebook/java/jvm/stop-the-world.html","title":"Stop The World(STW)","lang":"zh-CN","frontmatter":{"title":"Stop The World(STW)","author":null,"category":"JVM","tag":"JVM","date":"2024-02-29T00:00:00.000Z","description":"什么是Stop The World(STW)？ Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。 这是Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。 不管选择哪种GC算法，stop-the-world都是不能彻底避免的，只能尽量降低S...","head":[["meta",{"property":"og:url","content":"https://hollowlatte.github.io/Note-Book/Note-Book/notebook/java/jvm/stop-the-world.html"}],["meta",{"property":"og:site_name","content":"Note-Book"}],["meta",{"property":"og:title","content":"Stop The World(STW)"}],["meta",{"property":"og:description","content":"什么是Stop The World(STW)？ Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。 这是Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。 不管选择哪种GC算法，stop-the-world都是不能彻底避免的，只能尽量降低S..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-28T19:26:07.000Z"}],["meta",{"property":"article:author","content":"Hollow-Latte"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2024-02-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-28T19:26:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Stop The World(STW)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-29T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-28T19:26:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hollow-Latte\\",\\"url\\":\\"https://hollowlatte.github.io/Note-Book\\"}]}"]]},"headers":[{"level":2,"title":"什么是Stop The World(STW)？","slug":"什么是stop-the-world-stw","link":"#什么是stop-the-world-stw","children":[]},{"level":2,"title":"为什么要有STW？不全局暂停可以吗？","slug":"为什么要有stw-不全局暂停可以吗","link":"#为什么要有stw-不全局暂停可以吗","children":[{"level":3,"title":"多标和漏标","slug":"多标和漏标","link":"#多标和漏标","children":[]}]},{"level":2,"title":"什么情况会触发STW？","slug":"什么情况会触发stw","link":"#什么情况会触发stw","children":[]}],"git":{"createdTime":1711653967000,"updatedTime":1711653967000,"contributors":[{"name":"hollowlatte","email":"hollowlatte@outlook.com","commits":1}]},"readingTime":{"minutes":1.81,"words":542},"filePathRelative":"notebook/java/jvm/stop-the-world.md","localizedDate":"2024年2月29日","excerpt":"<h2>什么是Stop The World(STW)？</h2>\\n<p>Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。\\n这是Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。</p>\\n<p><strong>不管选择哪种GC算法，stop-the-world都是不能彻底避免的，只能尽量降低STW的时长。</strong></p>\\n<h2>为什么要有STW？不全局暂停可以吗？</h2>\\n<p>首先，如果不暂停用户线程，就意味着GC期间会不断有垃圾产生，会影响标记垃圾，永远也清理不干净。</p>","autoDesc":true}');export{c as comp,T as data};
