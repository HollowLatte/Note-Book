import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as o,e as a}from"./app-4HbIzINy.js";const r="/Note-Book/assets/jpa-select-cache-oom-C7Icd-OZ.png",p={},n=a('<h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h2><p><strong>JDK版本：</strong> <code>13</code></p><p><strong>JPA的版本：</strong> <code>org.springframework.boot:spring-boot-starter-data-jpa:3.1.5</code></p><p>用户数量有130万左右，每天相隔4个小时会进行增量同步用户数据，每日凌晨定时全量同步用户数据</p><h2 id="问题现象" tabindex="-1"><a class="header-anchor" href="#问题现象"><span>问题现象</span></a></h2><p>在凌晨进行全量同步用户数据时发生OOM</p><h2 id="可能原因" tabindex="-1"><a class="header-anchor" href="#可能原因"><span>可能原因</span></a></h2><p>一次加载的用户数据对象太多，撑爆堆内存了？</p><h2 id="原因分析" tabindex="-1"><a class="header-anchor" href="#原因分析"><span>原因分析</span></a></h2><p>一开始以为是一次加载的用户数据对象太多，导致撑爆堆内存了</p><p>查看业务代码后发现，每次都是拉一小批用户进行处理的，每批500，并且使用完后没有其他地方引用，不影响GC回收，堆应该不会爆</p><h3 id="hprof分析" tabindex="-1"><a class="header-anchor" href="#hprof分析"><span>hprof分析</span></a></h3><p>因为配置了<code>-XX:+HeapDumpOnOutOfMemoryError</code>，所以有dump出来的hprof文件，用Eclipse Memory Analyzer打开hprof文件</p><figure><img src="'+r+'" alt="堆内存分析" tabindex="0"><figcaption>堆内存分析</figcaption></figure><p>发现<code>org.springframework.orm.jpa.EntityManagerHolder</code>类，它的实例占用了堆内存的96%</p><p>在它里面，可以发现非常多的<code>cn.com.systec.system.modules.user.repo.entity.User</code> ，说明这些User对象一直在内存中，没有GC掉，但是很奇怪的是为什么这些User会在EntityManagerHolder里</p><p>去查阅JPA相关资料发现，这和JPA的一级缓存有关</p><h3 id="jpa一级缓存" tabindex="-1"><a class="header-anchor" href="#jpa一级缓存"><span>JPA一级缓存</span></a></h3><p>JPA的默认缓存机制是一级缓存（first-level caching），旨在提高性能。然而，在某些情况下，查询结果不是最新的数据库值。这是因为在同一事务中多次调用相同的查询时，Spring Data JPA会返回缓存中的结果，而不是直接访问数据库。</p><p>上面查询的User对象数据会缓存到JPA中，这些被JPA管理的User对象不会被GC，当JPA的一次Session处理的数据很多时，缓存的量也就越大，可能就会发生OOM</p><h2 id="问题原因" tabindex="-1"><a class="header-anchor" href="#问题原因"><span>问题原因</span></a></h2><p>每次查询用户数据时，JPA会缓存查询数据，当同步用户数量多时，缓存的对象过多会导致堆内存不足，发生OOM</p><h2 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法"><span>解决方法</span></a></h2><ul><li>调大JVM堆内存</li><li>JPA每次处理一批数据后，若之后没有很多地方使用这些数据的话，可以清除掉JPA的缓存。注入EntityManager的Bean， 然后使用<code>EntityManager.clear</code>来清除缓存</li></ul>',24),l=[n];function c(i,s){return t(),o("div",null,l)}const m=e(p,[["render",c],["__file","jpa-select-cache-oom.html.vue"]]),g=JSON.parse('{"path":"/problem/backend-problem/product-env-problem/jpa-select-cache-oom.html","title":"JPA查询导致OOM","lang":"zh-CN","frontmatter":{"title":"JPA查询导致OOM","author":null,"category":"JPA","tag":"JPA","date":"2024-03-20T00:00:00.000Z","description":"背景 JDK版本： 13 JPA的版本： org.springframework.boot:spring-boot-starter-data-jpa:3.1.5 用户数量有130万左右，每天相隔4个小时会进行增量同步用户数据，每日凌晨定时全量同步用户数据 问题现象 在凌晨进行全量同步用户数据时发生OOM 可能原因 一次加载的用户数据对象太多，撑爆堆内存...","head":[["meta",{"property":"og:url","content":"https://hollowlatte.github.io/Note-Book/Note-Book/problem/backend-problem/product-env-problem/jpa-select-cache-oom.html"}],["meta",{"property":"og:site_name","content":"Note-Book"}],["meta",{"property":"og:title","content":"JPA查询导致OOM"}],["meta",{"property":"og:description","content":"背景 JDK版本： 13 JPA的版本： org.springframework.boot:spring-boot-starter-data-jpa:3.1.5 用户数量有130万左右，每天相隔4个小时会进行增量同步用户数据，每日凌晨定时全量同步用户数据 问题现象 在凌晨进行全量同步用户数据时发生OOM 可能原因 一次加载的用户数据对象太多，撑爆堆内存..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-26T15:40:23.000Z"}],["meta",{"property":"article:author","content":"Hollow-Latte"}],["meta",{"property":"article:tag","content":"JPA"}],["meta",{"property":"article:published_time","content":"2024-03-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-26T15:40:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JPA查询导致OOM\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-20T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-26T15:40:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hollow-Latte\\",\\"url\\":\\"https://hollowlatte.github.io/Note-Book\\"}]}"]]},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"问题现象","slug":"问题现象","link":"#问题现象","children":[]},{"level":2,"title":"可能原因","slug":"可能原因","link":"#可能原因","children":[]},{"level":2,"title":"原因分析","slug":"原因分析","link":"#原因分析","children":[{"level":3,"title":"hprof分析","slug":"hprof分析","link":"#hprof分析","children":[]},{"level":3,"title":"JPA一级缓存","slug":"jpa一级缓存","link":"#jpa一级缓存","children":[]}]},{"level":2,"title":"问题原因","slug":"问题原因","link":"#问题原因","children":[]},{"level":2,"title":"解决方法","slug":"解决方法","link":"#解决方法","children":[]}],"git":{"createdTime":1711467623000,"updatedTime":1711467623000,"contributors":[{"name":"hollowlatte","email":"hollowlatte@outlook.com","commits":1}]},"readingTime":{"minutes":1.94,"words":582},"filePathRelative":"problem/backend-problem/product-env-problem/jpa-select-cache-oom.md","localizedDate":"2024年3月20日","excerpt":"<h2>背景</h2>\\n<p><strong>JDK版本：</strong> <code>13</code></p>\\n<p><strong>JPA的版本：</strong> <code>org.springframework.boot:spring-boot-starter-data-jpa:3.1.5</code></p>\\n<p>用户数量有130万左右，每天相隔4个小时会进行增量同步用户数据，每日凌晨定时全量同步用户数据</p>\\n<h2>问题现象</h2>\\n<p>在凌晨进行全量同步用户数据时发生OOM</p>\\n<h2>可能原因</h2>\\n<p>一次加载的用户数据对象太多，撑爆堆内存了？</p>","autoDesc":true}');export{m as comp,g as data};
