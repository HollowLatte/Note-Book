import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as o,e as a}from"./app-R-jbemKs.js";const r={},t=a('<h2 id="脏读的解决方式" tabindex="-1"><a class="header-anchor" href="#脏读的解决方式" aria-hidden="true">#</a> 脏读的解决方式</h2><p>InnoDB 通过在每行数据中添加一个隐藏的事务 ID 来实现 MVCC，当一个事务开始时，它会获取一个唯一的事务 ID，该事务 ID 被用来标记该事务所做的修改。当一个事务读取一行数据时，InnoDB 检查该行数据的事务 ID 是否小于当前事务的 ID，只有小于当前事务ID才是已提交的数据。否则，说明该行数据是未提交的数据，InnoDB 将阻止该事务读取该行数据，从而避免了脏读的问题。</p><h2 id="不可重复读的解决方式" tabindex="-1"><a class="header-anchor" href="#不可重复读的解决方式" aria-hidden="true">#</a> 不可重复读的解决方式</h2><p>InnoDB 通过使用 MVCC 来解决不可重复读的问题。在RR这种隔离级别下，当我们使用快照读进行数据读取的时候，只会在第一次读取的时候生成一个Read View，后续的所有快照读都是用的同一个快照，所以就不会发生不可重复读的问题了。</p><h2 id="幻读的解决方式" tabindex="-1"><a class="header-anchor" href="#幻读的解决方式" aria-hidden="true">#</a> 幻读的解决方式</h2><p>InnoDB的RR级别中，基于MVCC+间隙锁，是在某种程度上是可以避免幻读的发生的，<strong>但是没有办法完全避免</strong>，当一个事务中发生当前读的时候，会导致幻读的发生。</p>',6),c=[t];function d(h,i){return n(),o("div",null,c)}const l=e(r,[["render",d],["__file","innodb-how-to-solve-concurrence.html.vue"]]);export{l as default};
