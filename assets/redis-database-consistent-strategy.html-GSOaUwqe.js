import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,e as i}from"./app-CjdU_M7_.js";const h={},r=i('<p>有4种常见的策略，但是一般Cache Aside的方式是大多数场景下的常用方案，Cache Aside有又三种方式(变体)来处理缓存/数据库</p><h2 id="cache-aside" tabindex="-1"><a class="header-anchor" href="#cache-aside"><span>Cache Aside</span></a></h2><p>Cache Aside的三种变体都面临两个问题，删除缓存还是更新缓存？先删缓存还是后删缓存？</p><h3 id="删除还是更新缓存" tabindex="-1"><a class="header-anchor" href="#删除还是更新缓存"><span>删除还是更新缓存？</span></a></h3><p>首先，删除缓存是比较好的做法。</p><p>因为更新缓存的动作，相比于直接删除缓存，操作过程比较的复杂，而且也容易出错。通常缓存业务的一些数据时，都是以JSON的格式放到Redis中，那如果更新缓存的话还需要将该JSON反序列化，然后更新其中的信息，然后再序列化放回Redis，相比于删除操作复杂了很多</p><h3 id="先更新数据库后删缓存" tabindex="-1"><a class="header-anchor" href="#先更新数据库后删缓存"><span>先更新数据库后删缓存</span></a></h3><p>这种处理方式，一般来说是没问题的，但是在极端情况下还是会出现一致性问题</p><p>场景一：更新数据库成功，但是去删除缓存时，由于网络或者其他原因，删除缓存的操作失败，那么缓存中的数据就一直是以前的旧数据了 场景二：请求1从DB读数据A ---&gt; 请求2更新DB中的数据A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） ---&gt; 请求1将数据A 写入cache</p><p>适用场景：业务量不大，并发不高的情况下，可以选择该方式</p><h3 id="先删缓存后更新数据库" tabindex="-1"><a class="header-anchor" href="#先删缓存后更新数据库"><span>先删缓存后更新数据库</span></a></h3><p>该方式会无形中放大&quot;读写并发&quot;导致的数据不一致的问题。</p><p>例如该场景：请求1先把Cache中的A数据删除 ---&gt; 请求2从DB中读取数据 ---&gt; 请求1再把DB中的A数据更新</p><p><strong>这种问题的后果也比较严重，那就是缓存中的值一直是错的，就会导致后续的所有命中缓存的查询结果都是错的！</strong></p><h3 id="延迟双删" tabindex="-1"><a class="header-anchor" href="#延迟双删"><span>延迟双删</span></a></h3><p>TODO</p><h2 id="read-write-through" tabindex="-1"><a class="header-anchor" href="#read-write-through"><span>Read/Write Through</span></a></h2><p>在下面两种模式中，应用程序将缓存作为主要的数据源，不需要感知数据库，更新数据库和从数据库的读取的任务都交给缓存来代理。</p><p>这两种模式下，不需要应用自己去操作数据库，缓存自己就把活干完了。</p><h3 id="read-through" tabindex="-1"><a class="header-anchor" href="#read-through"><span>Read Through</span></a></h3><p>缓存配置一个读模块，它知道如何将数据库中的数据写入缓存</p><ul><li>Cache存在，读到即返回</li><li>Cache不存在，通过读模块从DB读取后写入Cache再返回</li></ul><h3 id="write-through" tabindex="-1"><a class="header-anchor" href="#write-through"><span>Write Through</span></a></h3><p>缓存配置一个写模块，它知道如何将数据写入数据库。</p><ul><li>Cache存在，先更新Cache，再通过写模块更新DB</li><li>Cache不存在，通过写模块直接更新DB</li></ul><h2 id="write-behind" tabindex="-1"><a class="header-anchor" href="#write-behind"><span>Write Behind</span></a></h2><p>只更新缓存，不直接更新 DB，而是定时通过异步批量的方式更新DB</p><p>这种模式的优缺点比较明显，那就是读写速度都很快，但是可能会造成一定的数据丢失。</p><p>这种比较适合用在比如统计文章的访问量、点赞等场景中，允许数据少量丢失，但是速度要快。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>要根据自身业务选择合适的策略</p>',31),o=[r];function s(n,l){return t(),a("div",null,o)}const p=e(h,[["render",s],["__file","redis-database-consistent-strategy.html.vue"]]),g=JSON.parse('{"path":"/notebook/redis/redis-database-consistent-strategy.html","title":"Redis与数据库一致性策略","lang":"zh-CN","frontmatter":{"title":"Redis与数据库一致性策略","author":null,"category":"Redis","tag":"Redis","description":"有4种常见的策略，但是一般Cache Aside的方式是大多数场景下的常用方案，Cache Aside有又三种方式(变体)来处理缓存/数据库 Cache Aside Cache Aside的三种变体都面临两个问题，删除缓存还是更新缓存？先删缓存还是后删缓存？ 删除还是更新缓存？ 首先，删除缓存是比较好的做法。 因为更新缓存的动作，相比于直接删除缓存，操...","head":[["meta",{"property":"og:url","content":"https://hollowlatte.github.io/Note-Book/Note-Book/notebook/redis/redis-database-consistent-strategy.html"}],["meta",{"property":"og:site_name","content":"Note-Book"}],["meta",{"property":"og:title","content":"Redis与数据库一致性策略"}],["meta",{"property":"og:description","content":"有4种常见的策略，但是一般Cache Aside的方式是大多数场景下的常用方案，Cache Aside有又三种方式(变体)来处理缓存/数据库 Cache Aside Cache Aside的三种变体都面临两个问题，删除缓存还是更新缓存？先删缓存还是后删缓存？ 删除还是更新缓存？ 首先，删除缓存是比较好的做法。 因为更新缓存的动作，相比于直接删除缓存，操..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-21T08:07:11.000Z"}],["meta",{"property":"article:author","content":"Hollow-Latte"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:modified_time","content":"2024-03-21T08:07:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis与数据库一致性策略\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-21T08:07:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hollow-Latte\\",\\"url\\":\\"https://hollowlatte.github.io/Note-Book\\"}]}"]]},"headers":[{"level":2,"title":"Cache Aside","slug":"cache-aside","link":"#cache-aside","children":[{"level":3,"title":"删除还是更新缓存？","slug":"删除还是更新缓存","link":"#删除还是更新缓存","children":[]},{"level":3,"title":"先更新数据库后删缓存","slug":"先更新数据库后删缓存","link":"#先更新数据库后删缓存","children":[]},{"level":3,"title":"先删缓存后更新数据库","slug":"先删缓存后更新数据库","link":"#先删缓存后更新数据库","children":[]},{"level":3,"title":"延迟双删","slug":"延迟双删","link":"#延迟双删","children":[]}]},{"level":2,"title":"Read/Write Through","slug":"read-write-through","link":"#read-write-through","children":[{"level":3,"title":"Read Through","slug":"read-through","link":"#read-through","children":[]},{"level":3,"title":"Write Through","slug":"write-through","link":"#write-through","children":[]}]},{"level":2,"title":"Write Behind","slug":"write-behind","link":"#write-behind","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1711008431000,"updatedTime":1711008431000,"contributors":[{"name":"hollowlatte","email":"hollowlatte@outlook.com","commits":1}]},"readingTime":{"minutes":2.82,"words":845},"filePathRelative":"notebook/redis/redis-database-consistent-strategy.md","localizedDate":"2024年3月21日","excerpt":"<p>有4种常见的策略，但是一般Cache Aside的方式是大多数场景下的常用方案，Cache Aside有又三种方式(变体)来处理缓存/数据库</p>\\n<h2>Cache Aside</h2>\\n<p>Cache Aside的三种变体都面临两个问题，删除缓存还是更新缓存？先删缓存还是后删缓存？</p>\\n<h3>删除还是更新缓存？</h3>\\n<p>首先，删除缓存是比较好的做法。</p>\\n<p>因为更新缓存的动作，相比于直接删除缓存，操作过程比较的复杂，而且也容易出错。通常缓存业务的一些数据时，都是以JSON的格式放到Redis中，那如果更新缓存的话还需要将该JSON反序列化，然后更新其中的信息，然后再序列化放回Redis，相比于删除操作复杂了很多</p>","autoDesc":true}');export{p as comp,g as data};
