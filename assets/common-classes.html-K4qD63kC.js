import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as a,e as r}from"./app-R-jbemKs.js";const l={},t=r('<h2 id="常见类及作用" tabindex="-1"><a class="header-anchor" href="#常见类及作用" aria-hidden="true">#</a> 常见类及作用</h2><p>Netty作为Java中使用广泛的NIO框架,其主要类和作用如下：</p><ul><li><strong>Channel</strong>：对套接字连接的抽象,用于处理连接的生命周期事件。</li><li><strong>ChannelHandler</strong>：用于处理Channel上的IO事件及数据处理逻辑,分为入站、出站Handler。</li><li><strong>ChannelPipeline</strong>：存放ChannelHandler的链,用于处理或拦截Channel的IO事件和数据。</li><li><strong>EventLoop</strong>：处理IO操作的线程,一个EventLoop可以处理多个Channel。</li><li><strong>EventLoopGroup</strong>：一组EventLoop,用于为Channel分配EventLoop。</li><li><strong>ChannelFuture</strong>：异步IO操作的结果容器,可以添加回调函数。</li><li><strong>Bootstrap</strong>：客户端启动助手类,用于连接服务器。</li><li><strong>ServerBootstrap</strong>：服务器启动引导类,用于绑定端口启动服务器。</li><li><strong>ByteBuf</strong>：Netty的数据容器,用于缓冲读写的数据。</li></ul><h2 id="常见encoder" tabindex="-1"><a class="header-anchor" href="#常见encoder" aria-hidden="true">#</a> 常见Encoder</h2><h3 id="messagetobyteencoder" tabindex="-1"><a class="header-anchor" href="#messagetobyteencoder" aria-hidden="true">#</a> MessageToByteEncoder</h3><p>MessageToByteEncoder 是一种出站的编码器,它将消息对象编码成字节码然后发送出站</p><p><strong>作用</strong>：</p><ol><li>将实现可序列化Serializable接口的消息对象编码为字节数组。</li><li>通过抽象方法encode()实现自定义的编码运算。</li><li>将消息编码为io.netty.buffer.ByteBuf类型的数据。</li><li>编码时可以获取ChannelHandlerContext相关的上下文信息。</li><li>线程安全的编码器实现。</li></ol><p><strong>使用案例</strong>：</p><ol><li>实现protobuf、json等格式的编码器。</li><li>将消息封装成自定义协议的字节码数据。</li><li>加密编码实现安全传输。</li><li>使用gzip等实现数据压缩编码。</li><li>结合WebSocket实现自定义帧数据编码。</li></ol><h2 id="常见decoder" tabindex="-1"><a class="header-anchor" href="#常见decoder" aria-hidden="true">#</a> 常见Decoder</h2><h3 id="bytetomessagedecoder" tabindex="-1"><a class="header-anchor" href="#bytetomessagedecoder" aria-hidden="true">#</a> ByteToMessageDecoder</h3><h3 id="lengthfieldbasedframedecoder" tabindex="-1"><a class="header-anchor" href="#lengthfieldbasedframedecoder" aria-hidden="true">#</a> LengthFieldBasedFrameDecoder</h3><p>LengthFieldBasedFrameDecoder 是 Netty 中一个非常常用的字节流解码器,它允许按照帧长度来解码字节数据,常用于处理setFixed长度帧的自定义协议解码。</p><p><strong>作用</strong>:</p><ol><li>可以把字节流拆分成按帧长度定义的消息包,解决粘包/拆包问题。</li><li>支持固定长度或者部分长度字段的协议解码。</li><li>可以处理异步串口、网络流等不定长字节流。</li><li>常与 LineBasedFrameDecoder 组合使用,实现分帧和分行解码器。</li><li>可配置长度字段的偏移量、长度和调整值来适应不同协议。</li><li>高性能的零拷贝实现,直接解码到 ByteBuf。</li></ol><p>如果需要实现自定义的变长协议解码,应该扩展 ByteToMessageDecoder;如果协议带长度字段,可以直接使用 LengthFieldBasedFrameDecoder 更加方便</p><h2 id="handler" tabindex="-1"><a class="header-anchor" href="#handler" aria-hidden="true">#</a> Handler</h2><h3 id="channelinboundhandleradapter" tabindex="-1"><a class="header-anchor" href="#channelinboundhandleradapter" aria-hidden="true">#</a> ChannelInboundHandlerAdapter</h3><p><strong>有下面几个常用方法</strong>：</p><ol><li><p><strong>channelRead</strong>： 这个方法会在收到入站数据时被调用,是最重要的一个方法。通常会在这个方法中实现对入站数据的处理逻辑,比如:</p><ul><li>对入站数据进行解码</li><li>处理业务逻辑</li><li>生成响应等</li></ul></li><li><p><strong>channelReadComplete</strong>： 会在channelRead()读取到入站数据结束时调用,可以在这个方法中发送响应数据。</p></li><li><p><strong>exceptionCaught</strong>： 用来处理发生的异常,避免异常传播导致程序终止。</p></li><li><p><strong>userEventTriggered</strong>： 可以用来处理自定义的用户事件,根据需要决定是否实现。</p></li><li><p><strong>channelRegistered/channelUnregistered</strong>： channel 的生命周期回调方法,可以在里面执行初始化或销毁的逻辑。</p></li><li><p><strong>channelActive/channelInactive</strong>： channel 连接激活或失活时调用,可以控制连接。</p></li></ol><p>Netty</p><p>https://blog.csdn.net/qq_38263083/article/details/131825724</p>',23),i=[t];function o(d,s){return n(),a("div",null,i)}const g=e(l,[["render",o],["__file","common-classes.html.vue"]]);export{g as default};
