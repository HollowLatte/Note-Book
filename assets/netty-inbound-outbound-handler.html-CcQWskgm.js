import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as l,c as o,b as d,a as n,e as r}from"./app-CjdU_M7_.js";const s={},i=n("h2",{id:"channelinbound-outboundhandler关系",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#channelinbound-outboundhandler关系"},[n("span",null,"ChannelInbound/OutboundHandler关系")])],-1),u=r(`<p><strong>实现自定义处理器：</strong></p><p>自定义Inbound入站处理器：</p><ol><li>继承<code>ChannelInboundHandlerAdapter</code></li><li>继承<code>SimpleChannelInboundHandler</code></li></ol><p>自定义Outbound入站处理器：</p><ol><li>继承<code>ChannelOutboundHandlerAdapter</code></li></ol><h3 id="适配器模式" tabindex="-1"><a class="header-anchor" href="#适配器模式"><span>适配器模式</span></a></h3><p>为什么实现自定义Handler时不直接实现ChannelInboundHandler、ChannelOutboundHandler接口，而是继承两者的适配器呢？</p><p>因为接口中有很多默认方法需要实现，所以这里就采用了适配器模式。适配器内部对ChannelInboundHandler、ChannelOutboundHandler接口方法做了默认的实现，所以当使用适配器时，只需要重写想要处理的方法就行，不需要实现ChannelInboundHandler、ChannelOutboundHandler接口内的所有方法</p><h2 id="simplechannelinboundhandler" tabindex="-1"><a class="header-anchor" href="#simplechannelinboundhandler"><span>SimpleChannelInboundHandler</span></a></h2><p>SimpleChannelInboundHandler 继承自 ChannelInboundHandlerAdapter，并提供了更方便的消息处理方式。</p><p>相比ChannelInboundHandlerAdapter，有以下几个优点：</p><ol><li><strong>泛型支持：</strong> SimpleChannelInboundHandler 是一个泛型类，可以指定处理的消息类型。这样，在处理消息时，不需要进行类型转换，可以直接获取到正确的消息类型，并进行相应的处理。</li><li><strong>消息自动释放：</strong> SimpleChannelInboundHandler 在处理完消息后，会ReferenceCountUtil.release自动释放消息对象。这减少了手动释放消息的工作量，避免了内存泄漏的风险。</li></ol><h3 id="read方法对比" tabindex="-1"><a class="header-anchor" href="#read方法对比"><span>Read方法对比</span></a></h3><p><strong>SimpleChannelInboundHandler的Read：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>ChannelInboundHandlerAdapter的Read：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看出，SimpleChannelInboundHandler的Read方法msg是带有类型的，不需要再进行类型转换了</p><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h3><p>虽然SimpleChannelInboundHandler进行了类型转换，但是看源码就知道，它是强转的，也就是说，如果接收到的数据与定义在泛型的类型原本就不一样，是转换不了的</p><p>所以，<strong>使用SimpleChannelInboundHandler自定义Handler时，仍然要这Handler之前添加decoder到ChannelPipeline</strong>，否则可能无法正常收到数据</p>`,21);function p(c,h){const e=t("Mermaid");return l(),o("div",null,[i,d(e,{id:"mermaid-3",code:"eJxLzkksLnbJTEwvSszlUgAC54zEvLzUHI/EvJSc1CIFmxpdXZiYZ15SfmleClSKkGr/0hLCyvX00MQcUxILSlBVo1qLoglVCoteVBk8viFNL5rfsGhGU4HiasK6sboN4oLgzNyCnFTsQcMFAKXModg="}),u])}const C=a(s,[["render",p],["__file","netty-inbound-outbound-handler.html.vue"]]),g=JSON.parse('{"path":"/notebook/netty/netty-inbound-outbound-handler.html","title":"ChannelInbound/OutboundHandler","lang":"zh-CN","frontmatter":{"title":"ChannelInbound/OutboundHandler","author":null,"category":"Netty","tag":"Netty","date":"2024-03-18T00:00:00.000Z","description":"ChannelInbound/OutboundHandler关系 实现自定义处理器： 自定义Inbound入站处理器： 继承ChannelInboundHandlerAdapter 继承SimpleChannelInboundHandler 自定义Outbound入站处理器： 继承ChannelOutboundHandlerAdapter 适配器模式 ...","head":[["meta",{"property":"og:url","content":"https://hollowlatte.github.io/Note-Book/Note-Book/notebook/netty/netty-inbound-outbound-handler.html"}],["meta",{"property":"og:site_name","content":"Note-Book"}],["meta",{"property":"og:title","content":"ChannelInbound/OutboundHandler"}],["meta",{"property":"og:description","content":"ChannelInbound/OutboundHandler关系 实现自定义处理器： 自定义Inbound入站处理器： 继承ChannelInboundHandlerAdapter 继承SimpleChannelInboundHandler 自定义Outbound入站处理器： 继承ChannelOutboundHandlerAdapter 适配器模式 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-21T08:07:11.000Z"}],["meta",{"property":"article:author","content":"Hollow-Latte"}],["meta",{"property":"article:tag","content":"Netty"}],["meta",{"property":"article:published_time","content":"2024-03-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-21T08:07:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ChannelInbound/OutboundHandler\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-21T08:07:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hollow-Latte\\",\\"url\\":\\"https://hollowlatte.github.io/Note-Book\\"}]}"]]},"headers":[{"level":2,"title":"ChannelInbound/OutboundHandler关系","slug":"channelinbound-outboundhandler关系","link":"#channelinbound-outboundhandler关系","children":[{"level":3,"title":"适配器模式","slug":"适配器模式","link":"#适配器模式","children":[]}]},{"level":2,"title":"SimpleChannelInboundHandler","slug":"simplechannelinboundhandler","link":"#simplechannelinboundhandler","children":[{"level":3,"title":"Read方法对比","slug":"read方法对比","link":"#read方法对比","children":[]},{"level":3,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[]}]}],"git":{"createdTime":1711008431000,"updatedTime":1711008431000,"contributors":[{"name":"hollowlatte","email":"hollowlatte@outlook.com","commits":1}]},"readingTime":{"minutes":1.61,"words":483},"filePathRelative":"notebook/netty/netty-inbound-outbound-handler.md","localizedDate":"2024年3月18日","excerpt":"<h2>ChannelInbound/OutboundHandler关系</h2>\\n<p><strong>实现自定义处理器：</strong></p>\\n<p>自定义Inbound入站处理器：</p>\\n<ol>\\n<li>继承<code>ChannelInboundHandlerAdapter</code></li>\\n<li>继承<code>SimpleChannelInboundHandler</code></li>\\n</ol>\\n<p>自定义Outbound入站处理器：</p>\\n<ol>\\n<li>继承<code>ChannelOutboundHandlerAdapter</code></li>\\n</ol>","autoDesc":true}');export{C as comp,g as data};
