import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as t,c as a,e as r}from"./app-R-jbemKs.js";const o="/Note-Book/assets/channel-buffer-selector-bi2ncOrC.png",n={},l=r('<h2 id="nio核心组件" tabindex="-1"><a class="header-anchor" href="#nio核心组件" aria-hidden="true">#</a> NIO核心组件</h2><p><strong>NIO 主要包括以下三个核心组件</strong>：</p><ul><li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer中，而写操作时将 Buffer中的数据写入到 Channel 中。</li><li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过Channel来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li><li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到Selector上，由Selector来分配线程来处理事件。</li></ul><figure><img src="'+o+'" alt="Buffer、Channel、Selector关系" tabindex="0"><figcaption>Buffer、Channel、Selector关系</figcaption></figure><h2 id="netty" tabindex="-1"><a class="header-anchor" href="#netty" aria-hidden="true">#</a> Netty</h2><p>Netty是基于Java NIO实现的网络应用框架。</p><p>Netty的核心IO模型是异步非阻塞的,这是建立在Java NIO的非阻塞IO基础之上的。相比于传统的BIO同步阻塞模型,NIO可以大大提高网络应用的性能和扩展能力。</p><p>Netty对Java NIO进行了抽象和封装,实现了Reactor模式来做到异步非阻塞,其主要基于Java NIO的抽象有:</p><ul><li>使用Java NIO的Channel、Selector、ByteBuffer等作为异步IO的基础。</li><li>基于Java NIO的SocketChannel实现了异步客户端和服务端。</li><li>通过ByteBuf抽象了虚拟缓存区,用于高效处理字节数据。</li><li>用Pipeline、ChannelHandler等实现了拦截过滤链模式。</li><li>基于Selector实现了异步非阻塞的事件驱动模型。</li><li>提供了各种协议的编解码器和框架。</li><li>简化和扩展了线程模型的使用。</li></ul><p>综上,Netty对Java NIO的抽象使其更易于使用,并构建了一个灵活强大的异步网络应用框架。所以可以说Netty是基于Java NIO之上进行模块化设计实现的。</p><h2 id="reactor模型" tabindex="-1"><a class="header-anchor" href="#reactor模型" aria-hidden="true">#</a> Reactor模型</h2><p>Reactor 模型是一种设计模式,用于构建高并发和高性能的网络服务器。</p><p>Reactor 模型的核心是事件驱动，使用非阻塞IO实现事件驱动架构, 通过事件与处理分离、队列传递消息实现高并发。 正是因为事件驱动,Reactor才能高效地响应大量客户端、实现高性能服务器。</p><p><strong>应用案例</strong>：</p><ul><li>Nginx</li><li>Tomcat</li><li>Node.js</li><li>Kafka</li></ul><h3 id="reactor模型——主从多线程模型-父子多线程模型" tabindex="-1"><a class="header-anchor" href="#reactor模型——主从多线程模型-父子多线程模型" aria-hidden="true">#</a> Reactor模型——主从多线程模型（父子多线程模型）</h3><p>主从Reactor 模式中，分为主 Reactor 和 从 Reactor，分别处理 新建立的连接、IO读写事件/事件分发</p><p><strong>主Reactor</strong>：只负责接受新连接，不做具体的数据处理。</p><p><strong>从Reactor</strong>：负责处理连接的所有读写和数据操作。</p><ul><li>主Reactor 只关注接受新连接,处理简单,效率高。可以解决同一时间大量新连接</li><li>从Reactor 处理比接收新连接复杂得多的读写和业务,可以支撑很多连接。</li><li>主从多线程模型由多个 Reactor 线程组成，每个 Reactor 线程都有独立的 Selector 对象。MainReactor 仅负责处理客户端连接的 Accept 事件，连接建立成功后将新创建的连接对象注册至 SubReactor。再由 SubReactor 分配线程池中的 I/O 线程与其连接绑定，它将负责连接生命周期内所有的 I/O 事件。</li></ul>',20),i=[l];function c(s,h){return t(),a("div",null,i)}const d=e(n,[["render",c],["__file","core-concepts.html.vue"]]);export{d as default};
