const e=JSON.parse('{"key":"v-32d7ae5c","path":"/java/collection/delayqueue-source-code.html","title":"","lang":"zh-CN","frontmatter":{"description":"DelayQueue简介 DelayQueue是JUC包(java.util.concurrent)为我们提供的延迟队列，它是一个基于PriorityQueue实现的一个无界队列，是一个线程安全的延迟队列。 关于PriorityQueue可以参考笔者编写的这篇文章: PriorityQueue源码分析 当我们希望某个任务在某个时间才能取出并操作时，我们就可以让这个继承Delayed接口，实现其计算任务到期时间的方法 getDelay 。然后将任务存放到 DelayQueue 中,默认情况下, DelayQueue 会按照到期时间升序编排任务。随后当 DelayQueue 发现任务到期时，我们才能从 DelayQueue 中取出这个任务并执行。","head":[["meta",{"property":"og:url","content":"https://hollowlatte.github.io/Note-Book/Note-Book/java/collection/delayqueue-source-code.html"}],["meta",{"property":"og:site_name","content":"Note-Book"}],["meta",{"property":"og:description","content":"DelayQueue简介 DelayQueue是JUC包(java.util.concurrent)为我们提供的延迟队列，它是一个基于PriorityQueue实现的一个无界队列，是一个线程安全的延迟队列。 关于PriorityQueue可以参考笔者编写的这篇文章: PriorityQueue源码分析 当我们希望某个任务在某个时间才能取出并操作时，我们就可以让这个继承Delayed接口，实现其计算任务到期时间的方法 getDelay 。然后将任务存放到 DelayQueue 中,默认情况下, DelayQueue 会按照到期时间升序编排任务。随后当 DelayQueue 发现任务到期时，我们才能从 DelayQueue 中取出这个任务并执行。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Hollow-Latte"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hollow-Latte\\",\\"url\\":\\"https://hollowlatte.github.io/Note-Book\\"}]}"]]},"headers":[{"level":2,"title":"DelayQueue简介","slug":"delayqueue简介","link":"#delayqueue简介","children":[]},{"level":2,"title":"DelayQueue发展史","slug":"delayqueue发展史","link":"#delayqueue发展史","children":[]},{"level":2,"title":"DelayQueue常见使用场景示例","slug":"delayqueue常见使用场景示例","link":"#delayqueue常见使用场景示例","children":[]},{"level":2,"title":"DelayQueue源码解析","slug":"delayqueue源码解析","link":"#delayqueue源码解析","children":[{"level":3,"title":"核心成员变量","slug":"核心成员变量","link":"#核心成员变量","children":[]},{"level":3,"title":"构造方法","slug":"构造方法","link":"#构造方法","children":[]},{"level":3,"title":"添加元素","slug":"添加元素","link":"#添加元素","children":[]},{"level":3,"title":"获取元素","slug":"获取元素","link":"#获取元素","children":[]},{"level":3,"title":"查看元素","slug":"查看元素","link":"#查看元素","children":[]}]},{"level":2,"title":"DelayQueue常见面试题","slug":"delayqueue常见面试题","link":"#delayqueue常见面试题","children":[{"level":3,"title":"DelayQueue 的实现原理是什么？","slug":"delayqueue-的实现原理是什么","link":"#delayqueue-的实现原理是什么","children":[]},{"level":3,"title":"DelayQueue 的使用场景有哪些？","slug":"delayqueue-的使用场景有哪些","link":"#delayqueue-的使用场景有哪些","children":[]},{"level":3,"title":"DelayQueue 中 Delayed 接口的作用是什么？","slug":"delayqueue-中-delayed-接口的作用是什么","link":"#delayqueue-中-delayed-接口的作用是什么","children":[]},{"level":3,"title":"DelayQueue 和 Timer/TimerTask 的区别是什么？","slug":"delayqueue-和-timer-timertask-的区别是什么","link":"#delayqueue-和-timer-timertask-的区别是什么","children":[]},{"level":3,"title":"DelayQueue 的实现是否线程安全？","slug":"delayqueue-的实现是否线程安全","link":"#delayqueue-的实现是否线程安全","children":[]},{"level":3,"title":"实现延迟队列的几种方式","slug":"实现延迟队列的几种方式","link":"#实现延迟队列的几种方式","children":[]}]},{"level":2,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}],"git":{},"readingTime":{"minutes":17.29,"words":5187},"filePathRelative":"java/collection/delayqueue-source-code.md","excerpt":"<h2> DelayQueue简介</h2>\\n<p>DelayQueue是JUC包(java.util.concurrent)为我们提供的延迟队列，它是一个基于PriorityQueue实现的一个无界队列，是一个线程安全的延迟队列。</p>\\n<p>关于PriorityQueue可以参考笔者编写的这篇文章:</p>\\n<p><a href=\\"http://t.csdn.cn/XJuAf\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">PriorityQueue源码分析</a></p>\\n<p>当我们希望某个任务在某个时间才能取出并操作时，我们就可以让这个继承Delayed接口，实现其计算任务到期时间的方法 getDelay 。然后将任务存放到 DelayQueue 中,默认情况下, DelayQueue 会按照到期时间升序编排任务。随后当 DelayQueue 发现任务到期时，我们才能从 DelayQueue 中取出这个任务并执行。</p>","autoDesc":true}');export{e as data};
