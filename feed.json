{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Note-Book",
  "home_page_url": "https://hollowlatte.github.io/Note-Book/Note-Book/",
  "feed_url": "https://hollowlatte.github.io/Note-Book/Note-Book/feed.json",
  "description": "「Java学习指北 + Java面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，复习 Java 知识点，首选 JavaGuide！  ",
  "favicon": "https://hollowlatte.github.io/Note-Book/Note-Book/favicon.ico",
  "items": [
    {
      "title": "JavaGuide（Java学习&面试指南）",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/home.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/home.html",
      "summary": "友情提示 logologo 阅读 Stars forks issues GitHub | Gitee Java 基础 知识点/面试题总结 : (必看👍 )： 重要知识点详解： 集合 知识点/面试题总结： (必看 👍) (必看 👍) 源码分析： IO 并发 知识点/面试题总结 : (必看 👍) 重要知识点详解： **线程池 **：、 JVM (必...",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">友情提示</p>\n</div>\n<div align=\"center\">\n<figure><a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/1c00413c65d1995993bf2b0daf7b4f03.png\" alt=\"logo\" tabindex=\"0\"></a><figcaption>logo</figcaption></figure>\n<p><a href=\"https://javaguide.cn/\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/阅读-read-brightgreen.svg\" alt=\"阅读\"></a>\n<img src=\"https://img.shields.io/github/stars/Snailclimb/JavaGuide\" alt=\"Stars\">\n<img src=\"https://img.shields.io/github/forks/Snailclimb/JavaGuide\" alt=\"forks\">\n<img src=\"https://img.shields.io/github/issues/Snailclimb/JavaGuide\" alt=\"issues\"></p>\n<p><a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a> | <a href=\"https://gitee.com/SnailClimb/JavaGuide\" target=\"_blank\" rel=\"noopener noreferrer\">Gitee</a></p>\n</div>\n<h2>Java</h2>\n<h3>基础</h3>\n<p><strong>知识点/面试题总结</strong> : (必看👍 )：</p>\n<ul>\n<li><a href=\"/Note-Book/java/basis/java-basic-questions-01.html\" target=\"_blank\">Java 基础常见知识点&amp;面试题总结(上)</a></li>\n<li><a href=\"/Note-Book/java/basis/java-basic-questions-02.html\" target=\"_blank\">Java 基础常见知识点&amp;面试题总结(中)</a></li>\n<li><a href=\"/Note-Book/java/basis/java-basic-questions-03.html\" target=\"_blank\">Java 基础常见知识点&amp;面试题总结(下)</a></li>\n</ul>\n<p><strong>重要知识点详解</strong>：</p>\n<ul>\n<li><a href=\"/Note-Book/java/basis/why-there-only-value-passing-in-java.html\" target=\"_blank\">为什么 Java 中只有值传递？</a></li>\n<li><a href=\"/Note-Book/java/basis/serialization.html\" target=\"_blank\">Java 序列化详解</a></li>\n<li><a href=\"/Note-Book/java/basis/reflection.html\" target=\"_blank\">Java 反射机制详解</a></li>\n<li><a href=\"/Note-Book/java/basis/proxy.html\" target=\"_blank\">Java 代理模式详解</a></li>\n<li><a href=\"/Note-Book/java/basis/bigdecimal.html\" target=\"_blank\">BigDecimal 详解</a></li>\n<li><a href=\"/Note-Book/java/basis/unsafe.html\" target=\"_blank\">Java 魔法类 Unsafe 详解</a></li>\n<li><a href=\"/Note-Book/java/basis/spi.html\" target=\"_blank\">Java SPI 机制详解</a></li>\n<li><a href=\"/Note-Book/java/basis/syntactic-sugar.html\" target=\"_blank\">Java 语法糖详解</a></li>\n</ul>\n<h3>集合</h3>\n<p><strong>知识点/面试题总结</strong>：</p>\n<ul>\n<li><a href=\"/Note-Book/java/collection/java-collection-questions-01.html\" target=\"_blank\">Java 集合常见知识点&amp;面试题总结(上)</a> (必看 👍)</li>\n<li><a href=\"/Note-Book/java/collection/java-collection-questions-02.html\" target=\"_blank\">Java 集合常见知识点&amp;面试题总结(下)</a> (必看 👍)</li>\n<li><a href=\"/Note-Book/java/collection/java-collection-precautions-for-use.html\" target=\"_blank\">Java 容器使用注意事项总结</a></li>\n</ul>\n<p><strong>源码分析</strong>：</p>\n<ul>\n<li><a href=\"/Note-Book/java/collection/arraylist-source-code.html\" target=\"_blank\">ArrayList 核心源码+扩容机制分析</a></li>\n<li><a href=\"/Note-Book/java/collection/linkedlist-source-code.html\" target=\"_blank\">LinkedList 核心源码分析</a></li>\n<li><a href=\"/Note-Book/java/collection/hashmap-source-code.html\" target=\"_blank\">HashMap 核心源码+底层数据结构分析</a></li>\n<li><a href=\"/Note-Book/java/collection/concurrent-hash-map-source-code.html\" target=\"_blank\">ConcurrentHashMap 核心源码+底层数据结构分析</a></li>\n<li><a href=\"/Note-Book/java/collection/copyonwritearraylist-source-code.html\" target=\"_blank\">CopyOnWriteArrayList 核心源码分析</a></li>\n<li><a href=\"/Note-Book/java/collection/arrayblockingqueue-source-code.html\" target=\"_blank\">ArrayBlockingQueue 核心源码分析</a></li>\n</ul>\n<h3>IO</h3>\n<ul>\n<li><a href=\"/Note-Book/java/io/io-basis.html\" target=\"_blank\">IO 基础知识总结</a></li>\n<li><a href=\"/Note-Book/java/io/io-design-patterns.html\" target=\"_blank\">IO 设计模式总结</a></li>\n<li><a href=\"/Note-Book/java/io/io-model.html\" target=\"_blank\">IO 模型详解</a></li>\n<li><a href=\"/Note-Book/java/io/nio-basis.html\" target=\"_blank\">NIO 核心知识总结</a></li>\n</ul>\n<h3>并发</h3>\n<p><strong>知识点/面试题总结</strong> : (必看 👍)</p>\n<ul>\n<li><a href=\"/Note-Book/java/concurrent/java-concurrent-questions-01.html\" target=\"_blank\">Java 并发常见知识点&amp;面试题总结（上）</a></li>\n<li><a href=\"/Note-Book/java/concurrent/java-concurrent-questions-02.html\" target=\"_blank\">Java 并发常见知识点&amp;面试题总结（中）</a></li>\n<li><a href=\"/Note-Book/java/concurrent/java-concurrent-questions-03.html\" target=\"_blank\">Java 并发常见知识点&amp;面试题总结（下）</a></li>\n</ul>\n<p><strong>重要知识点详解</strong>：</p>\n<ul>\n<li><a href=\"/Note-Book/java/concurrent/jmm.html\" target=\"_blank\">JMM（Java 内存模型）详解</a></li>\n<li>**线程池\n**：<a href=\"/Note-Book/java/concurrent/java-thread-pool-summary.html\" target=\"_blank\">Java 线程池详解</a>、<a href=\"/Note-Book/java/concurrent/java-thread-pool-best-practices.html\" target=\"_blank\">Java 线程池最佳实践</a></li>\n<li><a href=\"/Note-Book/java/concurrent/threadlocal.html\" target=\"_blank\">ThreadLocal 详解</a></li>\n<li><a href=\"/Note-Book/java/concurrent/java-concurrent-collections.html\" target=\"_blank\">Java 并发容器总结</a></li>\n<li><a href=\"/Note-Book/java/concurrent/atomic-classes.html\" target=\"_blank\">Atomic 原子类总结</a></li>\n<li><a href=\"/Note-Book/java/concurrent/aqs.html\" target=\"_blank\">AQS 详解</a></li>\n<li><a href=\"/Note-Book/java/concurrent/completablefuture-intro.html\" target=\"_blank\">CompletableFuture 详解</a></li>\n</ul>\n<h3>JVM (必看 👍)</h3>\n<p>JVM 这部分内容主要参考 <a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">JVM 虚拟机规范-Java8</a>\n和周志明老师的<a href=\"https://book.douban.com/subject/34907497/\" target=\"_blank\" rel=\"noopener noreferrer\">《深入理解 Java 虚拟机（第 3 版）》</a> （强烈建议阅读多遍！）。</p>\n<ul>\n<li><strong><a href=\"/Note-Book/java/jvm/memory-area.html\" target=\"_blank\">Java 内存区域</a></strong></li>\n<li><strong><a href=\"/Note-Book/java/jvm/jvm-garbage-collection.html\" target=\"_blank\">JVM 垃圾回收</a></strong></li>\n<li><a href=\"/Note-Book/java/jvm/class-file-structure.html\" target=\"_blank\">类文件结构</a></li>\n<li><strong><a href=\"/Note-Book/java/jvm/class-loading-process.html\" target=\"_blank\">类加载过程</a></strong></li>\n<li><a href=\"/Note-Book/java/jvm/classloader.html\" target=\"_blank\">类加载器</a></li>\n<li><a href=\"/Note-Book/java/jvm/jvm-parameters-intro.html\" target=\"_blank\">【待完成】最重要的 JVM 参数总结（翻译完善了一半）</a></li>\n<li><a href=\"/Note-Book/java/jvm/jvm-intro.html\" target=\"_blank\">【加餐】大白话带你认识 JVM</a></li>\n<li><a href=\"/Note-Book/java/jvm/jdk-monitoring-and-troubleshooting-tools.html\" target=\"_blank\">JDK 监控和故障处理工具</a></li>\n</ul>\n<h3>新特性</h3>\n<ul>\n<li>**Java 8\n**：<a href=\"/Note-Book/java/new-features/java8-tutorial-translate.html\" target=\"_blank\">Java 8 新特性总结（翻译）</a>、<a href=\"/Note-Book/java/new-features/java8-common-new-features.html\" target=\"_blank\">Java8 常用新特性总结</a></li>\n<li><a href=\"/Note-Book/java/new-features/java9.html\" target=\"_blank\">Java 9 新特性概览</a></li>\n<li><a href=\"/Note-Book/java/new-features/java10.html\" target=\"_blank\">Java 10 新特性概览</a></li>\n<li><a href=\"/Note-Book/java/new-features/java11.html\" target=\"_blank\">Java 11 新特性概览</a></li>\n<li><a href=\"/Note-Book/java/new-features/java12-13.html\" target=\"_blank\">Java 12 &amp; 13 新特性概览</a></li>\n<li><a href=\"/Note-Book/java/new-features/java14-15.html\" target=\"_blank\">Java 14 &amp; 15 新特性概览</a></li>\n<li><a href=\"/Note-Book/java/new-features/java16.html\" target=\"_blank\">Java 16 新特性概览</a></li>\n<li><a href=\"/Note-Book/java/new-features/java17.html\" target=\"_blank\">Java 17 新特性概览</a></li>\n<li><a href=\"/Note-Book/java/new-features/java18.html\" target=\"_blank\">Java 18 新特性概览</a></li>\n<li><a href=\"/Note-Book/java/new-features/java19.html\" target=\"_blank\">Java 19 新特性概览</a></li>\n<li><a href=\"/Note-Book/java/new-features/java20.html\" target=\"_blank\">Java 20 新特性概览</a></li>\n</ul>\n<h2>数据库</h2>\n<h3>基础</h3>\n<ul>\n<li><a href=\"/Note-Book/database/basis.html\" target=\"_blank\">数据库基础知识总结</a></li>\n<li><a href=\"/Note-Book/database/nosql.html\" target=\"_blank\">NoSQL 基础知识总结</a></li>\n<li><a href=\"/Note-Book/database/character-set.html\" target=\"_blank\">字符集详解</a></li>\n<li>SQL :\n<ul>\n<li><a href=\"/Note-Book/database/sql/sql-syntax-summary.html\" target=\"_blank\">SQL 语法基础知识总结</a></li>\n<li><a href=\"/Note-Book/database/sql/sql-questions-01.html\" target=\"_blank\">SQL 常见面试题总结</a></li>\n</ul>\n</li>\n</ul>\n<h3>MySQL</h3>\n<p><strong>知识点/面试题总结：</strong></p>\n<ul>\n<li><strong><a href=\"/Note-Book/database/mysql/mysql-questions-01.html\" target=\"_blank\">MySQL 常见知识点&amp;面试题总结</a></strong> (必看 👍)</li>\n<li><a href=\"/Note-Book/database/mysql/mysql-high-performance-optimization-specification-recommendations.html\" target=\"_blank\">MySQL 高性能优化规范建议总结</a></li>\n</ul>\n<p><strong>重要知识点：</strong></p>\n<ul>\n<li><a href=\"/Note-Book/database/mysql/mysql-index.html\" target=\"_blank\">MySQL 索引详解</a></li>\n<li><a href=\"/Note-Book/database/mysql/transaction-isolation-level.html\" target=\"_blank\">MySQL 事务隔离级别图文详解)</a></li>\n<li><a href=\"/Note-Book/database/mysql/mysql-logs.html\" target=\"_blank\">MySQL 三大日志(binlog、redo log 和 undo log)详解</a></li>\n<li><a href=\"/Note-Book/database/mysql/innodb-implementation-of-mvcc.html\" target=\"_blank\">InnoDB 存储引擎对 MVCC 的实现</a></li>\n<li><a href=\"/Note-Book/database/mysql/how-sql-executed-in-mysql.html\" target=\"_blank\">SQL 语句在 MySQL 中的执行过程</a></li>\n<li><a href=\"/Note-Book/database/mysql/mysql-query-cache.html\" target=\"_blank\">MySQL 查询缓存详解</a></li>\n<li><a href=\"/Note-Book/database/mysql/mysql-query-execution-plan.html\" target=\"_blank\">MySQL 执行计划分析</a></li>\n<li><a href=\"/Note-Book/database/mysql/mysql-auto-increment-primary-key-continuous.html\" target=\"_blank\">MySQL 自增主键一定是连续的吗</a></li>\n<li><a href=\"/Note-Book/database/mysql/some-thoughts-on-database-storage-time.html\" target=\"_blank\">MySQL 时间类型数据存储建议</a></li>\n<li><a href=\"/Note-Book/database/mysql/index-invalidation-caused-by-implicit-conversion.html\" target=\"_blank\">MySQL 隐式转换造成索引失效</a></li>\n</ul>\n<h3>Redis</h3>\n<p><strong>知识点/面试题总结</strong> : (必看👍 )：</p>\n<ul>\n<li><a href=\"/Note-Book/database/redis/redis-questions-01.html\" target=\"_blank\">Redis 常见知识点&amp;面试题总结(上)</a></li>\n<li><a href=\"/Note-Book/database/redis/redis-questions-02.html\" target=\"_blank\">Redis 常见知识点&amp;面试题总结(下)</a></li>\n</ul>\n<p><strong>重要知识点：</strong></p>\n<ul>\n<li><a href=\"/Note-Book/database/redis/3-commonly-used-cache-read-and-write-strategies.html\" target=\"_blank\">3 种常用的缓存读写策略详解</a></li>\n<li><a href=\"/Note-Book/database/redis/redis-data-structures-01.html\" target=\"_blank\">Redis 5 种基本数据结构详解</a></li>\n<li><a href=\"/Note-Book/database/redis/redis-data-structures-02.html\" target=\"_blank\">Redis 3 种特殊数据结构详解</a></li>\n<li><a href=\"/Note-Book/database/redis/redis-persistence.html\" target=\"_blank\">Redis 持久化机制详解</a></li>\n<li><a href=\"/Note-Book/database/redis/redis-memory-fragmentation.html\" target=\"_blank\">Redis 内存碎片详解</a></li>\n<li><a href=\"/Note-Book/database/redis/redis-common-blocking-problems-summary.html\" target=\"_blank\">Redis 常见阻塞原因总结</a></li>\n</ul>\n<h3>MongoDB</h3>\n<ul>\n<li><a href=\"/Note-Book/database/mongodb/mongodb-questions-01.html\" target=\"_blank\">MongoDB 常见知识点&amp;面试题总结(上)</a></li>\n<li><a href=\"/Note-Book/database/mongodb/mongodb-questions-02.html\" target=\"_blank\">MongoDB 常见知识点&amp;面试题总结(下)</a></li>\n</ul>\n<h2>搜索引擎</h2>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n<h2>开发工具</h2>\n<h3>Maven</h3>\n<p><a href=\"/Note-Book/tools/maven/maven-core-concepts.html\" target=\"_blank\">Maven 核心概念总结</a></p>\n<h3>Gradle</h3>\n<p><a href=\"/Note-Book/tools/gradle/gradle-core-concepts.html\" target=\"_blank\">Gradle 核心概念总结</a>（可选，目前国内还是使用 Maven 普遍一些）</p>\n<h3>Docker</h3>\n<ul>\n<li><a href=\"/Note-Book/tools/docker/docker-intro.html\" target=\"_blank\">Docker 核心概念总结</a></li>\n<li><a href=\"/Note-Book/tools/docker/docker-in-action.html\" target=\"_blank\">Docker 实战</a></li>\n</ul>\n<h3>Git</h3>\n<ul>\n<li><a href=\"/Note-Book/tools/git/git-intro.html\" target=\"_blank\">Git 核心概念总结</a></li>\n<li><a href=\"/Note-Book/tools/git/github-tips.html\" target=\"_blank\">GitHub 实用小技巧总结</a></li>\n</ul>\n<h2>系统设计</h2>\n<ul>\n<li><a href=\"/Note-Book/system-design/design-pattern.html\" target=\"_blank\">设计模式常见面试题总结</a></li>\n</ul>\n<h3>基础</h3>\n<ul>\n<li><a href=\"/Note-Book/system-design/basis/RESTfulAPI.html\" target=\"_blank\">RestFul API 简明教程</a></li>\n<li><a href=\"/Note-Book/system-design/basis/software-engineering.html\" target=\"_blank\">软件工程简明教程简明教程</a></li>\n<li><a href=\"/Note-Book/system-design/basis/naming.html\" target=\"_blank\">代码命名指南</a></li>\n<li><a href=\"/Note-Book/system-design/basis/refactoring.html\" target=\"_blank\">代码重构指南</a></li>\n<li><a href=\"/Note-Book/system-design/basis/unit-test.html\" target=\"_blank\">单元测试指南</a></li>\n</ul>\n<h3>常用框架</h3>\n<h4>Spring/SpringBoot (必看 👍)</h4>\n<p><strong>知识点/面试题总结</strong> :</p>\n<ul>\n<li><a href=\"/Note-Book/system-design/framework/spring/spring-knowledge-and-questions-summary.html\" target=\"_blank\">Spring 常见知识点&amp;面试题总结</a></li>\n<li><a href=\"/Note-Book/system-design/framework/spring/spring-common-annotations.html\" target=\"_blank\">Spring/Spring Boot 常用注解总结</a></li>\n<li><a href=\"https://github.com/Snailclimb/springboot-guide\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot 入门指南</a></li>\n</ul>\n<p><strong>重要知识点详解</strong>：</p>\n<ul>\n<li><a href=\"/Note-Book/system-design/framework/spring/spring-transaction.html\" target=\"_blank\">Spring 事务详解</a></li>\n<li><a href=\"/Note-Book/system-design/framework/spring/spring-design-patterns-summary.html\" target=\"_blank\">Spring 中的设计模式详解</a></li>\n<li><a href=\"/Note-Book/system-design/framework/spring/spring-boot-auto-assembly-principles.html\" target=\"_blank\">SpringBoot 自动装配原理详解</a></li>\n</ul>\n<h4>MyBatis</h4>\n<p><a href=\"/Note-Book/system-design/framework/mybatis/mybatis-interview.html\" target=\"_blank\">MyBatis 常见面试题总结</a></p>\n<h3>安全</h3>\n<h4>认证授权</h4>\n<ul>\n<li><a href=\"/Note-Book/system-design/security/basis-of-authority-certification.html\" target=\"_blank\">认证授权基础概念详解</a></li>\n<li><a href=\"/Note-Book/system-design/security/jwt-intro.html\" target=\"_blank\">JWT 基础概念详解</a></li>\n<li><a href=\"/Note-Book/system-design/security/advantages-and-disadvantages-of-jwt.html\" target=\"_blank\">JWT 优缺点分析以及常见问题解决方案</a></li>\n<li><a href=\"/Note-Book/system-design/security/sso-intro.html\" target=\"_blank\">SSO 单点登录详解</a></li>\n<li><a href=\"/Note-Book/system-design/security/design-of-authority-system.html\" target=\"_blank\">权限系统设计详解</a></li>\n<li><a href=\"/Note-Book/system-design/security/encryption-algorithms.html\" target=\"_blank\">常见加密算法总结</a></li>\n</ul>\n<h4>数据脱敏</h4>\n<p>数据脱敏说的就是我们根据特定的规则对敏感信息数据进行变形，比如我们把手机号、身份证号某些位数使用 * 来代替。</p>\n<h4>敏感词过滤</h4>\n<p><a href=\"/Note-Book/system-design/security/sentive-words-filter.html\" target=\"_blank\">敏感词过滤方案总结</a></p>\n<h3>定时任务</h3>\n<p><a href=\"/Note-Book/system-design/schedule-task.html\" target=\"_blank\">Java 定时任务详解</a></p>\n<h3>Web 实时消息推送</h3>\n<p><a href=\"/Note-Book/system-design/web-real-time-message-push.html\" target=\"_blank\">Web 实时消息推送详解</a></p>\n<h2>分布式</h2>\n<h3>理论&amp;算法&amp;协议</h3>\n<ul>\n<li><a href=\"/Note-Book/distributed-system/protocol/cap-and-base-theorem.html\" target=\"_blank\">CAP 理论和 BASE 理论解读</a></li>\n<li><a href=\"/Note-Book/distributed-system/protocol/paxos-algorithm.html\" target=\"_blank\">Paxos 算法解读</a></li>\n<li><a href=\"/Note-Book/distributed-system/protocol/raft-algorithm.html\" target=\"_blank\">Raft 算法解读</a></li>\n<li><a href=\"/Note-Book/distributed-system/protocol/gossip-protocl.html\" target=\"_blank\">Gossip 协议详解</a></li>\n</ul>\n<h3>RPC</h3>\n<ul>\n<li><a href=\"/Note-Book/distributed-system/rpc/rpc-intro.html\" target=\"_blank\">RPC 基础知识总结</a></li>\n<li><a href=\"/Note-Book/distributed-system/rpc/dubbo.html\" target=\"_blank\">Dubbo 常见知识点&amp;面试题总结</a></li>\n</ul>\n<h3>ZooKeeper</h3>\n<blockquote>\n<p>这两篇文章可能有内容重合部分，推荐都看一遍。</p>\n</blockquote>\n<ul>\n<li><a href=\"/Note-Book/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html\" target=\"_blank\">ZooKeeper 相关概念总结(入门)</a></li>\n<li><a href=\"/Note-Book/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus.html\" target=\"_blank\">ZooKeeper 相关概念总结(进阶)</a></li>\n</ul>\n<h3>API 网关</h3>\n<ul>\n<li><a href=\"/Note-Book/distributed-system/api-gateway.html\" target=\"_blank\">API 网关基础知识总结</a></li>\n<li><a href=\"/Note-Book/distributed-system/spring-cloud-gateway-questions.html\" target=\"_blank\">Spring Cloud Gateway 常见知识点&amp;面试题总结</a></li>\n</ul>\n<h3>分布式 ID</h3>\n<ul>\n<li><a href=\"/Note-Book/distributed-system/distributed-id.html\" target=\"_blank\">分布式 ID 常见知识点&amp;面试题总结</a></li>\n<li><a href=\"/Note-Book/distributed-system/distributed-id-design.html\" target=\"_blank\">分布式 ID 设计指南</a></li>\n</ul>\n<h3>分布式锁</h3>\n<ul>\n<li><a href=\"https://javaguide.cn/distributed-system/distributed-lock.html\" target=\"_blank\" rel=\"noopener noreferrer\">分布式锁介绍</a></li>\n<li><a href=\"https://javaguide.cn/distributed-system/distributed-lock-implementations.html\" target=\"_blank\" rel=\"noopener noreferrer\">分布式锁常见实现方案总结</a></li>\n</ul>\n<h3>分布式事务</h3>\n<p><a href=\"/Note-Book/distributed-system/distributed-transaction.html\" target=\"_blank\">分布式事务常见知识点&amp;面试题总结</a></p>\n<h3>分布式配置中心</h3>\n<p><a href=\"/Note-Book/distributed-system/distributed-configuration-center.html\" target=\"_blank\">分布式配置中心常见知识点&amp;面试题总结</a></p>\n<h2>高性能</h2>\n<h3>数据库读写分离&amp;分库分表</h3>\n<p><a href=\"/Note-Book/high-performance/read-and-write-separation-and-library-subtable.html\" target=\"_blank\">数据库读写分离和分库分表常见知识点&amp;面试题总结</a></p>\n<h3>负载均衡</h3>\n<p><a href=\"/Note-Book/high-performance/load-balancing.html\" target=\"_blank\">负载均衡常见知识点&amp;面试题总结</a></p>\n<h3>SQL 优化</h3>\n<h3>CDN</h3>\n<p><a href=\"/Note-Book/high-performance/cdn.html\" target=\"_blank\">CDN（内容分发网络）常见知识点&amp;面试题总结</a></p>\n<h3>消息队列</h3>\n<ul>\n<li><a href=\"/Note-Book/high-performance/message-queue/message-queue.html\" target=\"_blank\">消息队列基础知识总结</a></li>\n<li><a href=\"/Note-Book/high-performance/message-queue/disruptor-questions.html\" target=\"_blank\">Disruptor 常见知识点&amp;面试题总结</a></li>\n<li><a href=\"/Note-Book/high-performance/message-queue/rabbitmq-questions.html\" target=\"_blank\">RabbitMQ 常见知识点&amp;面试题总结</a></li>\n<li><a href=\"/Note-Book/high-performance/message-queue/rocketmq-questions.html\" target=\"_blank\">RocketMQ 常见知识点&amp;面试题总结</a></li>\n<li><a href=\"/Note-Book/high-performance/message-queue/kafka-questions-01.html\" target=\"_blank\">Kafka 常常见知识点&amp;面试题总结</a></li>\n</ul>\n<h2>高可用</h2>\n<p><a href=\"/Note-Book/high-availability/high-availability-system-design.html\" target=\"_blank\">高可用系统设计指南</a></p>\n<h3>冗余设计</h3>\n<p><a href=\"/Note-Book/high-availability/redundancy.html\" target=\"_blank\">冗余设计详解</a></p>\n<h3>限流</h3>\n<p><a href=\"/Note-Book/high-availability/limit-request.html\" target=\"_blank\">服务限流详解</a></p>\n<h3>降级&amp;熔断</h3>\n<h3>超时&amp;重试</h3>\n<p><a href=\"/Note-Book/high-availability/timeout-and-retry.html\" target=\"_blank\">超时&amp;重试详解</a></p>\n<h3>集群</h3>\n<p>相同的服务部署多份，避免单点故障。</p>\n<h3>灾备设计和异地多活</h3>\n<p><strong>灾备</strong> = 容灾 + 备份。</p>\n<ul>\n<li><strong>备份</strong>：将系统所产生的的所有重要数据多备份几份。</li>\n<li><strong>容灾</strong>：在异地建立两个完全相同的系统。当某个地方的系统突然挂掉，整个应用系统可以切换到另一个，这样系统就可以正常提供服务了。</li>\n</ul>\n<p><strong>异地多活</strong> 描述的是将服务部署在异地并且服务同时对外提供服务。和传统的灾备设计的最主要区别在于“多活”，即所有站点都是同时在对外提供服务的。异地多活是为了应对突发状况比如火灾、地震等自然或者人为灾害。</p>\n<h2>Star 趋势</h2>\n<figure><img src=\"https://api.star-history.com/svg?repos=Snailclimb/JavaGuide&amp;type=Date\" alt=\"Stars\" tabindex=\"0\"><figcaption>Stars</figcaption></figure>\n<h2>公众号</h2>\n<p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号“<strong>JavaGuide</strong>”。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/csdn/1c00413c65d1995993bf2b0daf7b4f03.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "算法",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/algorithm/",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/algorithm/",
      "summary": "记录算法题 数据结构可视化 需自行添加数据：Data Structure Visualizations 可自动生成数据：VisuAlgo",
      "content_html": "<p>记录算法题</p>\n<h2>数据结构可视化</h2>\n<p>需自行添加数据：<a href=\"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\" target=\"_blank\" rel=\"noopener noreferrer\">Data Structure Visualizations</a></p>\n<p>可自动生成数据：<a href=\"https://visualgo.net/zh\" target=\"_blank\" rel=\"noopener noreferrer\">VisuAlgo</a></p>\n",
      "date_published": "2024-03-01T00:00:00.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "微信开发概要",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/business/",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/business/",
      "summary": "微信公众平台 微信公众平台，简称MP(Media Press)。 3年前，小龙说：“终于可以订阅网上的杂志了，信息就应该这样PUSH过来”。你是否还记得公众平台首页上写的“在这里，阅读更简单”？你是否知道MP代表的是Media Press？其实，最初，微信公众号就是为优质内容发布打造的。 公众平台注册的账号分为四类：服务号、订阅号、小程序/小游戏账号、...",
      "content_html": "<h2>微信公众平台</h2>\n<p>微信公众平台，简称MP(<a href=\"https://mp.weixin.qq.com/s/Rg8NnCXGosouAm3NjkXu5Q\" target=\"_blank\" rel=\"noopener noreferrer\">Media Press</a>)。</p>\n<blockquote>\n<p>3年前，小龙说：“终于可以订阅网上的杂志了，信息就应该这样PUSH过来”。你是否还记得公众平台首页上写的“在这里，阅读更简单”？你是否知道MP代表的是Media\nPress？其实，最初，微信公众号就是为优质内容发布打造的。</p>\n</blockquote>\n<p>公众平台注册的账号分为四类：服务号、订阅号、小程序/小游戏账号、企业微信。</p>\n<p>所以开发以上几种应用时，可使用统一命名mp</p>\n<h2>开发</h2>\n<p>第三方微信开发SDK：<a href=\"https://github.com/Wechat-Group/WxJava\" target=\"_blank\" rel=\"noopener noreferrer\">WxJava</a>\n，微信Java开发工具包，支持包括微信支付、开放平台、公众号、企业微信、视频号、小程序等微信功能模块的后端开发。</p>\n",
      "date_published": "2024-01-17T00:00:00.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "Business"
      ]
    },
    {
      "title": "数据库基础知识总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/basis.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/basis.html",
      "summary": "数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员? 数据库 : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数...",
      "content_html": "<p>数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。</p>\n<h2>什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h2>\n<ul>\n<li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li>\n<li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>\n<li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>\n<li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li>\n</ul>\n<h2>什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h2>\n<ul>\n<li><strong>元组</strong>：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>\n<li><strong>码</strong>：码就是能唯一标识实体的属性，对应表中的列。</li>\n<li><strong>候选码</strong>：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>\n<li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>\n<li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>\n<li><strong>主属性</strong>：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>\n<li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>\n</ul>\n<h2>什么是 ER 图？</h2>\n<p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。</p>\n<p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。</p>\n<p>ER 图由下面 3 个要素组成：</p>\n<ul>\n<li><strong>实体</strong>：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li>\n<li><strong>属性</strong>：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。</li>\n<li><strong>联系</strong>：即实体与实体之间的关系，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>\n</ul>\n<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/c745c87f6eda9a439e0eea52012c7f4a.png\" alt=\"学生与课程之间联系的E-R图\" tabindex=\"0\"><figcaption>学生与课程之间联系的E-R图</figcaption></figure>\n<h2>数据库范式了解吗?</h2>\n<p>数据库范式有 3 种：</p>\n<ul>\n<li>1NF(第一范式)：属性不可再分。</li>\n<li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>\n<li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li>\n</ul>\n<h3>1NF(第一范式)</h3>\n<p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p>\n<h3>2NF(第二范式)</h3>\n<p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/bd1d31be3779342427fc9e462bf7f05c.png\" alt=\"第二范式\" tabindex=\"0\"><figcaption>第二范式</figcaption></figure>\n<p>一些重要的概念：</p>\n<ul>\n<li><strong>函数依赖（functional dependency）</strong>：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li>\n<li><strong>部分函数依赖（partial functional dependency）</strong>：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li>\n<li><strong>完全函数依赖(Full functional dependency)</strong>：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li>\n<li><strong>传递函数依赖</strong>：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li>\n</ul>\n<h3>3NF(第三范式)</h3>\n<p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p>\n<h2>主键和外键有什么区别?</h2>\n<ul>\n<li><strong>主键(主码)</strong>：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>\n<li><strong>外键(外码)</strong>：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>\n</ul>\n<h2>为什么不推荐使用外键与级联？</h2>\n<p>对于外键和级联，阿里巴巴开发手册这样说到：</p>\n<blockquote>\n<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>\n<p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度</p>\n</blockquote>\n<p>为什么不要用外键呢？大部分人可能会这样回答：</p>\n<ol>\n<li><strong>增加了复杂性：</strong> a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>\n<li><strong>增加了额外工作</strong>：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>\n<li><strong>对分库分表不友好</strong>：因为分库分表下外键是无法生效的。</li>\n<li>......</li>\n</ol>\n<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>\n<ol>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n<li>......</li>\n</ol>\n<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p>\n<h2>什么是存储过程?</h2>\n<p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p>\n<p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>\n<p>阿里巴巴 Java 开发手册里要求禁止使用存储过程。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/0fa082bc4d4f919065767476a41b2156.png\" alt=\"阿里巴巴Java开发手册: 禁止存储过程\" tabindex=\"0\"><figcaption>阿里巴巴Java开发手册: 禁止存储过程</figcaption></figure>\n<h2>drop、delete 与 truncate 区别？</h2>\n<h3>用法不同</h3>\n<ul>\n<li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>\n<li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>\n<li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li>\n</ul>\n<p><code>truncate</code> 和不带 <code>where</code>子句的 <code>delete</code>、以及 <code>drop</code> 都会删除表内的数据，但是 <strong><code>truncate</code> 和 <code>delete</code> 只删除数据不删除表的结构(定义)，执行 <code>drop</code> 语句，此表的结构也会删除，也就是执行<code>drop</code> 之后对应的表不复存在。</strong></p>\n<h3>属于不同的数据库语言</h3>\n<p><code>truncate</code> 和 <code>drop</code> 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 <code>delete</code> 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。</p>\n<p><strong>DML 语句和 DDL 语句区别：</strong></p>\n<ul>\n<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li>\n<li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>\n</ul>\n<p>另外，由于<code>select</code>不会对表进行破坏，所以有的地方也会把<code>select</code>单独区分开叫做数据库查询语言 DQL（Data Query Language）。</p>\n<h3>执行速度不同</h3>\n<p>一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code>（这个我没有设计测试过）。</p>\n<ul>\n<li><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>\n<li><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li>\n<li><code>drop</code>命令会把表占用的空间全部释放掉。</li>\n</ul>\n<p>Tips：你应该更多地关注在使用场景上，而不是执行效率。</p>\n<h2>数据库设计通常分为哪几步?</h2>\n<ol>\n<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>\n<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>\n<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>\n<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>\n<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>\n<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li>\n</ol>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/rl529014/article/details/48391465\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/rl529014/article/details/48391465</a></li>\n<li><a href=\"https://www.zhihu.com/question/24696366/answer/29189700\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/24696366/answer/29189700</a></li>\n<li><a href=\"https://blog.csdn.net/bieleyang/article/details/77149954\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/bieleyang/article/details/77149954</a></li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/csdn/c745c87f6eda9a439e0eea52012c7f4a.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "字符集详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/character-set.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/character-set.html",
      "summary": "MySQL 字符编码集中有两套 UTF-8 编码实现：utf8 和 utf8mb4。 如果使用 utf8 的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。 为什么会这样呢？这篇文章可以从源头给你解答。 何为字符集？ 字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 字符集 就是一系列字符的集合。字符集的种类较多...",
      "content_html": "<p>MySQL 字符编码集中有两套 UTF-8 编码实现：<strong><code>utf8</code></strong> 和 <strong><code>utf8mb4</code></strong>。</p>\n<p>如果使用 <strong><code>utf8</code></strong> 的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p>\n<p>为什么会这样呢？这篇文章可以从源头给你解答。</p>\n<h2>何为字符集？</h2>\n<p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</p>\n<p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p>\n<p>我们要将这些字符和二进制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。我们将字符对应二进制数据的过程称为\"<strong>字符编码</strong>\"，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p>\n<h2>有哪些常见的字符集？</h2>\n<p>常见的字符集有 ASCII、GB2312、GBK、UTF-8......。</p>\n<p>不同的字符集的主要区别在于：</p>\n<ul>\n<li>可以表示的字符范围</li>\n<li>编码方式</li>\n</ul>\n<h3>ASCII</h3>\n<p><strong>ASCII</strong> (<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p>\n<p><strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？</strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言。</p>\n<p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p>\n<p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 128（2^7）个字符。</p>\n<p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 256（2^8）个字符。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/c1c6375d08ca268690cef2b13591a5b4.png\" alt=\"ASCII字符编码\" tabindex=\"0\"><figcaption>ASCII字符编码</figcaption></figure>\n<h3>GB2312</h3>\n<p>我们上面说了，ASCII 字符集是一种现代美国英语适用的字符集。因此，很多国家都捣鼓了一个适合自己国家语言的字符集。</p>\n<p>GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。</p>\n<p>对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</p>\n<h3>GBK</h3>\n<p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p>\n<p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p>\n<h3>GB18030</h3>\n<p>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p>\n<h3>BIG5</h3>\n<p>BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。</p>\n<h3>Unicode &amp; UTF-8 编码</h3>\n<p>为了更加适合本国语言，诞生了很多种字符集。</p>\n<p>我们上面也说了不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p>\n<p>就比如说你使用 UTF-8 编码方式打开 GB2312 编码格式的文件就会出现乱码。示例：“牛”这个汉字 GB2312 编码后的十六进制数值为 “C5A3”，而 “C5A3” 用 UTF-8 解码之后得到的却是 “ţ”。</p>\n<p>你可以通过这个网站在线进行编码和解码：<a href=\"https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan</a></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/836c49b117ee4408871b0020b74c991d.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这样我们就搞懂了乱码的本质：<strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/a8808cbabeea49caa3af27d314fa3c02-1.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为了解决这个问题，人们就想：“如果我们能够有一种字符集将世界上所有的字符都纳入其中就好了！”。</p>\n<p>然后，<strong>Unicode</strong> 带着这个使命诞生了。</p>\n<p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p>\n<p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p>\n<p>UTF-8 使用 1 到 4 个字节为每个字符编码， UTF-16 使用 2 或 4 个字节为每个字符编码，UTF-32 固定位 4 个字节为每个字符编码。</p>\n<p>UTF-8 可以根据不同的符号自动选择编码的长短，像英文字符只需要 1 个字节就够了，这一点 ASCII 字符集一样 。因此，对于英语字符，UTF-8 编码和 ASCII 码是相同的。</p>\n<p>UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。</p>\n<p><strong>UTF-8</strong> 是目前使用最广的一种字符编码，。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/1280px-Utf8webgrowth.svg.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>MySQL 字符集</h2>\n<p>MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5。</p>\n<p>你可以通过 <code>SHOW CHARSET</code> 命令来查看。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/image-20211008164229671.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。</p>\n<p>不过，这里有一个小坑。</p>\n<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>\n<ul>\n<li><strong><code>utf8</code></strong>：<code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>\n<li><strong><code>utf8mb4</code></strong>：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>\n</ul>\n<p><strong>为什么有两套 UTF-8 编码实现呢？</strong> 原因如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/image-20211008164542347.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>因此，如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code> 而不是<code>utf8</code> ，要不然存储的时候就会报错了。</p>\n<p>演示一下吧！（环境：MySQL 5.7+）</p>\n<p>建表语句如下，我们指定数据库 CHARSET 为 <code>utf8</code> 。</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">66</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">CHARACTER</span> <span class=\"token keyword\">SET</span> utf8mb4 <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>name<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">33</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">CHARACTER</span> <span class=\"token keyword\">SET</span> utf8mb4 <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>phone<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">33</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">CHARACTER</span> <span class=\"token keyword\">SET</span> utf8mb4 <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>password<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">CHARACTER</span> <span class=\"token keyword\">SET</span> utf8mb4 <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n</code></pre></div><p>当我们执行下面的 insert 语句插入数据到数据库时，果然报错！</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>name<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>phone<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>password<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">VALUES</span>\n <span class=\"token punctuation\">(</span><span class=\"token string\">'A00003'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'guide哥😘😘😘'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'181631312312'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'123456'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n</code></pre></div><p>报错信息如下：</p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>Incorrect string value: '\\xF0\\x9F\\x98\\x98\\xF0\\x9F...' for column 'name' at row 1\n</code></pre></div><h2>参考</h2>\n<ul>\n<li>字符集和字符编码（Charset &amp; Encoding）：<a href=\"https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html</a></li>\n<li>十分钟搞清字符集和字符编码：<a href=\"http://cenalulu.github.io/linux/character-encoding/\" target=\"_blank\" rel=\"noopener noreferrer\">http://cenalulu.github.io/linux/character-encoding/</a></li>\n<li>Unicode-维基百科：<a href=\"https://zh.wikipedia.org/wiki/Unicode\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/Unicode</a></li>\n<li>GB2312-维基百科：<a href=\"https://zh.wikipedia.org/wiki/GB_2312\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/GB_2312</a></li>\n<li>UTF-8-维基百科：<a href=\"https://zh.wikipedia.org/wiki/UTF-8\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/UTF-8</a></li>\n<li>GB18030-维基百科: <a href=\"https://zh.wikipedia.org/wiki/GB_18030\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/GB_18030</a></li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/csdn/c1c6375d08ca268690cef2b13591a5b4.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "NoSQL基础知识总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/nosql.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/nosql.html",
      "summary": "NoSQL 是什么？ NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。 一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关...",
      "content_html": "<h2>NoSQL 是什么？</h2>\n<p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p>\n<p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p>\n<p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/sql-nosql-tushi.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>SQL 和 NoSQL 有什么区别？</h2>\n<p>|              | SQL 数据库                                                                 | NoSQL 数据库                                                                                                                            |\n| :</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/mongodb/sql-nosql-tushi.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "API网关基础知识总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/api-gateway.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/api-gateway.html",
      "summary": "什么是网关？ 微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。 网关示意图网关示意图 一般情况下，网关可以为我们提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、降级熔断、...",
      "content_html": "<h2>什么是网关？</h2>\n<p>微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway-overview.png\" alt=\"网关示意图\" tabindex=\"0\"><figcaption>网关示意图</figcaption></figure>\n<p>一般情况下，网关可以为我们提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、降级熔断、日志、监控、参数校验、协议转换等功能。</p>\n<p>上面介绍了这么多功能，实际上，网关主要做了两件事情：<strong>请求转发</strong> + <strong>请求过滤</strong>。</p>\n<p>由于引入网关之后，会多一步网络转发，因此性能会有一点影响（几乎可以忽略不计，尤其是内网访问的情况下）。 另外，我们需要保障网关服务的高可用，避免单点风险。</p>\n<p>如下图所示，网关服务外层通过 Nginx（其他负载均衡设备/软件也行） 进⾏负载转发以达到⾼可⽤。Nginx 在部署的时候，尽量也要考虑高可用，避免单点风险。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/load-balancing/server-load-balancing.png\" alt=\"基于 Nginx 的服务端负载均衡\" tabindex=\"0\"><figcaption>基于 Nginx 的服务端负载均衡</figcaption></figure>\n<h2>网关能提供哪些功能？</h2>\n<p>绝大部分网关可以提供下面这些功能：</p>\n<ul>\n<li><strong>请求转发</strong>：将请求转发到目标微服务。</li>\n<li><strong>负载均衡</strong>：根据各个微服务实例的负载情况或者具体的负载均衡策略配置对请求实现动态的负载均衡。</li>\n<li><strong>安全认证</strong>：对用户请求进行身份验证并仅允许可信客户端访问 API，并且还能够使用类似 RBAC 等方式来授权。</li>\n<li><strong>参数校验</strong>：支持参数映射与校验逻辑。</li>\n<li><strong>日志记录</strong>：记录所有请求的行为日志供后续使用。</li>\n<li><strong>监控告警</strong>：从业务指标、机器指标、JVM 指标等方面进行监控并提供配套的告警机制。</li>\n<li><strong>流量控制</strong>：对请求的流量进行控制，也就是限制某一时刻内的请求数。</li>\n<li><strong>熔断降级</strong>：实时监控请求的统计信息，达到配置的失败阈值后，自动熔断，返回默认值。</li>\n<li><strong>响应缓存</strong>：当用户请求获取的是一些静态的或更新不频繁的数据时，一段时间内多次请求获取到的数据很可能是一样的。对于这种情况可以将响应缓存起来。这样用户请求可以直接在网关层得到响应数据，无需再去访问业务服务，减轻业务服务的负担。</li>\n<li><strong>响应聚合</strong>：某些情况下用户请求要获取的响应内容可能会来自于多个业务服务。网关作为业务服务的调用方，可以把多个服务的响应整合起来，再一并返回给用户。</li>\n<li><strong>灰度发布</strong>：将请求动态分流到不同的服务版本（最基本的一种灰度发布）。</li>\n<li><strong>异常处理</strong>：对于业务服务返回的异常响应，可以在网关层在返回给用户之前做转换处理。这样可以把一些业务侧返回的异常细节隐藏，转换成用户友好的错误提示返回。</li>\n<li><strong>API 文档：</strong> 如果计划将 API 暴露给组织以外的开发人员，那么必须考虑使用 API 文档，例如 Swagger 或 OpenAPI。</li>\n<li><strong>协议转换</strong>：通过协议转换整合后台基于 REST、AMQP、Dubbo 等不同风格和实现技术的微服务，面向 Web Mobile、开放平台等特定客户端提供统一服务。</li>\n</ul>\n<p>下图来源于<a href=\"https://mp.weixin.qq.com/s/iITqdIiHi3XGKq6u6FRVdg\" target=\"_blank\" rel=\"noopener noreferrer\">百亿规模 API 网关服务 Shepherd 的设计与实现 - 美团技术团队 - 2021</a>这篇文章。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-35e102c633bbe8e0dea1e075ea3fee5dcfb.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>有哪些常见的网关系统？</h2>\n<h3>Netflix Zuul</h3>\n<p>Zuul 是 Netflix 开发的一款提供动态路由、监控、弹性、安全的网关服务，基于 Java 技术栈开发，可以和 Eureka、Ribbon、Hystrix 等组件配合使用。</p>\n<p>Zuul 核心架构如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/zuul-core-architecture.webp\" alt=\"Zuul 核心架构\" tabindex=\"0\"><figcaption>Zuul 核心架构</figcaption></figure>\n<p>Zuul 主要通过过滤器（类似于 AOP）来过滤请求，从而实现网关必备的各种功能。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/zuul-request-lifecycle.webp\" alt=\"Zuul 请求声明周期\" tabindex=\"0\"><figcaption>Zuul 请求声明周期</figcaption></figure>\n<p>我们可以自定义过滤器来处理请求，并且，Zuul 生态本身就有很多现成的过滤器供我们使用。就比如限流可以直接用国外朋友写的 <a href=\"https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit\" target=\"_blank\" rel=\"noopener noreferrer\">spring-cloud-zuul-ratelimit</a> (这里只是举例说明，一般是配合 hystrix 来做限流)：</p>\n<div class=\"language-xml\" data-ext=\"xml\" data-title=\"xml\"><pre class=\"language-xml\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>org.springframework.cloud<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>spring-cloud-starter-netflix-zuul<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>com.marcosbarbero.cloud<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>spring-cloud-zuul-ratelimit<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">&gt;</span></span>2.2.0.RELEASE<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre></div><p><a href=\"https://netflixtechblog.com/announcing-zuul-edge-service-in-the-cloud-ab3af5be08ee\" target=\"_blank\" rel=\"noopener noreferrer\">Zuul 1.x</a> 基于同步 IO，性能较差。<a href=\"https://netflixtechblog.com/open-sourcing-zuul-2-82ea476cb2b3\" target=\"_blank\" rel=\"noopener noreferrer\">Zuul 2.x</a> 基于 Netty 实现了异步 IO，性能得到了大幅改进。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-4f9047dc9109e27f9fced1b365e2b976e9d.png\" alt=\"Zuul2 架构\" tabindex=\"0\"><figcaption>Zuul2 架构</figcaption></figure>\n<ul>\n<li>GitHub 地址： <a href=\"https://github.com/Netflix/zuul\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Netflix/zuul</a></li>\n<li>官方 Wiki： <a href=\"https://github.com/Netflix/zuul/wiki\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Netflix/zuul/wiki</a></li>\n</ul>\n<h3>Spring Cloud Gateway</h3>\n<p>SpringCloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 <strong>Zuul</strong>。准确点来说，应该是 Zuul 1.x。SpringCloud Gateway 起步要比 Zuul 2.x 更早。</p>\n<p>为了提升网关的性能，SpringCloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I/O。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway- demo.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。</p>\n<p>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。</p>\n<ul>\n<li>Github 地址： <a href=\"https://github.com/spring-cloud/spring-cloud-gateway\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/spring-cloud/spring-cloud-gateway</a></li>\n<li>官网： <a href=\"https://spring.io/projects/spring-cloud-gateway\" target=\"_blank\" rel=\"noopener noreferrer\">https://spring.io/projects/spring-cloud-gateway</a></li>\n</ul>\n<h3>Kong</h3>\n<p>Kong 是一款基于 <a href=\"https://github.com/openresty/\" target=\"_blank\" rel=\"noopener noreferrer\">OpenResty</a> （Nginx + Lua）的高性能、云原生、可扩展的网关系统，主要由 3 个组件组成：</p>\n<ul>\n<li>Kong Server：基于 Nginx 的服务器，用来接收 API 请求。</li>\n<li>Apache Cassandra/PostgreSQL：用来存储操作数据。</li>\n<li>Kong Dashboard：官方推荐 UI 管理工具，当然，也可以使用 RESTful 方式 管理 Admin api。</li>\n</ul>\n<blockquote>\n<p>OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/kong-way.webp\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Kong 提供了插件机制来扩展其功能，插件在 API 请求响应循环的生命周期中被执行。比如在服务上启用 Zipkin 插件：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code>$ <span class=\"token function\">curl</span> <span class=\"token parameter variable\">-X</span> POST http://kong:8001/services/<span class=\"token punctuation\">{</span>service<span class=\"token punctuation\">}</span>/plugins <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">--data</span> <span class=\"token string\">\"name=zipkin\"</span>  <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">--data</span> <span class=\"token string\">\"config.http_endpoint=http://your.zipkin.collector:9411/api/v2/spans\"</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">--data</span> <span class=\"token string\">\"config.sample_ratio=0.001\"</span>\n</code></pre></div><blockquote>\n<p>Kong 本身就是一个 Lua 应用程序，并且是在 Openresty 的基础之上做了一层封装的应用。归根结底就是利用 Lua 嵌入 Nginx 的方式，赋予了 Nginx 可编程的能力，这样以插件的形式在 Nginx 这一层能够做到无限想象的事情。例如限流、安全访问策略、路由、负载均衡等等。编写一个 Kong 插件，就是按照 Kong 插件编写规范，写一个自己自定义的 Lua 脚本，然后加载到 Kong 中，最后引用即可。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/kong-gateway-overview.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<ul>\n<li>Github 地址： <a href=\"https://github.com/Kong/kong\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Kong/kong</a></li>\n<li>官网地址： <a href=\"https://konghq.com/kong\" target=\"_blank\" rel=\"noopener noreferrer\">https://konghq.com/kong</a></li>\n</ul>\n<h3>APISIX</h3>\n<p>APISIX 是一款基于 Nginx 和 etcd 的高性能、云原生、可扩展的网关系统。</p>\n<blockquote>\n<p>etcd 是使用 Go 语言开发的一个开源的、高可用的分布式 key-value 存储系统，使用 Raft 协议做分布式共识。</p>\n</blockquote>\n<p>与传统 API 网关相比，APISIX 具有动态路由和插件热加载，特别适合微服务系统下的 API 管理。并且，APISIX 与 SkyWalking（分布式链路追踪系统）、Zipkin（分布式链路追踪系统）、Prometheus（监控系统） 等 DevOps 生态工具对接都十分方便。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-cc6717d095705a584dd8daaaadb13c5c75b.png\" alt=\"APISIX 架构图\" tabindex=\"0\"><figcaption>APISIX 架构图</figcaption></figure>\n<p>作为 NGINX 和 Kong 的替代项目，APISIX 目前已经是 Apache 顶级开源项目，并且是最快毕业的国产开源项目。国内目前已经有很多知名企业（比如金山、有赞、爱奇艺、腾讯、贝壳）使用 APISIX 处理核心的业务流量。</p>\n<p>根据官网介绍：“APISIX 已经生产可用，功能、性能、架构全面优于 Kong”。</p>\n<p>APISIX 同样支持定制化的插件开发。开发者除了能够使用 Lua 语言开发插件，还能通过下面两种方式开发来避开 Lua 语言的学习成本：</p>\n<ul>\n<li>通过 Plugin Runner 来支持更多的主流编程语言（比如 Java、Python、Go 等等）。通过这样的方式，可以让后端工程师通过本地 RPC 通信，使用熟悉的编程语言开发 APISIX 的插件。这样做的好处是减少了开发成本，提高了开发效率，但是在性能上会有一些损失。</li>\n<li>使用 Wasm（WebAssembly） 开发插件。Wasm 被嵌入到了 APISIX 中，用户可以使用 Wasm 去编译成 Wasm 的字节码在 APISIX 中运行。</li>\n</ul>\n<blockquote>\n<p>Wasm 是基于堆栈的虚拟机的二进制指令格式，一种低级汇编语言，旨在非常接近已编译的机器代码，并且非常接近本机性能。Wasm 最初是为浏览器构建的，但是随着技术的成熟，在服务器端看到了越来越多的用例。</p>\n</blockquote>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-a240d3b113cde647f5850f4c7cc55d4ff5c.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<ul>\n<li>Github 地址：<a href=\"https://github.com/apache/apisix\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/apache/apisix</a></li>\n<li>官网地址： <a href=\"https://apisix.apache.org/zh/\" target=\"_blank\" rel=\"noopener noreferrer\">https://apisix.apache.org/zh/</a></li>\n</ul>\n<p>相关阅读：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/j8ggPGEHFu3x5ekJZyeZnA\" target=\"_blank\" rel=\"noopener noreferrer\">为什么说 Apache APISIX 是最好的 API 网关？</a></li>\n<li><a href=\"https://www.apiseven.com/zh/blog/why-we-need-Apache-APISIX\" target=\"_blank\" rel=\"noopener noreferrer\">有了 NGINX 和 Kong，为什么还需要 Apache APISIX</a></li>\n<li><a href=\"https://www.apiseven.com/zh/blog\" target=\"_blank\" rel=\"noopener noreferrer\">APISIX 技术博客</a></li>\n<li><a href=\"https://www.apiseven.com/zh/usercases\" target=\"_blank\" rel=\"noopener noreferrer\">APISIX 用户案例</a></li>\n</ul>\n<h3>Shenyu</h3>\n<p>Shenyu 是一款基于 WebFlux 的可扩展、高性能、响应式网关，Apache 顶级开源项目。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-1c2b39f22e5a0bb1730531429c4147bfbf8.png\" alt=\"Shenyu 架构\" tabindex=\"0\"><figcaption>Shenyu 架构</figcaption></figure>\n<p>Shenyu 通过插件扩展功能，插件是 ShenYu 的灵魂，并且插件也是可扩展和热插拔的。不同的插件实现不同的功能。Shenyu 自带了诸如限流、熔断、转发、重写、重定向、和路由监控等插件。</p>\n<ul>\n<li>Github 地址： <a href=\"https://github.com/apache/incubator-shenyu\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/apache/incubator-shenyu</a></li>\n<li>官网地址： <a href=\"https://shenyu.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://shenyu.apache.org/</a></li>\n</ul>\n<h2>参考</h2>\n<ul>\n<li>Kong 插件开发教程[通俗易懂]：<a href=\"https://cloud.tencent.com/developer/article/2104299\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.tencent.com/developer/article/2104299</a></li>\n<li>API 网关 Kong 实战：<a href=\"https://xie.infoq.cn/article/10e4dab2de0bdb6f2c3c93da6\" target=\"_blank\" rel=\"noopener noreferrer\">https://xie.infoq.cn/article/10e4dab2de0bdb6f2c3c93da6</a></li>\n<li>Spring Cloud Gateway 原理介绍和应用：<a href=\"https://blog.fintopia.tech/60e27b0e2078082a378ec5ed/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.fintopia.tech/60e27b0e2078082a378ec5ed/</a></li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway-overview.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "分布式配置中心常见问题总结(付费)",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-configuration-center.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-configuration-center.html",
      "summary": "分布式配置中心 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>分布式配置中心</strong> 相关的面试题为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。</p>\n<figure><img src=\"https://oss.javaguide.cn/javamianshizhibei/distributed-system.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/javamianshizhibei/distributed-system.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "分布式ID设计指南",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-id-design.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-id-design.html",
      "summary": "提示 看到百度 Geek 说的一篇结合具体场景聊分布式 ID 设计的文章，感觉挺不错的。于是，我将这篇文章的部分内容整理到了这里。原文传送门：分布式 ID 生成服务的技术原理和项目实战 。 网上绝大多数的分布式 ID 生成服务，一般着重于技术原理剖析，很少见到根据具体的业务场景去选型 ID 生成服务的文章。 本文结合一些使用场景，进一步探讨业务场景中对...",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>看到百度 Geek 说的一篇结合具体场景聊分布式 ID 设计的文章，感觉挺不错的。于是，我将这篇文章的部分内容整理到了这里。原文传送门：<a href=\"https://mp.weixin.qq.com/s/bFDLb6U6EgI-DvCdLTq_QA\" target=\"_blank\" rel=\"noopener noreferrer\">分布式 ID 生成服务的技术原理和项目实战</a> 。</p>\n</div>\n<p>网上绝大多数的分布式 ID 生成服务，一般着重于技术原理剖析，很少见到根据具体的业务场景去选型 ID 生成服务的文章。</p>\n<p>本文结合一些使用场景，进一步探讨业务场景中对 ID 有哪些具体的要求。</p>\n<h2>场景一：订单系统</h2>\n<p>我们在商场买东西一码付二维码，下单生成的订单号，使用到的优惠券码，联合商品兑换券码，这些是在网上购物经常使用到的单号，那么为什么有些单号那么长，有些只有几位数？有些单号一看就知道年月日的信息，有些却看不出任何意义？下面展开分析下订单系统中不同场景的 id 服务的具体实现。</p>\n<h3>1、一码付</h3>\n<p>我们常见的一码付，指的是一个二维码可以使用支付宝或者微信进行扫码支付。</p>\n<p>二维码的本质是一个字符串。聚合码的本质就是一个链接地址。用户使用支付宝微信直接扫一个码付钱，不用担心拿支付宝扫了微信的收款码或者用微信扫了支付宝的收款码，这极大减少了用户扫码支付的时间。</p>\n<p>实现原理是当客户用 APP 扫码后，网站后台就会判断客户的扫码环境。（微信、支付宝、QQ 钱包、京东支付、云闪付等）。</p>\n<p>判断扫码环境的原理就是根据打开链接浏览器的 HTTP header。任何浏览器打开 http 链接时，请求的 header 都会有 User-Agent(UA、用户代理)信息。</p>\n<p>UA 是一个特殊字符串头，服务器依次可以识别出客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等很多信息。</p>\n<p>各渠道对应支付产品的名称不一样，一定要仔细看各支付产品的 API 介绍。</p>\n<ol>\n<li>微信支付：JSAPI 支付支付</li>\n<li>支付宝：手机网站支付</li>\n<li>QQ 钱包：公众号支付</li>\n</ol>\n<p>其本质均为在 APP 内置浏览器中实现 HTML5 支付。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-pay-one-card.png\" alt=\"文库会员支付示例\" tabindex=\"0\"><figcaption>文库会员支付示例</figcaption></figure>\n<p>文库的研发同学在这个思路上，做了优化迭代。动态生成一码付的二维码预先绑定用户所选的商品信息和价格，根据用户所选的商品动态更新。这样不仅支持一码多平台调起支付，而且不用用户选择商品输入金额，即可完成订单支付的功能，很丝滑。用户在真正扫码后，服务端才通过前端获取用户 UID，结合二维码绑定的商品信息，真正的生成订单，发送支付信息到第三方（qq、微信、支付宝），第三方生成支付订单推给用户设备，从而调起支付。</p>\n<p>区别于固定的一码付，在文库的应用中，使用到了动态二维码，二维码本质是一个短网址，ID 服务提供短网址的唯一标志参数。唯一的短网址映射的 ID 绑定了商品的订单信息，技术和业务的深度结合，缩短了支付流程，提升用户的支付体验。</p>\n<h3>2、订单号</h3>\n<p>订单号在实际的业务过程中作为一个订单的唯一标识码存在，一般实现以下业务场景：</p>\n<ol>\n<li>用户订单遇到问题，需要找客服进行协助；</li>\n<li>对订单进行操作，如线下收款，订单核销；</li>\n<li>下单，改单，成单，退单，售后等系统内部的订单流程处理和跟进。</li>\n</ol>\n<p>很多时候搜索订单相关信息的时候都是以订单 ID 作为唯一标识符，这是由于订单号的生成规则的唯一性决定的。从技术角度看，除了 ID 服务必要的特性之外，在订单号的设计上需要体现几个特性：</p>\n<p><strong>（1）信息安全</strong></p>\n<p>编号不能透露公司的运营情况，比如日销、公司流水号等信息，以及商业信息和用户手机号，身份证等隐私信息。并且不能有明显的整体规律（可以有局部规律），任意修改一个字符就能查询到另一个订单信息，这也是不允许的。</p>\n<p>类比于我们高考时候的考生编号的生成规则，一定不能是连号的，否则只需要根据顺序往下查询就能搜索到别的考生的成绩，这是绝对不可允许。</p>\n<p><strong>（2）部分可读</strong></p>\n<p>位数要便于操作，因此要求订单号的位数适中，且局部有规律。这样可以方便在订单异常，或者退货时客服查询。</p>\n<p>过长的订单号或易读性差的订单号会导致客服输入困难且易错率较高，影响用户体验的售后体验。因此在实际的业务场景中，订单号的设计通常都会适当携带一些允许公开的对使用场景有帮助的信息，如时间，星期，类型等等，这个主要根据所涉及的编号对应的使用场景来。</p>\n<p>而且像时间、星期这些自增长的属于作为订单号的设计的一部分元素，有助于解决业务累积而导致的订单号重复的问题。</p>\n<p><strong>（3）查询效率</strong></p>\n<p>常见的电商平台订单号大多是纯数字组成，兼具可读性的同时，int 类型相对 varchar 类型的查询效率更高，对在线业务更加友好。</p>\n<h3>3、优惠券和兑换券</h3>\n<p>优惠券、兑换券是运营推广最常用的促销工具之一，合理使用它们，可以让买家得到实惠，商家提升商品销量。常见场景有：</p>\n<ol>\n<li>在文库购买【文库 VIP+QQ 音乐年卡】联合商品，支付成功后会得到 QQ 音乐年卡的兑换码，可以去 QQ 音乐 App 兑换音乐会员年卡；</li>\n<li>疫情期间，部分地方政府发放的消费券；</li>\n<li>瓶装饮料经常会出现输入优惠编码兑换奖品。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-coupon.png\" alt=\"优惠编码兑换奖品\" tabindex=\"0\"><figcaption>优惠编码兑换奖品</figcaption></figure>\n<p>从技术角度看，有些场景适合 ID 即时生成，比如电商平台购物领取的优惠券，只需要在用户领取时分配优惠券信息即可。有些线上线下结合的场景，比如疫情优惠券，瓶盖开奖，京东卡，超市卡这种，则需要预先生成，预先生成的券码具备以下特性：</p>\n<p>1.预先生成，在活动正式开始前提供出来进行活动预热；</p>\n<p>2.优惠券体量大，以万为单位，通常在 10 万级别以上；</p>\n<p>3.不可破解、仿制券码；</p>\n<p>4.支持用后核销；</p>\n<p>5.优惠券、兑换券属于广撒网的策略，所以利用率低，也就不适合使用数据。</p>\n<p><strong>库进行存储（占空间，有效的数据有少）</strong></p>\n<p>设计思路上，需要设计一种有效的兑换码生成策略，支持预先生成，支持校验，内容简洁，生成的兑换码都具有唯一性，那么这种策略就是一种特殊的编解码策略，按照约定的编解码规则支撑上述需求。</p>\n<p>既然是一种编解码规则，那么需要约定编码空间(也就是用户看到的组成兑换码的字符)，编码空间由字符 a-z,A-Z,数字 0-9 组成，为了增强兑换码的可识别度，剔除大写字母 O 以及 I,可用字符如下所示，共 60 个字符：</p>\n<p>abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXZY0123456789</p>\n<p>之前说过，兑换码要求近可能简洁，那么设计时就需要考虑兑换码的字符数，假设上限为 12 位，而字符空间有 60 位，那么可以表示的空间范围为 60^12=130606940160000000000000(也就是可以 12 位的兑换码可以生成天量,应该够运营同学挥霍了)，转换成 2 进制：</p>\n<p>1001000100000000101110011001101101110011000000000000000000000(61 位)</p>\n<p><strong>兑换码组成成分分析</strong></p>\n<p>兑换码可以预先生成，并且不需要额外的存储空间保存这些信息，每一个优惠方案都有独立的一组兑换码(指运营同学组织的每一场运营活动都有不同的兑换码,不能混合使用, 例如双 11 兑换码不能使用在双 12 活动上)，每个兑换码有自己的编号，防止重复，为了保证兑换码的有效性，对兑换码的数据需要进行校验，当前兑换码的数据组成如下所示：</p>\n<p>优惠方案 ID + 兑换码序列号 i + 校验码</p>\n<p><strong>编码方案</strong></p>\n<ol>\n<li>兑换码序列号 i，代表当前兑换码是当前活动中第 i 个兑换码，兑换码序列号的空间范围决定了优惠活动可以发行的兑换码数目，当前采用 30 位 bit 位表示，可表示范围：1073741824（10 亿个券码）。</li>\n<li>优惠方案 ID, 代表当前优惠方案的 ID 号，优惠方案的空间范围决定了可以组织的优惠活动次数，当前采用 15 位表示，可以表示范围：32768（考虑到运营活动的频率，以及 ID 的初始值 10000，15 位足够，365 天每天有运营活动，可以使用 54 年）。</li>\n<li>校验码，校验兑换码是否有效，主要为了快捷的校验兑换码信息的是否正确，其次可以起到填充数据的目的，增强数据的散列性，使用 13 位表示校验位，其中分为两部分，前 6 位和后 7 位。</li>\n</ol>\n<p>深耕业务还会有区分通用券和单独券的情况，分别具备以下特点，技术实现需要因地制宜地思考。</p>\n<ol>\n<li>通用券：多个玩家都可以输入兑换，然后有总量限制，期限限制。</li>\n<li>单独券：运营同学可以在后台设置兑换码的奖励物品、期限、个数，然后由后台生成兑换码的列表，兑换之后核销。</li>\n</ol>\n<h2>场景二：Tracing</h2>\n<h3>1、日志跟踪</h3>\n<p>在分布式服务架构下，一个 Web 请求从网关流入，有可能会调用多个服务对请求进行处理，拿到最终结果。这个过程中每个服务之间的通信又是单独的网络请求，无论请求经过的哪个服务出了故障或者处理过慢都会对前端造成影响。</p>\n<p>处理一个 Web 请求要调用的多个服务，为了能更方便的查询哪个环节的服务出现了问题，现在常用的解决方案是为整个系统引入分布式链路跟踪。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-tracing.png\" alt=\"在分布式链路跟踪\" tabindex=\"0\"><figcaption>在分布式链路跟踪</figcaption></figure>\n<p>在分布式链路跟踪中有两个重要的概念：跟踪（trace）和 跨度（ span)。trace 是请求在分布式系统中的整个链路视图，span 则代表整个链路中不同服务内部的视图，span 组合在一起就是整个 trace 的视图。</p>\n<p>在整个请求的调用链中，请求会一直携带 traceid 往下游服务传递，每个服务内部也会生成自己的 spanid 用于生成自己的内部调用视图，并和 traceid 一起传递给下游服务。</p>\n<h3>2、TraceId 生成规则</h3>\n<p>这种场景下，生成的 ID 除了要求唯一之外，还要求生成的效率高、吞吐量大。traceid 需要具备接入层的服务器实例自主生成的能力，如果每个 trace 中的 ID 都需要请求公共的 ID 服务生成，纯纯的浪费网络带宽资源。且会阻塞用户请求向下游传递，响应耗时上升，增加了没必要的风险。所以需要服务器实例最好可以自行计算 tracid，spanid，避免依赖外部服务。</p>\n<p>产生规则：服务器 IP + ID 产生的时间 + 自增序列 + 当前进程号 ，比如：</p>\n<p>0ad1348f1403169275002100356696</p>\n<p>前 8 位 0ad1348f 即产生 TraceId 的机器的 IP，这是一个十六进制的数字，每两位代表 IP 中的一段，我们把这个数字，按每两位转成 10 进制即可得到常见的 IP 地址表示方式 10.209.52.143，您也可以根据这个规律来查找到请求经过的第一个服务器。</p>\n<p>后面的 13 位 1403169275002 是产生 TraceId 的时间。之后的 4 位 1003 是一个自增的序列，从 1000 涨到 9000，到达 9000 后回到 1000 再开始往上涨。最后的 5 位 56696 是当前的进程 ID，为了防止单机多进程出现 TraceId 冲突的情况，所以在 TraceId 末尾添加了当前的进程 ID。</p>\n<h3>3、SpanId 生成规则</h3>\n<p>span 是层的意思，比如在第一个实例算是第一层， 请求代理或者分流到下一个实例处理，就是第二层，以此类推。通过层，SpanId 代表本次调用在整个调用链路树中的位置。</p>\n<p>假设一个 服务器实例 A 接收了一次用户请求，代表是整个调用的根节点，那么 A 层处理这次请求产生的非服务调用日志记录 spanid 的值都是 0，A 层需要通过 RPC 依次调用 B、C、D 三个服务器实例，那么在 A 的日志中，SpanId 分别是 0.1，0.2 和 0.3，在 B、C、D 中，SpanId 也分别是 0.1，0.2 和 0.3；如果 C 系统在处理请求的时候又调用了 E，F 两个服务器实例，那么 C 系统中对应的 spanid 是 0.2.1 和 0.2.2，E、F 两个系统对应的日志也是 0.2.1 和 0.2.2。</p>\n<p>根据上面的描述可以知道，如果把一次调用中所有的 SpanId 收集起来，可以组成一棵完整的链路树。</p>\n<p><strong>spanid 的生成本质：在跨层传递透传的同时，控制大小版本号的自增来实现的。</strong></p>\n<h2>场景三：短网址</h2>\n<p>短网址主要功能包括网址缩短与还原两大功能。相对于长网址，短网址可以更方便地在电子邮件，社交网络，微博和手机上传播，例如原来很长的网址通过短网址服务即可生成相应的短网址，避免折行或超出字符限制。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-short-url.png\" alt=\"短网址作用\" tabindex=\"0\"><figcaption>短网址作用</figcaption></figure>\n<p>常用的 ID 生成服务比如：MySQL ID 自增、 Redis 键自增、号段模式，生成的 ID 都是一串数字。短网址服务把客户的长网址转换成短网址，</p>\n<p>实际是在 dwz.cn 域名后面拼接新产生的数字类型 ID，直接用数字 ID，网址长度也有些长，服务可以通过数字 ID 转更高进制的方式压缩长度。这种算法在短网址的技术实现上越来越多了起来，它可以进一步压缩网址长度。转进制的压缩算法在生活中有广泛的应用场景，举例：</p>\n<ul>\n<li>客户的长网址：<a href=\"https://wenku.baidu.com/ndbusiness/browse/wenkuvipcashier?cashier_code=PCoperatebanner\" target=\"_blank\" rel=\"noopener noreferrer\">https://wenku.baidu.com/ndbusiness/browse/wenkuvipcashier?cashier_code=PCoperatebanner</a></li>\n<li>ID 映射的短网址：<a href=\"https://dwz.cn/2047601319t66\" target=\"_blank\" rel=\"noopener noreferrer\">https://dwz.cn/2047601319t66</a> (演示使用，可能无法正确打开)</li>\n<li>转进制后的短网址：<a href=\"https://dwz.cn/2ezwDJ0\" target=\"_blank\" rel=\"noopener noreferrer\">https://dwz.cn/2ezwDJ0</a> (演示使用，可能无法正确打开)</li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-pay-one-card.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "分布式ID介绍&实现方案总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-id.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-id.html",
      "summary": "分布式 ID 介绍 什么是 ID？ 日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。 我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应 简单来说，ID 就是数据的唯一标识。 什么是分布式 ID？...",
      "content_html": "<h2>分布式 ID 介绍</h2>\n<h3>什么是 ID？</h3>\n<p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。</p>\n<p>我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应</p>\n<p>简单来说，<strong>ID 就是数据的唯一标识</strong>。</p>\n<h3>什么是分布式 ID？</h3>\n<p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。</p>\n<p>我简单举一个分库分表的例子。</p>\n<p>我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。</p>\n<p>在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。<strong>我们如何为不同的数据节点生成全局唯一主键呢？</strong></p>\n<p>这个时候就需要生成<strong>分布式 ID</strong>了。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/id-after-the-sub-table-not-conflict.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>分布式 ID 需要满足哪些要求?</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-requirements.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。</p>\n<p>一个最基本的分布式 ID 需要满足下面这些要求：</p>\n<ul>\n<li><strong>全局唯一</strong>：ID 的全局唯一性肯定是首先要满足的！</li>\n<li><strong>高性能</strong>：分布式 ID 的生成速度要快，对本地资源消耗要小。</li>\n<li><strong>高可用</strong>：生成分布式 ID 的服务要保证可用性无限接近于 100%。</li>\n<li><strong>方便易用</strong>：拿来即用，使用方便，快速接入！</li>\n</ul>\n<p>除了这些之外，一个比较好的分布式 ID 还应保证：</p>\n<ul>\n<li><strong>安全</strong>：ID 中不包含敏感信息。</li>\n<li><strong>有序递增</strong>：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li>\n<li><strong>有具体的业务含义</strong>：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。</li>\n<li><strong>独立部署</strong>：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。</li>\n</ul>\n<h2>分布式 ID 常见解决方案</h2>\n<h3>数据库</h3>\n<h4>数据库主键自增</h4>\n<p>这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/the-primary-key-of-the-database-increases-automatically.png\" alt=\"数据库主键自增\" tabindex=\"0\"><figcaption>数据库主键自增</figcaption></figure>\n<p>以 MySQL 举例，我们通过下面的方式即可。</p>\n<p><strong>1.创建一个数据库表。</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>sequence_id<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">unsigned</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>stub<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">char</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>stub<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>stub<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8mb4<span class=\"token punctuation\">;</span>\n</code></pre></div><p><code>stub</code> 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 <code>stub</code> 字段创建了唯一索引，保证其唯一性。</p>\n<p><strong>2.通过 <code>replace into</code> 来插入数据。</strong></p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token constant\">BEGIN</span><span class=\"token punctuation\">;</span>\n<span class=\"token constant\">REPLACE</span> <span class=\"token class-name\">INTO</span> sequence_id <span class=\"token punctuation\">(</span>stub<span class=\"token punctuation\">)</span> <span class=\"token constant\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token char\">'stub'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">SELECT</span> <span class=\"token function\">LAST_INSERT_ID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token constant\">COMMIT</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>插入数据这里，我们没有使用 <code>insert into</code> 而是使用 <code>replace into</code> 来插入数据，具体步骤是这样的：</p>\n<ul>\n<li>\n<p>第一步：尝试把数据插入到表中。</p>\n</li>\n<li>\n<p>第二步：如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。</p>\n</li>\n</ul>\n<p>这种方式的优缺点也比较明显：</p>\n<ul>\n<li><strong>优点</strong>：实现起来比较简单、ID 有序递增、存储消耗空间小</li>\n<li><strong>缺点</strong>：支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）</li>\n</ul>\n<h4>数据库号段模式</h4>\n<p>数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。</p>\n<p>如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 <strong>基于数据库的号段模式来生成分布式 ID。</strong></p>\n<p>数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的<a href=\"https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D\" target=\"_blank\" rel=\"noopener noreferrer\">Tinyid</a> 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。</p>\n<p>以 MySQL 举例，我们通过下面的方式即可。</p>\n<p><strong>1. 创建一个数据库表。</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>sequence_id_generator<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>current_max_id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'当前最大id'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>step<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'号段的长度'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>version<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'版本号'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>biz_type<span class=\"token punctuation\">`</span></span>    <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'业务类型'</span><span class=\"token punctuation\">,</span>\n   <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8mb4<span class=\"token punctuation\">;</span>\n</code></pre></div><p><code>current_max_id</code> 字段和<code>step</code>字段主要用于获取批量 ID，获取的批量 id 为：<code>current_max_id ~ current_max_id+step</code>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/database-number-segment-mode.png\" alt=\"数据库号段模式\" tabindex=\"0\"><figcaption>数据库号段模式</figcaption></figure>\n<p><code>version</code> 字段主要用于解决并发问题（乐观锁）,<code>biz_type</code> 主要用于表示业务类型。</p>\n<p><strong>2. 先插入一行数据。</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>sequence_id_generator<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>current_max_id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>step<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>version<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>biz_type<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">VALUES</span>\n <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">101</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>3. 通过 SELECT 获取指定业务下的批量唯一 ID</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>current_max_id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>step<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>version<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">FROM</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>sequence_id_generator<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">where</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>biz_type<span class=\"token punctuation\">`</span></span> <span class=\"token operator\">=</span> <span class=\"token number\">101</span>\n</code></pre></div><p>结果：</p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>id current_max_id step version biz_type\n1 0 100 0 101\n</code></pre></div><p><strong>4. 不够用的话，更新之后重新 SELECT 即可。</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">UPDATE</span> sequence_id_generator <span class=\"token keyword\">SET</span> current_max_id <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token operator\">+</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> version<span class=\"token operator\">=</span>version<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token keyword\">WHERE</span> version <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token operator\">AND</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>biz_type<span class=\"token punctuation\">`</span></span> <span class=\"token operator\">=</span> <span class=\"token number\">101</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>current_max_id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>step<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>version<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">FROM</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>sequence_id_generator<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">where</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>biz_type<span class=\"token punctuation\">`</span></span> <span class=\"token operator\">=</span> <span class=\"token number\">101</span>\n</code></pre></div><p>结果：</p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>id current_max_id step version biz_type\n1 100 100 1 101\n</code></pre></div><p>相比于数据库主键自增的方式，<strong>数据库的号段模式对于数据库的访问次数更少，数据库压力更小。</strong></p>\n<p>另外，为了避免单点问题，你可以从使用主从模式来提高可用性。</p>\n<p><strong>数据库号段模式的优缺点:</strong></p>\n<ul>\n<li><strong>优点</strong>：ID 有序递增、存储消耗空间小</li>\n<li><strong>缺点</strong>：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）</li>\n</ul>\n<h4>NoSQL</h4>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/nosql-distributed-id.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 <code>incr</code> 命令即可实现对 id 原子顺序递增。</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>&gt;</span> <span class=\"token builtin class-name\">set</span> sequence_id_biz_type <span class=\"token number\">1</span>\nOK\n<span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>&gt;</span> incr sequence_id_biz_type\n<span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span>\n<span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>&gt;</span> get sequence_id_biz_type\n<span class=\"token string\">\"2\"</span>\n</code></pre></div><p>为了提高可用性和并发，我们可以使用 Redis Cluster。Redis Cluster 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。</p>\n<p>除了 Redis Cluster 之外，你也可以使用开源的 Redis 集群方案<a href=\"https://github.com/CodisLabs/codis\" target=\"_blank\" rel=\"noopener noreferrer\">Codis</a> （大规模集群比如上百个节点的时候比较推荐）。</p>\n<p>除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis 支持两种不同的持久化方式：<strong>快照（snapshotting，RDB）</strong>、<strong>只追加文件（append-only file, AOF）</strong>。 并且，Redis 4.0 开始支持 <strong>RDB 和 AOF 的混合持久化</strong>（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>\n<p>关于 Redis 持久化，我这里就不过多介绍。不了解这部分内容的小伙伴，可以看看 <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 对于 Redis 知识点的总结</a>。</p>\n<p><strong>Redis 方案的优缺点：</strong></p>\n<ul>\n<li><strong>优点</strong>：性能不错并且生成的 ID 是有序递增的</li>\n<li><strong>缺点</strong>：和数据库主键自增方案的缺点类似</li>\n</ul>\n<p>除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/mongodb9-objectId-distributed-id.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>MongoDB ObjectId 一共需要 12 个字节存储：</p>\n<ul>\n<li>0~3：时间戳</li>\n<li>3~6：代表机器 ID</li>\n<li>7~8：机器进程 ID</li>\n<li>9~11：自增值</li>\n</ul>\n<p><strong>MongoDB 方案的优缺点：</strong></p>\n<ul>\n<li><strong>优点</strong>：性能不错并且生成的 ID 是有序递增的</li>\n<li><strong>缺点</strong>：需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）、有安全性问题（ID 生成有规律性）</li>\n</ul>\n<h3>算法</h3>\n<h4>UUID</h4>\n<p>UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。</p>\n<p>JDK 就提供了现成的生成 UUID 的方法，一行代码就行了。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa</span>\n<span class=\"token constant\">UUID</span><span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre></div><p><a href=\"https://tools.ietf.org/html/rfc4122\" target=\"_blank\" rel=\"noopener noreferrer\">RFC 4122</a> 中关于 UUID 的示例是这样的：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/rfc-4122-uuid.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。</p>\n<p>5 种不同的 Version(版本)值分别对应的含义（参考<a href=\"https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科对于 UUID 的介绍</a>）：</p>\n<ul>\n<li><strong>版本 1</strong> : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；</li>\n<li><strong>版本 2</strong> : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；</li>\n<li><strong>版本 3、版本 5</strong> : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；</li>\n<li><strong>版本 4</strong> : UUID 使用<a href=\"https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%80%A7\" target=\"_blank\" rel=\"noopener noreferrer\">随机性</a>或<a href=\"https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%80%A7\" target=\"_blank\" rel=\"noopener noreferrer\">伪随机性</a>生成。</li>\n</ul>\n<p>下面是 Version 1 版本下生成的 UUID 的示例：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/version1-uuid.png\" alt=\"Version 1 版本下生成的 UUID 的示例\" tabindex=\"0\"><figcaption>Version 1 版本下生成的 UUID 的示例</figcaption></figure>\n<p>JDK 中通过 <code>UUID</code> 的 <code>randomUUID()</code> 方法生成的 UUID 的版本默认为 4。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">UUID</span> uuid <span class=\"token operator\">=</span> <span class=\"token constant\">UUID</span><span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> version <span class=\"token operator\">=</span> uuid<span class=\"token punctuation\">.</span><span class=\"token function\">version</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 4</span>\n</code></pre></div><p>另外，Variant(变体)也有 4 种不同的值，这种值分别对应不同的含义。这里就不介绍了，貌似平时也不怎么需要关注。</p>\n<p>需要用到的时候，去看看维基百科对于 UUID 的 Variant(变体) 相关的介绍即可。</p>\n<p>从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。</p>\n<p>虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。</p>\n<p>比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：</p>\n<ul>\n<li>数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。</li>\n<li>UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。</li>\n</ul>\n<p>最后，我们再简单分析一下 <strong>UUID 的优缺点</strong> （面试的时候可能会被问到的哦！） :</p>\n<ul>\n<li><strong>优点</strong>：生成速度比较快、简单易用</li>\n<li><strong>缺点</strong>：存储消耗空间大（32 个字符串，128 位）、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）</li>\n</ul>\n<h4>Snowflake(雪花算法)</h4>\n<p>Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：</p>\n<ul>\n<li><strong>第 0 位</strong>：符号位（标识正负），始终为 0，没有用，不用管。</li>\n<li><strong>第 1~41 位</strong>：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</li>\n<li><strong>第 42~52 位</strong>：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。</li>\n<li><strong>第 53~64 位</strong>：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/snowflake-distributed-id-schematic-diagram.png\" alt=\"Snowflake 示意图\" tabindex=\"0\"><figcaption>Snowflake 示意图</figcaption></figure>\n<p>如果你想要使用 Snowflake 算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。</p>\n<p>另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。</p>\n<p>我们再来看看 Snowflake 算法的优缺点：</p>\n<ul>\n<li><strong>优点</strong>：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）</li>\n<li><strong>缺点</strong>：需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。</li>\n</ul>\n<h3>开源框架</h3>\n<h4>UidGenerator(百度)</h4>\n<p><a href=\"https://github.com/baidu/uid-generator\" target=\"_blank\" rel=\"noopener noreferrer\">UidGenerator</a> 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。</p>\n<p>不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/uidgenerator-distributed-id-schematic-diagram.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。</p>\n<p>UidGenerator 官方文档中的介绍如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/uidgenerator-introduction-official-documents.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>自 18 年后，UidGenerator 就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看 <a href=\"https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md\" target=\"_blank\" rel=\"noopener noreferrer\">UidGenerator 的官方介绍</a>。</p>\n<h4>Leaf(美团)</h4>\n<p><strong><a href=\"https://github.com/Meituan-Dianping/Leaf\" target=\"_blank\" rel=\"noopener noreferrer\">Leaf</a></strong> 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话：“There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！</p>\n<p>Leaf 提供了 <strong>号段模式</strong> 和 <strong>Snowflake(雪花算法)</strong> 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。</p>\n<p>Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。</p>\n<p>Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章：<a href=\"https://tech.meituan.com/2017/04/21/mt-leaf.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Leaf——美团点评分布式 ID 生成系统》</a>）。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-5c152efed042a8fe7e13692e0339d577f5c.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms。</p>\n<h4>Tinyid(滴滴)</h4>\n<p><a href=\"https://github.com/didi/tinyid\" target=\"_blank\" rel=\"noopener noreferrer\">Tinyid</a> 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。</p>\n<p>数据库号段模式的原理我们在上面已经介绍过了。<strong>Tinyid 有哪些亮点呢？</strong></p>\n<p>为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:<a href=\"https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D\" target=\"_blank\" rel=\"noopener noreferrer\">《Tinyid 原理介绍》</a>）</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-4afc0e45c0c86ba5ad645d023dce11e53c2.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。</p>\n<p>这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题：</p>\n<ul>\n<li>获取新号段的情况下，程序获取唯一 ID 的速度比较慢。</li>\n<li>需要保证 DB 高可用，这个是比较麻烦且耗费资源的。</li>\n</ul>\n<p>除此之外，HTTP 调用也存在网络开销。</p>\n<p>Tinyid 的原理比较简单，其架构如下图所示：</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-53f74cd615178046d6c04fe50513fee74ce.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化：</p>\n<ul>\n<li><strong>双号段缓存</strong>：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。</li>\n<li><strong>增加多 db 支持</strong>：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。</li>\n<li><strong>增加 tinyid-client</strong>：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。</li>\n</ul>\n<p>Tinyid 的优缺点这里就不分析了，结合数据库号段模式的优缺点和 Tinyid 的原理就能知道。</p>\n<h2>总结</h2>\n<p>通过这篇文章，我基本上已经把最常见的分布式 ID 生成方案都总结了一波。</p>\n<p>除了上面介绍的方式之外，像 ZooKeeper 这类中间件也可以帮助我们生成唯一 ID。<strong>没有银弹，一定要结合实际项目来选择最适合自己的方案。</strong></p>\n<p>不过，本文主要介绍的是分布式 ID 的理论知识。在实际的面试中，面试官可能会结合具体的业务场景来考察你对分布式 ID 的设计，你可以参考这篇文章：<a href=\"https://chat.yqcloud.top/distributed-id-design.md\" target=\"_blank\" rel=\"noopener noreferrer\">分布式 ID 设计指南</a>（对于实际工作中分布式 ID 的设计也非常有帮助）。</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/id-after-the-sub-table-not-conflict.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "分布式锁常见实现方案总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-lock-implementations.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-lock-implementations.html",
      "summary": "通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也先以 Redis 为例介绍分布式锁的实现。 基于 Redis 实现分布式锁 如何基于 Redis 实现一个最简易的分布式锁？ 不论是本地锁还是分布式锁，核心都在于“互斥”。 在 Redis 中， SETNX 命令是可以帮助我们实现互斥...",
      "content_html": "<p>通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也先以 Redis 为例介绍分布式锁的实现。</p>\n<h2>基于 Redis 实现分布式锁</h2>\n<h3>如何基于 Redis 实现一个最简易的分布式锁？</h3>\n<p>不论是本地锁还是分布式锁，核心都在于“互斥”。</p>\n<p>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token operator\">&gt;</span> SETNX lockKey uniqueValue\n<span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span>\n<span class=\"token operator\">&gt;</span> SETNX lockKey uniqueValue\n<span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">0</span>\n</code></pre></div><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token operator\">&gt;</span> DEL lockKey\n<span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1</span>\n</code></pre></div><p>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</p>\n<p>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p>\n<div class=\"language-lua\" data-ext=\"lua\" data-title=\"lua\"><pre class=\"language-lua\"><code><span class=\"token operator\">//</span> 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放\n<span class=\"token keyword\">if</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get\"</span><span class=\"token punctuation\">,</span>KEYS<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> ARGV<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">then</span>\n    <span class=\"token keyword\">return</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"del\"</span><span class=\"token punctuation\">,</span>KEYS<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">end</span>\n</code></pre></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-setnx.png\" alt=\"Redis 实现简易分布式锁\" tabindex=\"0\"><figcaption>Redis 实现简易分布式锁</figcaption></figure>\n<p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。</p>\n<h3>为什么要给锁设置一个过期时间？</h3>\n<p>为了避免锁无法被释放，我们可以想到的一个解决办法就是：<strong>给这个 key（也就是锁） 设置一个过期时间</strong> 。</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>&gt;</span> SET lockKey uniqueValue EX <span class=\"token number\">3</span> NX\nOK\n</code></pre></div><ul>\n<li><strong>lockKey</strong>：加锁的锁名；</li>\n<li><strong>uniqueValue</strong>：能够唯一标示锁的随机字符串；</li>\n<li><strong>NX</strong>：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；</li>\n<li><strong>EX</strong>：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li>\n</ul>\n<p><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！！！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</p>\n<p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p>\n<p>你或许在想：<strong>如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！</strong></p>\n<h3>如何实现锁的优雅续期？</h3>\n<p>对于 Java 开发的小伙伴来说，已经有了现成的解决方案：<strong><a href=\"https://github.com/redisson/redisson\" target=\"_blank\" rel=\"noopener noreferrer\">Redisson</a></strong> 。其他语言的解决方案，可以在 Redis 官方文档中找到，地址：<a href=\"https://redis.io/topics/distlock\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/topics/distlock</a> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/redis-distributed-lock.png\" alt=\"Distributed locks with Redis\" tabindex=\"0\"><figcaption>Distributed locks with Redis</figcaption></figure>\n<p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。</p>\n<p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-redisson-renew-expiration.png\" alt=\"Redisson 看门狗自动续期\" tabindex=\"0\"><figcaption>Redisson 看门狗自动续期</figcaption></figure>\n<p>看门狗名字的由来于 <code>getLockWatchdogTimeout()</code> 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（<a href=\"https://github.com/redisson/redisson/releases/tag/redisson-3.17.6\" target=\"_blank\" rel=\"noopener noreferrer\">redisson-3.17.6</a>）。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">//默认 30秒，支持修改</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">long</span> lockWatchdogTimeout <span class=\"token operator\">=</span> <span class=\"token number\">30</span> <span class=\"token operator\">*</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Config</span> <span class=\"token function\">setLockWatchdogTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> lockWatchdogTimeout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lockWatchdogTimeout <span class=\"token operator\">=</span> lockWatchdogTimeout<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> <span class=\"token function\">getLockWatchdogTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span> lockWatchdogTimeout<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><code>renewExpiration()</code> 方法包含了看门狗的主要逻辑：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">renewExpiration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token comment\">//......</span>\n        <span class=\"token class-name\">Timeout</span> task <span class=\"token operator\">=</span> commandExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">getConnectionManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">TimerTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Timeout</span> timeout<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">//......</span>\n                <span class=\"token comment\">// 异步续期，基于 Lua 脚本</span>\n                <span class=\"token class-name\">CompletionStage</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">&gt;</span></span> future <span class=\"token operator\">=</span> <span class=\"token function\">renewExpirationAsync</span><span class=\"token punctuation\">(</span>threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                future<span class=\"token punctuation\">.</span><span class=\"token function\">whenComplete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span> <span class=\"token operator\">-&gt;</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token comment\">// 无法续期</span>\n                        log<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Can't update lock \"</span> <span class=\"token operator\">+</span> <span class=\"token function\">getRawName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" expiration\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token constant\">EXPIRATION_RENEWAL_MAP</span><span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token function\">getEntryName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token comment\">// 递归调用实现续期</span>\n                        <span class=\"token function\">renewExpiration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token comment\">// 取消续期</span>\n                        <span class=\"token function\">cancelExpirationRenewal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n         <span class=\"token comment\">// 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> internalLockLeaseTime <span class=\"token operator\">/</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MILLISECONDS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        ee<span class=\"token punctuation\">.</span><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre></div><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p>\n<p>Watch Dog 通过调用 <code>renewExpirationAsync()</code> 方法实现锁的异步续期：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">protected</span> <span class=\"token class-name\">CompletionStage</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">renewExpirationAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> threadId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">evalWriteAsync</span><span class=\"token punctuation\">(</span><span class=\"token function\">getRawName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">LongCodec</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INSTANCE</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">RedisCommands</span><span class=\"token punctuation\">.</span><span class=\"token constant\">EVAL_BOOLEAN</span><span class=\"token punctuation\">,</span>\n            <span class=\"token comment\">// 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）</span>\n            <span class=\"token string\">\"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \"</span> <span class=\"token operator\">+</span>\n                    <span class=\"token string\">\"redis.call('pexpire', KEYS[1], ARGV[1]); \"</span> <span class=\"token operator\">+</span>\n                    <span class=\"token string\">\"return 1; \"</span> <span class=\"token operator\">+</span>\n                    <span class=\"token string\">\"end; \"</span> <span class=\"token operator\">+</span>\n                    <span class=\"token string\">\"return 0;\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">singletonList</span><span class=\"token punctuation\">(</span><span class=\"token function\">getRawName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            internalLockLeaseTime<span class=\"token punctuation\">,</span> <span class=\"token function\">getLockName</span><span class=\"token punctuation\">(</span>threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>可以看出， <code>renewExpirationAsync</code> 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。</p>\n<p>我这里以 Redisson 的分布式可重入锁 <code>RLock</code> 为例来说明如何使用 Redisson 实现分布式锁：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 1.获取指定的分布式锁对象</span>\n<span class=\"token class-name\">RLock</span> lock <span class=\"token operator\">=</span> redisson<span class=\"token punctuation\">.</span><span class=\"token function\">getLock</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lock\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制</span>\nlock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 3.执行业务</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token comment\">// 4.释放锁</span>\nlock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制</span>\nlock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。</p>\n<h3>如何实现可重入锁？</h3>\n<p>所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p>\n<p><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。</strong></p>\n<p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p>\n<p>实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/redisson-readme-locks.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>Redis 如何解决集群情况下分布式锁的可靠性？</h3>\n<p>为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。</p>\n<p>Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/redis-master-slave-distributed-lock.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>针对这个问题，Redis 之父 antirez 设计了 <a href=\"https://redis.io/topics/distlock\" target=\"_blank\" rel=\"noopener noreferrer\">Redlock 算法</a> 来解决。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-redis.io-realock.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p>\n<p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p>\n<p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p>\n<p>Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（<a href=\"https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html\" target=\"_blank\" rel=\"noopener noreferrer\">How to do distributed locking - Martin Kleppmann - 2016</a>）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505097&amp;idx=1&amp;sn=5c03cb769c4458350f4d4a321ad51f5a&amp;source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 锁从面试连环炮聊到神仙打架</a>这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。</p>\n<p>实际项目中不建议使用 Redlock 算法，成本和收益不成正比。</p>\n<p>如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。</p>\n<h2>基于 ZooKeeper 实现分布式锁</h2>\n<p>Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。</p>\n<h3>如何基于 ZooKeeper 实现分布式锁？</h3>\n<p>ZooKeeper 分布式锁是基于 <strong>临时顺序节点</strong> 和 <strong>Watcher（事件监听器）</strong> 实现的。</p>\n<p>获取锁：</p>\n<ol>\n<li>首先我们要有一个持久节点<code>/locks</code>，客户端获取锁就是在<code>locks</code>下创建临时顺序节点。</li>\n<li>假设客户端 1 创建了<code>/locks/lock1</code>节点，创建成功之后，会判断 <code>lock1</code>是否是 <code>/locks</code> 下最小的子节点。</li>\n<li>如果 <code>lock1</code>是最小的子节点，则获取锁成功。否则，获取锁失败。</li>\n<li>如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如<code>/locks/lock0</code>上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li>\n</ol>\n<p>释放锁：</p>\n<ol>\n<li>成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。</li>\n<li>成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。</li>\n<li>我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-zookeeper.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p>\n<p><code>Curator</code>主要实现了下面四种锁：</p>\n<ul>\n<li><code>InterProcessMutex</code>：分布式可重入排它锁</li>\n<li><code>InterProcessSemaphoreMutex</code>：分布式不可重入排它锁</li>\n<li><code>InterProcessReadWriteLock</code>：分布式读写锁</li>\n<li><code>InterProcessMultiLock</code>：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。</li>\n</ul>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">CuratorFramework</span> client <span class=\"token operator\">=</span> <span class=\"token class-name\">ZKUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nclient<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 分布式可重入排它锁</span>\n<span class=\"token class-name\">InterProcessLock</span> lock1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterProcessMutex</span><span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">,</span> lockPath1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 分布式不可重入排它锁</span>\n<span class=\"token class-name\">InterProcessLock</span> lock2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterProcessSemaphoreMutex</span><span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">,</span> lockPath2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 将多个锁作为一个整体</span>\n<span class=\"token class-name\">InterProcessMultiLock</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterProcessMultiLock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>lock1<span class=\"token punctuation\">,</span> lock2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"不能获取多锁\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"已获取多锁\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"是否有第一个锁: \"</span> <span class=\"token operator\">+</span> lock1<span class=\"token punctuation\">.</span><span class=\"token function\">isAcquiredInThisProcess</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"是否有第二个锁: \"</span> <span class=\"token operator\">+</span> lock2<span class=\"token punctuation\">.</span><span class=\"token function\">isAcquiredInThisProcess</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 资源操作</span>\n    resource<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"释放多个锁\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"是否有第一个锁: \"</span> <span class=\"token operator\">+</span> lock1<span class=\"token punctuation\">.</span><span class=\"token function\">isAcquiredInThisProcess</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"是否有第二个锁: \"</span> <span class=\"token operator\">+</span> lock2<span class=\"token punctuation\">.</span><span class=\"token function\">isAcquiredInThisProcess</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nclient<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><h3>为什么要用临时顺序节点？</h3>\n<p>每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。</p>\n<p>我们通常是将 znode 分为 4 大类：</p>\n<ul>\n<li><strong>持久（PERSISTENT）节点</strong>：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>\n<li><strong>临时（EPHEMERAL）节点</strong>：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li>\n<li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong>：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code>、<code>/node1/app0000000002</code> 。</li>\n<li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong>：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>\n</ul>\n<p>可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。</p>\n<p>使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。</p>\n<p>假设不适用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。</p>\n<h3>为什么要设置对前一个节点的监听？</h3>\n<blockquote>\n<p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>\n</blockquote>\n<p>同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。</p>\n<p>这个事件监听器的作用是：<strong>当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 <code>wait/notifyAll</code> ），让它尝试去获取锁，然后就成功获取锁了。</strong></p>\n<h3>如何实现可重入锁？</h3>\n<p>这里以 Curator 的 <code>InterProcessMutex</code> 对可重入锁的实现来介绍（源码地址：<a href=\"https://github.com/apache/curator/blob/master/curator-recipes/src/main/java/org/apache/curator/framework/recipes/locks/InterProcessMutex.java\" target=\"_blank\" rel=\"noopener noreferrer\">InterProcessMutex.java</a>）。</p>\n<p>当我们调用 <code>InterProcessMutex#acquire</code>方法获取锁的时候，会调用<code>InterProcessMutex#internalLock</code>方法。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 获取可重入互斥锁，直到获取成功为止</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">internalLock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Lost connection while trying to acquire lock: \"</span> <span class=\"token operator\">+</span> basePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><code>internalLock</code> 方法会先获取当前请求锁的线程，然后从 <code>threadData</code>( <code>ConcurrentMap&lt;Thread, LockData&gt;</code> 类型)中获取当前线程对应的 <code>lockData</code> 。 <code>lockData</code> 包含锁的信息和加锁的次数，是实现可重入锁的关键。</p>\n<p>第一次获取锁的时候，<code>lockData</code>为 <code>null</code>。获取锁成功之后，会将当前线程和对应的 <code>lockData</code> 放到 <code>threadData</code> 中</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">internalLock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> time<span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 获取当前请求锁的线程</span>\n  <span class=\"token class-name\">Thread</span> currentThread <span class=\"token operator\">=</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 拿对应的 lockData</span>\n  <span class=\"token class-name\">LockData</span> lockData <span class=\"token operator\">=</span> threadData<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>currentThread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 第一次获取锁的话，lockData 为 null</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lockData <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 当前线程获取过一次锁之后</span>\n    <span class=\"token comment\">// 因为当前线程的锁存在， lockCount 自增后返回，实现锁重入.</span>\n    lockData<span class=\"token punctuation\">.</span>lockCount<span class=\"token punctuation\">.</span><span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 尝试获取锁</span>\n  <span class=\"token class-name\">String</span> lockPath <span class=\"token operator\">=</span> internals<span class=\"token punctuation\">.</span><span class=\"token function\">attemptLock</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">,</span> <span class=\"token function\">getLockNodeBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lockPath <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">LockData</span> newLockData <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LockData</span><span class=\"token punctuation\">(</span>currentThread<span class=\"token punctuation\">,</span> lockPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token comment\">// 获取锁成功之后，将当前线程和对应的 lockData 放到 threadData 中</span>\n    threadData<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>currentThread<span class=\"token punctuation\">,</span> newLockData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><code>LockData</code>是 <code>InterProcessMutex</code>中的一个静态内部类。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ConcurrentMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">LockData</span><span class=\"token punctuation\">&gt;</span></span> threadData <span class=\"token operator\">=</span> <span class=\"token class-name\">Maps</span><span class=\"token punctuation\">.</span><span class=\"token function\">newConcurrentMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LockData</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 当前持有锁的线程</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">Thread</span> owningThread<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 锁对应的子节点</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> lockPath<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 加锁的次数</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">AtomicInteger</span> lockCount <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">LockData</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span> owningThread<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> lockPath<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>owningThread <span class=\"token operator\">=</span> owningThread<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lockPath <span class=\"token operator\">=</span> lockPath<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>如果已经获取过一次锁，后面再来获取锁的话，直接就会在 <code>if (lockData != null)</code> 这里被拦下了，然后就会执行<code>lockData.lockCount.incrementAndGet();</code> 将加锁次数加 1。</p>\n<p>整个可重入锁的实现逻辑非常简单，直接在客户端判断当前线程有没有获取锁，有的话直接将加锁次数加 1 就可以了。</p>\n<h2>总结</h2>\n<p>这篇文章我们介绍了实现分布式锁的两种常见方式。至于具体选择 Redis 还是 ZooKeeper 来实现分布式锁，还是要看业务的具体需求。如果对性能要求比较高的话，建议使用 Redis 实现分布式锁。如果对可靠性要求比较高的话，建议使用 ZooKeeper 实现分布式锁。</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-setnx.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "分布式锁介绍",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-lock.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-lock.html",
      "summary": "网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。 这篇文章我们先介绍一下分布式锁的基本概念。 为什么需要分布式锁？ 在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。 举个例子，假设现在有 100 个用户参与某个限时秒杀活动...",
      "content_html": "<p>网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。</p>\n<p>这篇文章我们先介绍一下分布式锁的基本概念。</p>\n<h2>为什么需要分布式锁？</h2>\n<p>在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。</p>\n<p>举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况：</p>\n<ul>\n<li>线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。</li>\n<li>线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</li>\n<li>线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</li>\n<li>线程 1 继续执行，将库存数量减少 1 个，然后返回成功。</li>\n<li>线程 2 继续执行，将库存数量减少 1 个，然后返回成功。</li>\n<li>此时就发生了超卖问题，导致商品被多卖了一份。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/oversold-without-locking.png\" alt=\"共享资源未互斥访问导致出现问题\" tabindex=\"0\"><figcaption>共享资源未互斥访问导致出现问题</figcaption></figure>\n<p>为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。</p>\n<p><strong>如何才能实现共享资源的互斥访问呢？</strong> 锁是一个比较通用的解决方案，更准确点来说是悲观锁。</p>\n<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p>\n<p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p>\n<p>下面是我对本地锁画的一张示意图。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/jvm-local-lock.png\" alt=\"本地锁\" tabindex=\"0\"><figcaption>本地锁</figcaption></figure>\n<p>从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。</p>\n<p>分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong> 就诞生了。</p>\n<p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。</p>\n<p>下面是我对分布式锁画的一张示意图。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock.png\" alt=\"分布式锁\" tabindex=\"0\"><figcaption>分布式锁</figcaption></figure>\n<p>从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。</p>\n<h2>分布式锁应该具备哪些条件？</h2>\n<p>一个最基本的分布式锁需要满足：</p>\n<ul>\n<li><strong>互斥</strong>：任意一个时刻，锁只能被一个线程持有。</li>\n<li><strong>高可用</strong>：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。</li>\n<li><strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取锁。</li>\n</ul>\n<p>除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：</p>\n<ul>\n<li><strong>高性能</strong>：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。</li>\n<li><strong>非阻塞</strong>：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。</li>\n</ul>\n<h2>分布式锁的常见实现方式有哪些？</h2>\n<p>常见分布式锁实现方案如下：</p>\n<ul>\n<li>基于关系型数据库比如 MySQL 实现分布式锁。</li>\n<li>基于分布式协调服务 ZooKeeper 实现分布式锁。</li>\n<li>基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。</li>\n</ul>\n<p>关系型数据库的方式一般是通过唯一索引或者排他锁实现。不过，一般不会使用这种方式，问题太多比如性能太差、不具备锁失效机制。</p>\n<p>基于 ZooKeeper 或者 Redis 实现分布式锁这两种实现方式要用的更多一些，我专门写了一篇文章来详细介绍这两种方案：<a href=\"/Note-Book/distributed-system/distributed-lock-implementations.html\" target=\"_blank\">分布式锁常见实现方案总结</a>。</p>\n<h2>总结</h2>\n<p>这篇文章我们主要介绍了：</p>\n<ul>\n<li>分布式锁的用途：分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。</li>\n<li>分布式锁的应该具备的条件：互斥、高可用、可重入、高性能、非阻塞。</li>\n<li>分布式锁的常见实现方式：关系型数据库比如 MySQL、分布式协调服务 ZooKeeper、分布式键值存储系统比如 Redis 、Etcd 。</li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/oversold-without-locking.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "分布式事务常见问题总结(付费)",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-transaction.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/distributed-transaction.html",
      "summary": "分布式事务 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>分布式事务</strong> 相关的面试题为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。</p>\n<figure><img src=\"https://oss.javaguide.cn/javamianshizhibei/distributed-system.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/javamianshizhibei/distributed-system.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Spring Cloud Gateway常见问题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/spring-cloud-gateway-questions.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/spring-cloud-gateway-questions.html",
      "summary": "本文重构完善自6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理 - 悟空聊架构这篇文章。 什么是 Spring Cloud Gateway？ Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 Zuul。准确点来说，应该是 Zuul 1.x...",
      "content_html": "<blockquote>\n<p>本文重构完善自<a href=\"https://mp.weixin.qq.com/s/XjFYsP1IUqNzWqXZdJn-Aw\" target=\"_blank\" rel=\"noopener noreferrer\">6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理 - 悟空聊架构</a>这篇文章。</p>\n</blockquote>\n<h2>什么是 Spring Cloud Gateway？</h2>\n<p>Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 <strong>Zuul</strong>。准确点来说，应该是 Zuul 1.x。Spring Cloud Gateway 起步要比 Zuul 2.x 更早。</p>\n<p>为了提升网关的性能，Spring Cloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I/O。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway- demo.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。</p>\n<p>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。</p>\n<ul>\n<li>GitHub 地址： <a href=\"https://github.com/spring-cloud/spring-cloud-gateway\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/spring-cloud/spring-cloud-gateway</a></li>\n<li>官网： <a href=\"https://spring.io/projects/spring-cloud-gateway\" target=\"_blank\" rel=\"noopener noreferrer\">https://spring.io/projects/spring-cloud-gateway</a></li>\n</ul>\n<h2>Spring Cloud Gateway 的工作流程？</h2>\n<p>Spring Cloud Gateway 的工作流程如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-workflow.png\" alt=\"Spring Cloud Gateway 的工作流程\" tabindex=\"0\"><figcaption>Spring Cloud Gateway 的工作流程</figcaption></figure>\n<p>这是 Spring 官方博客中的一张图，原文地址：<a href=\"https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter\" target=\"_blank\" rel=\"noopener noreferrer\">https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter</a>。</p>\n<p>具体的流程分析：</p>\n<ol>\n<li><strong>路由判断</strong>：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。</li>\n<li><strong>请求过滤</strong>：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。</li>\n<li><strong>服务处理</strong>：后端服务会对请求进行处理。</li>\n<li><strong>响应过滤</strong>：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。</li>\n<li><strong>响应返回</strong>：响应经过过滤处理后，返回给客户端。</li>\n</ol>\n<p>总结：客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。</p>\n<h2>Spring Cloud Gateway 的断言是什么？</h2>\n<p>断言（Predicate）这个词听起来极其深奥，它是一种编程术语，我们生活中根本就不会用它。说白了它就是对一个表达式进行 if 判断，结果为真或假，如果为真则做这件事，否则做那件事。</p>\n<p>在 Gateway 中，如果客户端发送的请求满足了断言的条件，则映射到指定的路由器，就能转发到指定的服务上进行处理。</p>\n<p>断言配置的示例如下，配置了两个路由规则，有一个 predicates 断言配置，当请求 url 中包含 <code>api/thirdparty</code>，就匹配到了第一个路由 <code>route_thirdparty</code>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-example.png\" alt=\"断言配置示例\" tabindex=\"0\"><figcaption>断言配置示例</figcaption></figure>\n<p>常见的路由断言规则如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-rules.png\" alt=\"Spring Cloud GateWay 路由断言规则\" tabindex=\"0\"><figcaption>Spring Cloud GateWay 路由断言规则</figcaption></figure>\n<h2>Spring Cloud Gateway 的路由和断言是什么关系？</h2>\n<p>Route 路由和 Predicate 断言的对应关系如下：：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-route.png\" alt=\"路由和断言的对应关系\" tabindex=\"0\"><figcaption>路由和断言的对应关系</figcaption></figure>\n<ul>\n<li><strong>一对多</strong>：一个路由规则可以包含多个断言。如上图中路由 Route1 配置了三个断言 Predicate。</li>\n<li><strong>同时满足</strong>：如果一个路由规则中有多个断言，则需要同时满足才能匹配。如上图中路由 Route2 配置了两个断言，客户端发送的请求必须同时满足这两个断言，才能匹配路由 Route2。</li>\n<li><strong>第一个匹配成功</strong>：如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由。如上图所示，客户端发送的请求满足 Route3 和 Route4 的断言，但是 Route3 的配置在配置文件中靠前，所以只会匹配 Route3。</li>\n</ul>\n<h2>Spring Cloud Gateway 如何实现动态路由？</h2>\n<p>在使用 Spring Cloud Gateway 的时候，官方文档提供的方案总是基于配置文件或代码配置的方式。</p>\n<p>Spring Cloud Gateway 作为微服务的入口，需要尽量避免重启，而现在配置更改需要重启服务不能满足实际生产过程中的动态刷新、实时变更的业务需求，所以我们需要在 Spring Cloud Gateway 运行时动态配置网关。</p>\n<p>实现动态路由的方式有很多种，其中一种推荐的方式是基于 Nacos 配置中心来做。简单来说，我们将将路由配置放在 Nacos 中存储，然后写个监听器监听 Nacos 上配置的变化，将变化后的配置更新到 GateWay 应用的进程内。</p>\n<p>其实这些复杂的步骤并不需要我们手动实现，通过 Nacos Server 和 Spring Cloud Alibaba Nacos Config 即可实现配置的动态变更，官方文档地址：<a href=\"https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config</a> 。</p>\n<h2>Spring Cloud Gateway 的过滤器有哪些？</h2>\n<p>过滤器 Filter 按照请求和响应可以分为两种：</p>\n<ul>\n<li><strong>Pre 类型</strong>：在请求被转发到微服务之前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。</li>\n<li><strong>Post 类型</strong>：微服务处理完请求后，返回响应给网关，网关可以再次进行处理，例如修改响应内容或响应头、日志输出、流量监控等。</li>\n</ul>\n<p>另外一种分类是按照过滤器 Filter 作用的范围进行划分：</p>\n<ul>\n<li><strong>GatewayFilter</strong>：局部过滤器，应用在单个路由或一组路由上的过滤器。标红色表示比较常用的过滤器。</li>\n<li><strong>GlobalFilter</strong>：全局过滤器，应用在所有路由上的过滤器。</li>\n</ul>\n<h3>局部过滤器</h3>\n<p>常见的局部过滤器如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-gatewayfilters.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>具体怎么用呢？这里有个示例，如果 URL 匹配成功，则去掉 URL 中的 “api”。</p>\n<div class=\"language-yaml\" data-ext=\"yml\" data-title=\"yml\"><pre class=\"language-yaml\"><code><span class=\"token key atrule\">filters</span><span class=\"token punctuation\">:</span> <span class=\"token comment\">#过滤器</span>\n  <span class=\"token punctuation\">-</span> RewritePath=/api/(<span class=\"token punctuation\">?</span>&lt;segment<span class=\"token punctuation\">&gt;</span>.<span class=\"token important\">*)</span><span class=\"token punctuation\">,</span>/$\\<span class=\"token punctuation\">{</span>segment<span class=\"token punctuation\">}</span> <span class=\"token comment\"># 将跳转路径中包含的 “api” 替换成空</span>\n</code></pre></div><p>当然我们也可以自定义过滤器，本篇不做展开。</p>\n<h3>全局过滤器</h3>\n<p>常见的全局过滤器如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-globalfilters.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>全局过滤器最常见的用法是进行负载均衡。配置如下所示：</p>\n<div class=\"language-yaml\" data-ext=\"yml\" data-title=\"yml\"><pre class=\"language-yaml\"><code><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">gateway</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">routes</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> route_member <span class=\"token comment\"># 第三方微服务路由规则</span>\n          <span class=\"token key atrule\">uri</span><span class=\"token punctuation\">:</span> lb<span class=\"token punctuation\">:</span>//passjava<span class=\"token punctuation\">-</span>member <span class=\"token comment\"># 负载均衡，将请求转发到注册中心注册的 passjava-member 服务</span>\n          <span class=\"token key atrule\">predicates</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 断言</span>\n            <span class=\"token punctuation\">-</span> Path=/api/member/<span class=\"token important\">**</span> <span class=\"token comment\"># 如果前端请求路径包含 api/member，则应用这条路由规则</span>\n          <span class=\"token key atrule\">filters</span><span class=\"token punctuation\">:</span> <span class=\"token comment\">#过滤器</span>\n            <span class=\"token punctuation\">-</span> RewritePath=/api/(<span class=\"token punctuation\">?</span>&lt;segment<span class=\"token punctuation\">&gt;</span>.<span class=\"token important\">*)</span><span class=\"token punctuation\">,</span>/$\\<span class=\"token punctuation\">{</span>segment<span class=\"token punctuation\">}</span> <span class=\"token comment\"># 将跳转路径中包含的api替换成空</span>\n</code></pre></div><p>这里有个关键字 <code>lb</code>，用到了全局过滤器 <code>LoadBalancerClientFilter</code>，当匹配到这个路由后，会将请求转发到 passjava-member 服务，且支持负载均衡转发，也就是先将 passjava-member 解析成实际的微服务的 host 和 port，然后再转发给实际的微服务。</p>\n<h2>Spring Cloud Gateway 支持限流吗？</h2>\n<p>Spring Cloud Gateway 自带了限流过滤器，对应的接口是 <code>RateLimiter</code>，<code>RateLimiter</code> 接口只有一个实现类 <code>RedisRateLimiter</code> （基于 Redis + Lua 实现的限流），提供的限流功能比较简易且不易使用。</p>\n<p>从 Sentinel 1.6.0 版本开始，Sentinel 引入了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：route 维度和自定义 API 维度。也就是说，Spring Cloud Gateway 可以结合 Sentinel 实现更强大的网关流量控制。</p>\n<h2>Spring Cloud Gateway 如何自定义全局异常处理？</h2>\n<p>在 SpringBoot 项目中，我们捕获全局异常只需要在项目中配置 <code>@RestControllerAdvice</code>和 <code>@ExceptionHandler</code>就可以了。不过，这种方式在 Spring Cloud Gateway 下不适用。</p>\n<p>Spring Cloud Gateway 提供了多种全局处理的方式，比较常用的一种是实现<code>ErrorWebExceptionHandler</code>并重写其中的<code>handle</code>方法。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token annotation punctuation\">@Order</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token annotation punctuation\">@RequiredArgsConstructor</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GlobalErrorWebExceptionHandler</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ErrorWebExceptionHandler</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ObjectMapper</span> objectMapper<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Mono</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Void</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ServerWebExchange</span> exchange<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Throwable</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><h2>参考</h2>\n<ul>\n<li>Spring Cloud Gateway 官方文档：<a href=\"https://cloud.spring.io/spring-cloud-gateway/reference/html/\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.spring.io/spring-cloud-gateway/reference/html/</a></li>\n<li>Creating a custom Spring Cloud Gateway Filter：<a href=\"https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter\" target=\"_blank\" rel=\"noopener noreferrer\">https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter</a></li>\n<li>全局异常处理: <a href=\"https://zhuanlan.zhihu.com/p/347028665\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/347028665</a></li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-%20demo.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "高可用系统设计指南",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-availability/high-availability-system-design.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-availability/high-availability-system-design.html",
      "summary": "什么是高可用？可用性的判断标准是啥？ 高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。 一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高...",
      "content_html": "<h2>什么是高可用？可用性的判断标准是啥？</h2>\n<p>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</p>\n<p>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</p>\n<p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p>\n<h2>哪些情况会导致系统不可用？</h2>\n<ol>\n<li>黑客攻击；</li>\n<li>硬件故障，比如服务器坏掉。</li>\n<li>并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。</li>\n<li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li>\n<li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li>\n<li>自然灾害或者人为破坏。</li>\n<li>......</li>\n</ol>\n<h2>有哪些提高系统可用性的方法？</h2>\n<h3>注重代码质量，测试严格把关</h3>\n<p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p>\n<p>另外，安利几个对提高代码质量有实际效果的神器：</p>\n<ul>\n<li><a href=\"https://www.sonarqube.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Sonarqube</a>；</li>\n<li>Alibaba 开源的 Java 诊断工具 <a href=\"https://arthas.aliyun.com/doc/\" target=\"_blank\" rel=\"noopener noreferrer\">Arthas</a>；</li>\n<li><a href=\"https://github.com/alibaba/p3c\" target=\"_blank\" rel=\"noopener noreferrer\">阿里巴巴 Java 代码规范</a>（Alibaba Java Code Guidelines）；</li>\n<li>IDEA 自带的代码分析等工具。</li>\n</ul>\n<h3>使用集群，减少单点故障</h3>\n<p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。</p>\n<h3>限流</h3>\n<p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 <a href=\"https://github.com/alibaba/Sentinel\" title=\"Sentinel\" target=\"_blank\" rel=\"noopener noreferrer\">alibaba-Sentinel</a> 的 wiki。</p>\n<h3>超时和重试机制设置</h3>\n<p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法再处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p>\n<h3>熔断机制</h3>\n<p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p>\n<h3>异步调用</h3>\n<p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 <strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p>\n<h3>使用缓存</h3>\n<p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p>\n<h3>其他</h3>\n<ul>\n<li><strong>核心应用和服务优先使用更好的硬件</strong></li>\n<li><strong>监控系统资源使用情况增加报警设置。</strong></li>\n<li><strong>注意备份，必要时候回滚。</strong></li>\n<li><strong>灰度发布：</strong> 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li>\n<li><strong>定期检查/更换硬件：</strong> 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li>\n<li>.....</li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高可用"
      ]
    },
    {
      "title": "服务限流详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-availability/limit-request.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-availability/limit-request.html",
      "summary": "针对软件系统来说，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。 限流可能会导致用户的请求无法被正确处理，不过，这往往也是权衡了软件系统的稳定性之后得到的最优解。 现实生活中，处处都有限流的实际应用，就比如排队买票是为了避免大量用户涌入购票而导致售...",
      "content_html": "<p>针对软件系统来说，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。</p>\n<p>限流可能会导致用户的请求无法被正确处理，不过，这往往也是权衡了软件系统的稳定性之后得到的最优解。</p>\n<p>现实生活中，处处都有限流的实际应用，就比如排队买票是为了避免大量用户涌入购票而导致售票员无法处理。</p>\n<h2>常见限流算法有哪些？</h2>\n<p>简单介绍 4 种非常好理解并且容易实现的限流算法！</p>\n<blockquote>\n<p>图片来源于 InfoQ 的一篇文章<a href=\"https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673\" target=\"_blank\" rel=\"noopener noreferrer\">《分布式服务限流实战，已经为你排好坑了》</a>。</p>\n</blockquote>\n<h3>固定窗口计数器算法</h3>\n<p>固定窗口其实就是时间窗口。<strong>固定窗口计数器算法</strong> 规定了我们单位时间处理的请求数量。</p>\n<p>假如我们规定系统中某个接口 1 分钟只能访问 33 次的话，使用固定窗口计数器算法的实现思路如下：</p>\n<ul>\n<li>给定一个变量 <code>counter</code> 来记录当前接口处理的请求数量，初始值为 0（代表接口当前 1 分钟内还未处理请求）。</li>\n<li>1 分钟之内每处理一个请求之后就将 <code>counter+1</code> ，当 <code>counter=33</code> 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。</li>\n<li>等到 1 分钟结束后，将 <code>counter</code> 重置 0，重新开始计数。</li>\n</ul>\n<p><strong>这种限流算法无法保证限流速率，因而无法保证突然激增的流量。</strong></p>\n<p>就比如说我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。</p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png\" alt=\"固定窗口计数器算法\" tabindex=\"0\"><figcaption>固定窗口计数器算法</figcaption></figure>\n<h3>滑动窗口计数器算法</h3>\n<p><strong>滑动窗口计数器算法</strong> 算的上是固定窗口计数器算法的升级版。</p>\n<p>滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：<strong>它把时间以一定比例分片</strong> 。</p>\n<p>例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理 不大于 <code>60(请求数)/60（窗口数）</code> 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p>\n<p>很显然， <strong>当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</strong></p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/ae/15/ae4d3cd14efb8dc7046d691c90264715.png\" alt=\"滑动窗口计数器算法\" tabindex=\"0\"><figcaption>滑动窗口计数器算法</figcaption></figure>\n<h3>漏桶算法</h3>\n<p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。</p>\n<p>如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。</p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/75/03/75938d1010138ce66e38c6ed0392f103.png\" alt=\"漏桶算法\" tabindex=\"0\"><figcaption>漏桶算法</figcaption></figure>\n<h3>令牌桶算法</h3>\n<p>令牌桶算法也比较简单。和漏桶算法算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。</p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/ec/93/eca0e5eaa35dac938c673fecf2ec9a93.png\" alt=\"令牌桶算法\" tabindex=\"0\"><figcaption>令牌桶算法</figcaption></figure>\n<h2>单机限流怎么做？</h2>\n<p>单机限流针对的是单体架构应用。</p>\n<p>单机限流可以直接使用 Google Guava 自带的限流工具类 <code>RateLimiter</code> 。 <code>RateLimiter</code> 基于令牌桶算法，可以应对突发流量。</p>\n<blockquote>\n<p>Guava 地址：<a href=\"https://github.com/google/guava\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/google/guava</a></p>\n</blockquote>\n<p>除了最基本的令牌桶算法(平滑突发限流)实现之外，Guava 的<code>RateLimiter</code>还提供了 <strong>平滑预热限流</strong> 的算法实现。</p>\n<p>平滑突发限流就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，预热时间之内，速率会逐渐提升到配置的速率。</p>\n<p>我们下面通过两个简单的小例子来详细了解吧！</p>\n<p>我们直接在项目中引入 Guava 相关的依赖即可使用。</p>\n<div class=\"language-xml\" data-ext=\"xml\" data-title=\"xml\"><pre class=\"language-xml\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>com.google.guava<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>guava<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">&gt;</span></span>31.0.1-jre<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre></div><p>下面是一个简单的 Guava 平滑突发限流的 Demo。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>google<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RateLimiter</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token doc-comment comment\">/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * <span class=\"token keyword\">@author</span> Guide哥\n * <span class=\"token keyword\">@date</span> 2021/10/08 19:12\n **/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RateLimiterDemo</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里</span>\n        <span class=\"token class-name\">RateLimiter</span> rateLimiter <span class=\"token operator\">=</span> <span class=\"token class-name\">RateLimiter</span><span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">double</span> sleepingTime <span class=\"token operator\">=</span> rateLimiter<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get 1 tokens: %ss%n\"</span><span class=\"token punctuation\">,</span> sleepingTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre></div><p>输出：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code>get <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.0s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.188413s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.197811s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.198316s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.19864s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.199363s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.193997s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.199623s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.199357s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.195676s\n</code></pre></div><p>下面是一个简单的 Guava 平滑预热限流的 Demo。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>google<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RateLimiter</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">TimeUnit</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token doc-comment comment\">/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * <span class=\"token keyword\">@author</span> Guide哥\n * <span class=\"token keyword\">@date</span> 2021/10/08 19:12\n **/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RateLimiterDemo</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里</span>\n        <span class=\"token comment\">// 预热时间为3s,也就说刚开始的 3s 内发牌速率会逐渐提升到 0.2s 放 1 个令牌到桶里</span>\n        <span class=\"token class-name\">RateLimiter</span> rateLimiter <span class=\"token operator\">=</span> <span class=\"token class-name\">RateLimiter</span><span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">double</span> sleepingTime <span class=\"token operator\">=</span> rateLimiter<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get 1 tokens: %sds%n\"</span><span class=\"token punctuation\">,</span> sleepingTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>输出：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code>get <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.0s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.561919s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.516931s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.463798s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.41286s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.356172s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.300489s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.252545s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.203996s\nget <span class=\"token number\">1</span> tokens: <span class=\"token number\">0</span>.198359s\n</code></pre></div><p>另外，<strong>Bucket4j</strong> 是一个非常不错的基于令牌/漏桶算法的限流库。</p>\n<blockquote>\n<p>Bucket4j 地址：<a href=\"https://github.com/vladimir-bukhtoyarov/bucket4j\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/vladimir-bukhtoyarov/bucket4j</a></p>\n</blockquote>\n<p>相对于，Guava 的限流工具类来说，Bucket4j 提供的限流功能更加全面。不仅支持单机限流和分布式限流，还可以集成监控，搭配 Prometheus 和 Grafana 使用。</p>\n<p>不过，毕竟 Guava 也只是一个功能全面的工具类库，其提供的开箱即用的限流功能在很多单机场景下还是比较实用的。</p>\n<p>Spring Cloud Gateway 中自带的单机限流的早期版本就是基于 Bucket4j 实现的。后来，替换成了 <strong>Resilience4j</strong>。</p>\n<p>Resilience4j 是一个轻量级的容错组件，其灵感来自于 Hystrix。自<a href=\"https://github.com/Netflix/Hystrix/commit/a7df971cbaddd8c5e976b3cc5f14013fe6ad00e6\" target=\"_blank\" rel=\"noopener noreferrer\">Netflix 宣布不再积极开发 Hystrix</a> 之后，Spring 官方和 Netflix 都更推荐使用 Resilience4j 来做限流熔断。</p>\n<blockquote>\n<p>Resilience4j 地址: <a href=\"https://github.com/resilience4j/resilience4j\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/resilience4j/resilience4j</a></p>\n</blockquote>\n<p>一般情况下，为了保证系统的高可用，项目的限流和熔断都是要一起做的。</p>\n<p>Resilience4j 不仅提供限流，还提供了熔断、负载保护、自动重试等保障系统高可用开箱即用的功能。并且，Resilience4j 的生态也更好，很多网关都使用 Resilience4j 来做限流熔断的。</p>\n<p>因此，在绝大部分场景下 Resilience4j 或许会是更好的选择。如果是一些比较简单的限流场景的话，Guava 或者 Bucket4j 也是不错的选择。</p>\n<h2>分布式限流怎么做？</h2>\n<p>分布式限流针对的分布式/微服务应用架构应用，在这种架构下，单机限流就不适用了，因为会存在多种服务，并且一种服务也可能会被部署多份。</p>\n<p>分布式限流常见的方案：</p>\n<ul>\n<li><strong>借助中间件架限流</strong>：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。</li>\n<li><strong>网关层限流</strong>：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件/框架。就比如 Spring Cloud Gateway 的分布式限流实现<code>RedisRateLimiter</code>就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流。</li>\n</ul>\n<p>如果你要基于 Redis 来手动实现限流逻辑的话，建议配合 Lua 脚本来做。</p>\n<p><strong>为什么建议 Redis+Lua 的方式？</strong> 主要有两点原因：</p>\n<ul>\n<li><strong>减少了网络开销</strong>：我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</li>\n<li><strong>原子性</strong>：一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</li>\n</ul>\n<p>我这里就不放具体的限流脚本代码了，网上也有很多现成的优秀的限流脚本供你参考，就比如 Apache 网关项目 ShenYu 的 RateLimiter 限流插件就基于 Redis + Lua 实现了令牌桶算法/并发令牌桶算法、漏桶算法、滑动窗口算法。</p>\n<blockquote>\n<p>ShenYu 地址: <a href=\"https://github.com/apache/incubator-shenyu\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/apache/incubator-shenyu</a></p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/e1e2a75f489e4854990dabe3b6cec522.jpg\" alt=\"ShenYu 限流脚本\" tabindex=\"0\"><figcaption>ShenYu 限流脚本</figcaption></figure>\n<h2>相关阅读</h2>\n<ul>\n<li>服务治理之轻量级熔断框架 Resilience4j：<a href=\"https://xie.infoq.cn/article/14786e571c1a4143ad1ef8f19\" target=\"_blank\" rel=\"noopener noreferrer\">https://xie.infoq.cn/article/14786e571c1a4143ad1ef8f19</a></li>\n<li>超详细的 Guava RateLimiter 限流原理解析：<a href=\"https://cloud.tencent.com/developer/article/1408819\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.tencent.com/developer/article/1408819</a></li>\n<li>实战 Spring Cloud Gateway 之限流篇 👍：<a href=\"https://www.aneasystone.com/archives/2020/08/spring-cloud-gateway-current-limiting.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.aneasystone.com/archives/2020/08/spring-cloud-gateway-current-limiting.html</a></li>\n</ul>\n",
      "image": "https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高可用"
      ]
    },
    {
      "title": "性能测试入门",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-availability/performance-test.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-availability/performance-test.html",
      "summary": "性能测试一般情况下都是由测试这个职位去做的，那还需要我们开发学这个干嘛呢？了解性能测试的指标、分类以及工具等知识有助于我们更好地去写出性能更好的程序，另外作为开发这个角色，如果你会性能测试的话，相信也会为你的履历加分不少。 这篇文章是我会结合自己的实际经历以及在测试这里取的经所得，除此之外，我还借鉴了一些优秀书籍，希望对你有帮助。 一 不同角色看网站性...",
      "content_html": "<p>性能测试一般情况下都是由测试这个职位去做的，那还需要我们开发学这个干嘛呢？了解性能测试的指标、分类以及工具等知识有助于我们更好地去写出性能更好的程序，另外作为开发这个角色，如果你会性能测试的话，相信也会为你的履历加分不少。</p>\n<p>这篇文章是我会结合自己的实际经历以及在测试这里取的经所得，除此之外，我还借鉴了一些优秀书籍，希望对你有帮助。</p>\n<h2>一 不同角色看网站性能</h2>\n<h3>1.1 用户</h3>\n<p>当用户打开一个网站的时候，最关注的是什么？当然是网站响应速度的快慢。比如我们点击了淘宝的主页，淘宝需要多久将首页的内容呈现在我的面前，我点击了提交订单按钮需要多久返回结果等等。</p>\n<p>所以，用户在体验我们系统的时候往往根据你的响应速度的快慢来评判你的网站的性能。</p>\n<h3>1.2 开发人员</h3>\n<p>用户与开发人员都关注速度，这个速度实际上就是我们的系统<strong>处理用户请求的速度</strong>。</p>\n<p>开发人员一般情况下很难直观的去评判自己网站的性能，我们往往会根据网站当前的架构以及基础设施情况给一个大概的值,比如：</p>\n<ol>\n<li>项目架构是分布式的吗？</li>\n<li>用到了缓存和消息队列没有？</li>\n<li>高并发的业务有没有特殊处理？</li>\n<li>数据库设计是否合理？</li>\n<li>系统用到的算法是否还需要优化？</li>\n<li>系统是否存在内存泄露的问题？</li>\n<li>项目使用的 Redis 缓存多大？服务器性能如何？用的是机械硬盘还是固态硬盘？</li>\n<li>......</li>\n</ol>\n<h3>1.3 测试人员</h3>\n<p>测试人员一般会根据性能测试工具来测试，然后一般会做出一个表格。这个表格可能会涵盖下面这些重要的内容：</p>\n<ol>\n<li>响应时间；</li>\n<li>请求成功率；</li>\n<li>吞吐量；</li>\n<li>......</li>\n</ol>\n<h3>1.4 运维人员</h3>\n<p>运维人员会倾向于根据基础设施和资源的利用率来判断网站的性能，比如我们的服务器资源使用是否合理、数据库资源是否存在滥用的情况、当然，这是传统的运维人员，现在 Devops 火起来后，单纯干运维的很少了。我们这里暂且还保留有这个角色。</p>\n<h2>二 性能测试需要注意的点</h2>\n<p>几乎没有文章在讲性能测试的时候提到这个问题，大家都会讲如何去性能测试，有哪些性能测试指标这些东西。</p>\n<h3>2.1 了解系统的业务场景</h3>\n<p><strong>性能测试之前更需要你了解当前的系统的业务场景。</strong> 对系统业务了解的不够深刻，我们很容易犯测试方向偏执的错误，从而导致我们忽略了对系统某些更需要性能测试的地方进行测试。比如我们的系统可以为用户提供发送邮件的功能，用户配置成功邮箱后只需输入相应的邮箱之后就能发送，系统每天大概能处理上万次发邮件的请求。很多人看到这个可能就直接开始使用相关工具测试邮箱发送接口，但是，发送邮件这个场景可能不是当前系统的性能瓶颈，这么多人用我们的系统发邮件， 还可能有很多人一起发邮件，单单这个场景就这么人用，那用户管理可能才是性能瓶颈吧！</p>\n<h3>2.2 历史数据非常有用</h3>\n<p>当前系统所留下的历史数据非常重要，一般情况下，我们可以通过相应的些历史数据初步判定这个系统哪些接口调用的比较多、哪些 service 承受的压力最大，这样的话，我们就可以针对这些地方进行更细致的性能测试与分析。</p>\n<p>另外，这些地方也就像这个系统的一个短板一样，优化好了这些地方会为我们的系统带来质的提升。</p>\n<h3>三 性能测试的指标</h3>\n<h3>3.1 响应时间</h3>\n<p><strong>响应时间就是用户发出请求到用户收到系统处理结果所需要的时间。</strong> 重要吗？实在太重要！</p>\n<p>比较出名的 2-5-8 原则是这样描述的：通常来说，2 到 5 秒，页面体验会比较好，5 到 8 秒还可以接受，8 秒以上基本就很难接受了。另外，据统计当网站慢一秒就会流失十分之一的客户。</p>\n<p>但是，在某些场景下我们也并不需要太看重 2-5-8 原则 ，比如我觉得系统导出导入大数据量这种就不需要，系统生成系统报告这种也不需要。</p>\n<h3>3.2 并发数</h3>\n<p><strong>并发数是系统能同时处理请求的数目即同时提交请求的用户数目。</strong></p>\n<p>不得不说，高并发是现在后端架构中非常非常火热的一个词了，这个与当前的互联网环境以及中国整体的互联网用户量都有很大关系。一般情况下，你的系统并发量越大，说明你的产品做的就越大。但是，并不是每个系统都需要达到像淘宝、12306 这种亿级并发量的。</p>\n<h3>3.3 吞吐量</h3>\n<p>吞吐量指的是系统单位时间内系统处理的请求数量。衡量吞吐量有几个重要的参数：QPS（TPS）、并发数、响应时间。</p>\n<ol>\n<li>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</li>\n<li>TPS（Transaction Per Second）：服务器每秒处理的事务数（这里的一个事务可以理解为客户发出请求到收到服务器的过程）；</li>\n<li>并发数；系统能同时处理请求的数目即同时提交请求的用户数目。</li>\n<li>响应时间：一般取多次请求的平均响应时间</li>\n</ol>\n<p>理清他们的概念，就很容易搞清楚他们之间的关系了。</p>\n<ul>\n<li><strong>QPS（TPS）</strong> = 并发数/平均响应时间</li>\n<li><strong>并发数</strong> = QPS*平均响应时间</li>\n</ul>\n<p>书中是这样描述 QPS 和 TPS 的区别的。</p>\n<blockquote>\n<p>QPS vs TPS：QPS 基本类似于 TPS，但是不同的是，对于一个页面的一次访问，形成一个 TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器 2 次，一次访问，产生一个“T”，产生 2 个“Q”。</p>\n</blockquote>\n<h3>3.4 性能计数器</h3>\n<p><strong>性能计数器是描述服务器或者操作系统的一些数据指标如内存使用、CPU 使用、磁盘与网络 I/O 等情况。</strong></p>\n<h3>四 几种常见的性能测试</h3>\n<h3>性能测试</h3>\n<p>性能测试方法是通过测试工具模拟用户请求系统，目的主要是为了测试系统的性能是否满足要求。通俗地说，这种方法就是要在特定的运行条件下验证系统的能力状态。</p>\n<p>性能测试是你在对系统性能已经有了解的前提之后进行的，并且有明确的性能指标。</p>\n<h3>负载测试</h3>\n<p>对被测试的系统继续加大请求压力，直到服务器的某个资源已经达到饱和了，比如系统的缓存已经不够用了或者系统的响应时间已经不满足要求了。</p>\n<p>负载测试说白点就是测试系统的上限。</p>\n<h3>压力测试</h3>\n<p>不去管系统资源的使用情况，对系统继续加大请求压力，直到服务器崩溃无法再继续提供服务。</p>\n<h3>稳定性测试</h3>\n<p>模拟真实场景，给系统一定压力，看看业务是否能稳定运行。</p>\n<h2>五 常用性能测试工具</h2>\n<p>这里就不多扩展了，有时间的话会单独拎一个熟悉的说一下。</p>\n<h3>5.1 后端常用</h3>\n<p>没记错的话，除了 LoadRunner 其他几款性能测试工具都是开源免费的。</p>\n<ol>\n<li>Jmeter：Apache JMeter 是 JAVA 开发的性能测试工具。</li>\n<li>LoadRunner：一款商业的性能测试工具。</li>\n<li>Galtling：一款基于 Scala 开发的高性能服务器性能测试工具。</li>\n<li>ab：全称为 Apache Bench 。Apache 旗下的一款测试工具，非常实用。</li>\n</ol>\n<h3>5.2 前端常用</h3>\n<ol>\n<li>Fiddler：抓包工具，它可以修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是 Web 调试的利器。</li>\n<li>HttpWatch: 可用于录制 HTTP 请求信息的工具。</li>\n</ol>\n<h2>六 常见的性能优化策略</h2>\n<p>性能优化之前我们需要对请求经历的各个环节进行分析，排查出可能出现性能瓶颈的地方，定位问题。</p>\n<p>下面是一些性能优化时，我经常拿来自问的一些问题：</p>\n<ol>\n<li>系统是否需要缓存？</li>\n<li>系统架构本身是不是就有问题？</li>\n<li>系统是否存在死锁的地方？</li>\n<li>系统是否存在内存泄漏？（Java 的自动回收内存虽然很方便，但是，有时候代码写的不好真的会造成内存泄漏）</li>\n<li>数据库索引使用是否合理？</li>\n<li>......</li>\n</ol>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高可用"
      ]
    },
    {
      "title": "冗余设计详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-availability/redundancy.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-availability/redundancy.html",
      "summary": "冗余设计是保证系统和数据高可用的最常的手段。 对于服务来说，冗余的思想就是相同的服务部署多份，如果正在使用的服务突然挂掉的话，系统可以很快切换到备份服务上，大大减少系统的不可用时间，提高系统的可用性。 对于数据来说，冗余的思想就是相同的数据备份多份，这样就可以很简单地提高数据的安全性。 实际上，日常生活中就有非常多的冗余思想的应用。 拿我自己来说，我对...",
      "content_html": "<p>冗余设计是保证系统和数据高可用的最常的手段。</p>\n<p>对于服务来说，冗余的思想就是相同的服务部署多份，如果正在使用的服务突然挂掉的话，系统可以很快切换到备份服务上，大大减少系统的不可用时间，提高系统的可用性。</p>\n<p>对于数据来说，冗余的思想就是相同的数据备份多份，这样就可以很简单地提高数据的安全性。</p>\n<p>实际上，日常生活中就有非常多的冗余思想的应用。</p>\n<p>拿我自己来说，我对于重要文件的保存方法就是冗余思想的应用。我日常所使用的重要文件都会同步一份在 GitHub 以及个人云盘上，这样就可以保证即使电脑硬盘损坏，我也可以通过 GitHub 或者个人云盘找回自己的重要文件。</p>\n<p>高可用集群（High Availability Cluster，简称 HA Cluster）、同城灾备、异地灾备、同城多活和异地多活是冗余思想在高可用系统设计中最典型的应用。</p>\n<ul>\n<li><strong>高可用集群</strong> : 同一份服务部署两份或者多份，当正在使用的服务突然挂掉的话，可以切换到另外一台服务，从而保证服务的高可用。</li>\n<li><strong>同城灾备</strong>：一整个集群可以部署在同一个机房，而同城灾备中相同服务部署在同一个城市的不同机房中。并且，备用服务不处理请求。这样可以避免机房出现意外情况比如停电、火灾。</li>\n<li><strong>异地灾备</strong>：类似于同城灾备，不同的是，相同服务部署在异地（通常距离较远，甚至是在不同的城市或者国家）的不同机房中</li>\n<li><strong>同城多活</strong>：类似于同城灾备，但备用服务可以处理请求，这样可以充分利用系统资源，提高系统的并发。</li>\n<li><strong>异地多活</strong> : 将服务部署在异地的不同机房中，并且，它们可以同时对外提供服务。</li>\n</ul>\n<p>高可用集群单纯是服务的冗余，并没有强调地域。同城灾备、异地灾备、同城多活和异地多活实现了地域上的冗余。</p>\n<p>同城和异地的主要区别在于机房之间的距离。异地通常距离较远，甚至是在不同的城市或者国家。</p>\n<p>和传统的灾备设计相比，同城多活和异地多活最明显的改变在于“多活”，即所有站点都是同时在对外提供服务的。异地多活是为了应对突发状况比如火灾、地震等自然或者人为灾害。</p>\n<p>光做好冗余还不够，必须要配合上 <strong>故障转移</strong> 才可以！ 所谓故障转移，简单来说就是实现不可用服务快速且自动地切换到可用服务，整个过程不需要人为干涉。</p>\n<p>举个例子：哨兵模式的 Redis 集群中，如果 Sentinel（哨兵） 检测到 master 节点出现故障的话， 它就会帮助我们实现故障转移，自动将某一台 slave 升级为 master，确保整个 Redis 系统的可用性。整个过程完全自动，不需要人工介入。我在<a href=\"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>的「技术面试题篇」中的数据库部分详细介绍了 Redis 集群相关的知识点&amp;面试题，感兴趣的小伙伴可以看看。</p>\n<p>再举个例子：Nginx 可以结合 Keepalived 来实现高可用。如果 Nginx 主服务器宕机的话，Keepalived 可以自动进行故障转移，备用 Nginx 主服务器升级为主服务。并且，这个切换对外是透明的，因为使用的虚拟 IP，虚拟 IP 不会改变。我在<a href=\"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>的「技术面试题篇」中的「服务器」部分详细介绍了 Nginx 相关的知识点&amp;面试题，感兴趣的小伙伴可以看看。</p>\n<p>异地多活架构实施起来非常难，需要考虑的因素非常多。本人不才，实际项目中并没有实践过异地多活架构，我对其了解还停留在书本知识。</p>\n<p>如果你想要深入学习异地多活相关的知识，我这里推荐几篇我觉得还不错的文章：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/T6mMDdtTfBuIiEowCpqu6Q\" target=\"_blank\" rel=\"noopener noreferrer\">搞懂异地多活，看这篇就够了- 水滴与银弹 - 2021</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/hMD-IS__4JE5_nQhYPYSTg\" target=\"_blank\" rel=\"noopener noreferrer\">四步构建异地多活</a></li>\n<li><a href=\"http://gk.link/a/10pKZ\" target=\"_blank\" rel=\"noopener noreferrer\">《从零开始学架构》— 28 | 业务高可用的保障：异地多活架构</a></li>\n</ul>\n<p>不过，这些文章大多也都是在介绍概念知识。目前，网上还缺少真正介绍具体要如何去实践落地异地多活架构的资料。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高可用"
      ]
    },
    {
      "title": "超时&重试详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-availability/timeout-and-retry.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-availability/timeout-and-retry.html",
      "summary": "由于网络问题、系统或者服务内部的 Bug、服务器宕机、操作系统崩溃等问题的不确定性，我们的系统或者服务永远不可能保证时刻都是可用的状态。 为了最大限度的减小系统或者服务出现故障之后带来的影响，我们需要用到的 超时（Timeout） 和 重试（Retry） 机制。 想要把超时和重试机制讲清楚其实很简单，因为它俩本身就不是什么高深的概念。 虽然超时和重试机...",
      "content_html": "<p>由于网络问题、系统或者服务内部的 Bug、服务器宕机、操作系统崩溃等问题的不确定性，我们的系统或者服务永远不可能保证时刻都是可用的状态。</p>\n<p>为了最大限度的减小系统或者服务出现故障之后带来的影响，我们需要用到的 <strong>超时（Timeout）</strong> 和 <strong>重试（Retry）</strong> 机制。</p>\n<p>想要把超时和重试机制讲清楚其实很简单，因为它俩本身就不是什么高深的概念。</p>\n<p>虽然超时和重试机制的思想很简单，但是它俩是真的非常实用。你平时接触到的绝大部分涉及到远程调用的系统或者服务都会应用超时和重试机制。尤其是对于微服务系统来说，正确设置超时和重试非常重要。单体服务通常只涉及数据库、缓存、第三方 API、中间件等的网络调用，而微服务系统内部各个服务之间还存在着网络调用。</p>\n<h2>超时机制</h2>\n<h3>什么是超时机制？</h3>\n<p>超时机制说的是当一个请求超过指定的时间（比如 1s）还没有被处理的话，这个请求就会直接被取消并抛出指定的异常或者错误（比如 <code>504 Gateway Timeout</code>）。</p>\n<p>我们平时接触到的超时可以简单分为下面 2 种：</p>\n<ul>\n<li><strong>连接超时（ConnectTimeout）</strong>：客户端与服务端建立连接的最长等待时间。</li>\n<li><strong>读取超时（ReadTimeout）</strong>：客户端和服务端已经建立连接，客户端等待服务端处理完请求的最长时间。实际项目中，我们关注比较多的还是读取超时。</li>\n</ul>\n<p>一些连接池客户端框架中可能还会有获取连接超时和空闲连接清理超时。</p>\n<p>如果没有设置超时的话，就可能会导致服务端连接数爆炸和大量请求堆积的问题。</p>\n<p>这些堆积的连接和请求会消耗系统资源，影响新收到的请求的处理。严重的情况下，甚至会拖垮整个系统或者服务。</p>\n<p>我之前在实际项目就遇到过类似的问题，整个网站无法正常处理请求，服务器负载直接快被拉满。后面发现原因是项目超时设置错误加上客户端请求处理异常，导致服务端连接数直接接近 40w+，这么多堆积的连接直接把系统干趴了。</p>\n<h3>超时时间应该如何设置？</h3>\n<p>超时到底设置多长时间是一个难题！超时值设置太高或者太低都有风险。如果设置太高的话，会降低超时机制的有效性，比如你设置超时为 10s 的话，那设置超时就没啥意义了，系统依然可能会出现大量慢请求堆积的问题。如果设置太低的话，就可能会导致在系统或者服务在某些处理请求速度变慢的情况下（比如请求突然增多），大量请求重试（超时通常会结合重试）继续加重系统或者服务的压力，进而导致整个系统或者服务被拖垮的问题。</p>\n<p>通常情况下，我们建议读取超时设置为 <strong>1500ms</strong> ,这是一个比较普适的值。如果你的系统或者服务对于延迟比较敏感的话，那读取超时值可以适当在 <strong>1500ms</strong> 的基础上进行缩短。反之，读取超时值也可以在 <strong>1500ms</strong> 的基础上进行加长，不过，尽量还是不要超过 <strong>1500ms</strong> 。连接超时可以适当设置长一些，建议在 <strong>1000ms ~ 5000ms</strong> 之内。</p>\n<p>没有银弹！超时值具体该设置多大，还是要根据实际项目的需求和情况慢慢调整优化得到。</p>\n<p>更上一层，参考<a href=\"https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html\" target=\"_blank\" rel=\"noopener noreferrer\">美团的 Java 线程池参数动态配置</a>思想，我们也可以将超时弄成可配置化的参数而不是固定的，比较简单的一种办法就是将超时的值放在配置中心中。这样的话，我们就可以根据系统或者服务的状态动态调整超时值了。</p>\n<h2>重试机制</h2>\n<h3>什么是重试机制？</h3>\n<p>重试机制一般配合超时机制一起使用，指的是多次发送相同的请求来避免瞬态故障和偶然性故障。</p>\n<p>瞬态故障可以简单理解为某一瞬间系统偶然出现的故障，并不会持久。偶然性故障可以理解为哪些在某些情况下偶尔出现的故障，频率通常较低。</p>\n<p>重试的核心思想是通过消耗服务器的资源来尽可能获得请求更大概率被成功处理。由于瞬态故障和偶然性故障是很少发生的，因此，重试对于服务器的资源消耗几乎是可以被忽略的。</p>\n<h3>重试的次数如何设置？</h3>\n<p>重试的次数不宜过多，否则依然会对系统负载造成比较大的压力。</p>\n<p>重试的次数通常建议设为 3 次。并且，我们通常还会设置重试的间隔，比如说我们要重试 3 次的话，第 1 次请求失败后，等待 1 秒再进行重试，第 2 次请求失败后，等待 2 秒再进行重试，第 3 次请求失败后，等待 3 秒再进行重试。</p>\n<h3>重试幂等</h3>\n<p>超时和重试机制在实际项目中使用的话，需要注意保证同一个请求没有被多次执行。</p>\n<p>什么情况下会出现一个请求被多次执行呢？客户端等待服务端完成请求完成超时但此时服务端已经执行了请求，只是由于短暂的网络波动导致响应在发送给客户端的过程中延迟了。</p>\n<p>举个例子：用户支付购买某个课程，结果用户支付的请求由于重试的问题导致用户购买同一门课程支付了两次。对于这种情况，我们在执行用户购买课程的请求的时候需要判断一下用户是否已经购买过。这样的话，就不会因为重试的问题导致重复购买了。</p>\n<h2>参考</h2>\n<ul>\n<li>微服务之间调用超时的设置治理：<a href=\"https://www.infoq.cn/article/eyrslar53l6hjm5yjgyx\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.infoq.cn/article/eyrslar53l6hjm5yjgyx</a></li>\n<li>超时、重试和抖动回退：<a href=\"https://aws.amazon.com/cn/builders-library/timeouts-retries-and-backoff-with-jitter/\" target=\"_blank\" rel=\"noopener noreferrer\">https://aws.amazon.com/cn/builders-library/timeouts-retries-and-backoff-with-jitter/</a></li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高可用"
      ]
    },
    {
      "title": "CDN常见问题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/cdn.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/cdn.html",
      "summary": "什么是 CDN ？ CDN 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 内容分发网络 。 我们可以将内容分发网络拆开来看： 内容：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。 分发网络：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上...",
      "content_html": "<h2>什么是 CDN ？</h2>\n<p><strong>CDN</strong> 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 <strong>内容分发网络</strong> 。</p>\n<p>我们可以将内容分发网络拆开来看：</p>\n<ul>\n<li>内容：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。</li>\n<li>分发网络：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。</li>\n</ul>\n<p>所以，简单来说，<strong>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。</strong></p>\n<p>类似于京东建立的庞大的仓储运输体系，京东物流在全国拥有非常多的仓库，仓储网络几乎覆盖全国所有区县。这样的话，用户下单的第一时间，商品就从距离用户最近的仓库，直接发往对应的配送站，再由京东小哥送到你家。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/jingdong-wuliu-cangpei.png\" alt=\"京东仓配系统\" tabindex=\"0\"><figcaption>京东仓配系统</figcaption></figure>\n<p>你可以将 CDN 看作是服务上一层的特殊缓存服务，分布在全国各地，主要用来处理静态资源的请求。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-101.png\" alt=\"CDN 简易示意图\" tabindex=\"0\"><figcaption>CDN 简易示意图</figcaption></figure>\n<p>我们经常拿全站加速和内容分发网络做对比，不要把两者搞混了！全站加速（不同云服务商叫法不同，腾讯云叫 ECDN、阿里云叫 DCDN）既可以加速静态资源又可以加速动态资源，内容分发网络（CDN）主要针对的是 <strong>静态资源</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-aliyun-dcdn.png\" alt=\"阿里云文档：https://help.aliyun.com/document_detail/64836.html\" tabindex=\"0\"><figcaption>阿里云文档：https://help.aliyun.com/document_detail/64836.html</figcaption></figure>\n<p>绝大部分公司都会在项目开发中交使用 CDN 服务，但很少会有自建 CDN 服务的公司。基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。</p>\n<p>很多朋友可能要问了：<strong>既然是就近访问，为什么不直接将服务部署在多个不同的地方呢？</strong></p>\n<ul>\n<li>成本太高，需要部署多份相同的服务。</li>\n<li>静态资源通常占用空间比较大且经常会被访问到，如果直接使用服务器或者缓存来处理静态资源请求的话，对系统资源消耗非常大，可能会影响到系统其他服务的正常运行。</li>\n</ul>\n<p>同一个服务在在多个不同的地方部署多份（比如同城灾备、异地灾备、同城多活、异地多活）是为了实现系统的高可用而不是就近访问。</p>\n<h2>CDN 工作原理是什么？</h2>\n<p>搞懂下面 3 个问题也就搞懂了 CDN 的工作原理：</p>\n<ol>\n<li>静态资源是如何被缓存到 CDN 节点中的？</li>\n<li>如何找到最合适的 CDN 节点？</li>\n<li>如何防止静态资源被盗用？</li>\n</ol>\n<h3>静态资源是如何被缓存到 CDN 节点中的？</h3>\n<p>你可以通过 <strong>预热</strong> 的方式将源站的资源同步到 CDN 的节点中。这样的话，用户首次请求资源可以直接从 CDN 节点中取，无需回源。这样可以降低源站压力，提升用户体验。</p>\n<p>如果不预热的话，你访问的资源可能不在 CDN 节点中，这个时候 CDN 节点将请求源站获取资源，这个过程是大家经常说的 <strong>回源</strong>。</p>\n<blockquote>\n<ul>\n<li>回源：当 CDN 节点上没有用户请求的资源或该资源的缓存已经过期时，CDN 节点需要从原始服务器获取最新的资源内容，这个过程就是回源。当用户请求发生回源的话，会导致该请求的响应速度比未使用 CDN 还慢，因为相比于未使用 CDN 还多了一层 CDN 的调用流程。</li>\n<li>预热：预热是指在 CDN 上提前将内容缓存到 CDN 节点上。这样当用户在请求这些资源时，能够快速地从最近的 CDN 节点获取到而不需要回源，进而减少了对源站的访问压力，提高了访问速度。</li>\n</ul>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-back-to-source.png\" alt=\"CDN 回源\" tabindex=\"0\"><figcaption>CDN 回源</figcaption></figure>\n<p>如果资源有更新的话，你也可以对其 <strong>刷新</strong> ，删除 CDN 节点上缓存的旧资源，并强制 CDN 节点回源站获取最新资源。</p>\n<p>几乎所有云厂商提供的 CDN 服务都具备缓存的刷新和预热功能（下图是阿里云 CDN 服务提供的相应功能）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-refresh-warm-up.png\" alt=\"CDN 缓存的刷新和预热\" tabindex=\"0\"><figcaption>CDN 缓存的刷新和预热</figcaption></figure>\n<p><strong>命中率</strong> 和 <strong>回源率</strong> 是衡量 CDN 服务质量两个重要指标。命中率越高越好，回源率越低越好。</p>\n<h3>如何找到最合适的 CDN 节点？</h3>\n<p>GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB。</p>\n<p>CDN 会通过 GSLB 找到最合适的 CDN 节点，更具体点来说是下面这样的：</p>\n<ol>\n<li>浏览器向 DNS 服务器发送域名请求；</li>\n<li>DNS 服务器向根据 CNAME( Canonical Name ) 别名记录向 GSLB 发送请求；</li>\n<li>GSLB 返回性能最好（通常距离请求地址最近）的 CDN 节点（边缘服务器，真正缓存内容的地方）的地址给浏览器；</li>\n<li>浏览器直接访问指定的 CDN 节点。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-overview.png\" alt=\"CDN 原理示意图\" tabindex=\"0\"><figcaption>CDN 原理示意图</figcaption></figure>\n<p>为了方便理解，上图其实做了一点简化。GSLB 内部可以看作是 CDN 专用 DNS 服务器和负载均衡系统组合。CDN 专用 DNS 服务器会返回负载均衡系统 IP 地址给浏览器，浏览器使用 IP 地址请求负载均衡系统进而找到对应的 CDN 节点。</p>\n<p><strong>GSLB 是如何选择出最合适的 CDN 节点呢？</strong> GSLB 会根据请求的 IP 地址、CDN 节点状态（比如负载情况、性能、响应时间、带宽）等指标来综合判断具体返回哪一个 CDN 节点的地址。</p>\n<h3>如何防止资源被盗刷？</h3>\n<p>如果我们的资源被其他用户或者网站非法盗刷的话，将会是一笔不小的开支。</p>\n<p>解决这个问题最常用最简单的办法设置 <strong>Referer 防盗链</strong>，具体来说就是根据 HTTP 请求的头信息里面的 Referer 字段对请求进行限制。我们可以通过 Referer 字段获取到当前请求页面的来源页面的网站地址，这样我们就能确定请求是否来自合法的网站。</p>\n<p>CDN 服务提供商几乎都提供了这种比较基础的防盗链机制。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cnd-tencent-cloud-anti-theft.png\" alt=\"腾讯云 CDN Referer 防盗链配置\" tabindex=\"0\"><figcaption>腾讯云 CDN Referer 防盗链配置</figcaption></figure>\n<p>不过，如果站点的防盗链配置允许 Referer 为空的话，通过隐藏 Referer，可以直接绕开防盗链。</p>\n<p>通常情况下，我们会配合其他机制来确保静态资源被盗用，一种常用的机制是 <strong>时间戳防盗链</strong> 。相比之下，<strong>时间戳防盗链</strong> 的安全性更强一些。时间戳防盗链加密的 URL 具有时效性，过期之后就无法再被允许访问。</p>\n<p>时间戳防盗链的 URL 通常会有两个参数一个是签名字符串，一个是过期时间。签名字符串一般是通过对用户设定的加密字符串、请求路径、过期时间通过 MD5 哈希算法取哈希的方式获得。</p>\n<p>时间戳防盗链 URL 示例：</p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>http://cdn.wangsu.com/4/123.mp3? wsSecret=79aead3bd7b5db4adeffb93a010298b5&amp;wsTime=1601026312\n</code></pre></div><ul>\n<li><code>wsSecret</code>：签名字符串。</li>\n<li><code>wsTime</code>: 过期时间。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/timestamp-anti-theft.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>时间戳防盗链的实现也比较简单，并且可靠性较高，推荐使用。并且，绝大部分 CDN 服务提供商都提供了开箱即用的时间戳防盗链机制。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/qiniuyun-timestamp-anti-theft.png\" alt=\"七牛云时间戳防盗链配置\" tabindex=\"0\"><figcaption>七牛云时间戳防盗链配置</figcaption></figure>\n<p>除了 Referer 防盗链和时间戳防盗链之外，你还可以 IP 黑白名单配置、IP 访问限频配置等机制来防盗刷。</p>\n<h2>总结</h2>\n<ul>\n<li>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。</li>\n<li>基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。</li>\n<li>GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB。CDN 会通过 GSLB 找到最合适的 CDN 节点。</li>\n<li>为了防止静态资源被盗用，我们可以利用 <strong>Referer 防盗链</strong> + <strong>时间戳防盗链</strong> 。</li>\n</ul>\n<h2>参考</h2>\n<ul>\n<li>时间戳防盗链 - 七牛云 CDN：<a href=\"https://developer.qiniu.com/fusion/kb/1670/timestamp-hotlinking-prevention\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.qiniu.com/fusion/kb/1670/timestamp-hotlinking-prevention</a></li>\n<li>CDN 是个啥玩意？一文说个明白：<a href=\"https://mp.weixin.qq.com/s/Pp0C8ALUXsmYCUkM5QnkQw\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/Pp0C8ALUXsmYCUkM5QnkQw</a></li>\n<li>《透视 HTTP 协议》- 37 | CDN：加速我们的网络服务：<a href=\"http://gk.link/a/11yOG\" target=\"_blank\" rel=\"noopener noreferrer\">http://gk.link/a/11yOG</a></li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-performance/cdn/jingdong-wuliu-cangpei.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "负载均衡常见问题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/load-balancing.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/load-balancing.html",
      "summary": "什么是负载均衡？ 负载均衡 指的是将用户请求分摊到不同的服务器上处理，以提高系统整体的并发处理能力以及可靠性。负载均衡服务可以有由专门的软件或者硬件来完成，一般情况下，硬件的性能更好，软件的价格更便宜（后文会详细介绍到）。 下图是《Java 面试指北》 「高并发篇」中的一篇文章的配图，从图中可以看出，系统的商品服务部署了多份在不同的服务器上，为了实现访...",
      "content_html": "<h2>什么是负载均衡？</h2>\n<p><strong>负载均衡</strong> 指的是将用户请求分摊到不同的服务器上处理，以提高系统整体的并发处理能力以及可靠性。负载均衡服务可以有由专门的软件或者硬件来完成，一般情况下，硬件的性能更好，软件的价格更便宜（后文会详细介绍到）。</p>\n<p>下图是<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247519384&amp;idx=1&amp;sn=bc7e71af75350b755f04ca4178395b1a&amp;chksm=cea1c353f9d64a458f797696d4144b4d6e58639371a4612b8e4d106d83a66d2289e7b2cd7431&amp;token=660789642&amp;lang=zh_CN&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a> 「高并发篇」中的一篇文章的配图，从图中可以看出，系统的商品服务部署了多份在不同的服务器上，为了实现访问商品服务请求的分流，我们用到了负载均衡。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/load-balancing/multi-service-load-balancing.drawio.png\" alt=\"多服务实例-负载均衡\" tabindex=\"0\"><figcaption>多服务实例-负载均衡</figcaption></figure>\n<p>负载均衡是一种比较常用且实施起来较为简单的提高系统并发能力和可靠性的手段，不论是单体架构的系统还是微服务架构的系统几乎都会用到。</p>\n<h2>负载均衡分为哪几种？</h2>\n<p>负载均衡可以简单分为 <strong>服务端负载均衡</strong> 和 <strong>客户端负载均衡</strong> 这两种。</p>\n<p>服务端负载均衡涉及到的知识点更多，工作中遇到的也比较多，因为，我会花更多时间来介绍。</p>\n<h3>服务端负载均衡</h3>\n<p><strong>服务端负载均衡</strong> 主要应用在 <strong>系统外部请求</strong> 和 <strong>网关层</strong> 之间，可以使用 <strong>软件</strong> 或者 <strong>硬件</strong> 实现。</p>\n<p>下图是我画的一个简单的基于 Nginx 的服务端负载均衡示意图：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/load-balancing/server-load-balancing.png\" alt=\"基于 Nginx 的服务端负载均衡\" tabindex=\"0\"><figcaption>基于 Nginx 的服务端负载均衡</figcaption></figure>\n<p><strong>硬件负载均衡</strong> 通过专门的硬件设备（比如 <strong>F5、A10、Array</strong> ）实现负载均衡功能。</p>\n<p>硬件负载均衡的优势是性能很强且稳定，缺点就是实在是太贵了。像基础款的 F5 最低也要 20 多万，绝大部分公司是根本负担不起的，业务量不大的话，真没必要非要去弄个硬件来做负载均衡，用软件负载均衡就足够了！</p>\n<p>在我们日常开发中，一般很难接触到硬件负载均衡，接触的比较多的还是 <strong>软件负载均衡</strong> 。软件负载均衡通过软件（比如 <strong>LVS、Nginx、HAproxy</strong> ）实现负载均衡功能，性能虽然差一些，但价格便宜啊！像基础款的 Linux 服务器也就几千，性能好一点的 2~3 万的就很不错了。</p>\n<p>根据 OSI 模型，服务端负载均衡还可以分为：</p>\n<ul>\n<li>二层负载均衡</li>\n<li>三层负载均衡</li>\n<li>四层负载均衡</li>\n<li>七层负载均衡</li>\n</ul>\n<p>最常见的是四层和七层负载均衡，因此，本文也是重点介绍这两种负载均衡。</p>\n<blockquote>\n<p>Nginx 官网对四层负载和七层负载均衡均衡做了详细介绍，感兴趣的可以看看。</p>\n<ul>\n<li><a href=\"https://www.nginx.com/resources/glossary/layer-4-load-balancing/\" target=\"_blank\" rel=\"noopener noreferrer\">What Is Layer 4 Load Balancing?</a></li>\n<li><a href=\"https://www.nginx.com/resources/glossary/layer-7-load-balancing/\" target=\"_blank\" rel=\"noopener noreferrer\">What Is Layer 7 Load Balancing?</a></li>\n</ul>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png\" alt=\"OSI 七层模型\" tabindex=\"0\"><figcaption>OSI 七层模型</figcaption></figure>\n<ul>\n<li><strong>四层负载均衡</strong> 工作在 OSI 模型第四层，也就是传输层，这一层的主要协议是 TCP/UDP，负载均衡器在这一层能够看到数据包里的源端口地址以及目的端口地址，会基于这些信息通过一定的负载均衡算法将数据包转发到后端真实服务器。也就是说，四层负载均衡的核心就是 IP+端口层面的负载均衡，不涉及具体的报文内容。</li>\n<li><strong>七层负载均衡</strong> 工作在 OSI 模型第七层，也就是应用层，这一层的主要协议是 HTTP 。这一层的负载均衡比四层负载均衡路由网络请求的方式更加复杂，它会读取报文的数据部分（比如说我们的 HTTP 部分的报文），然后根据读取到的数据内容（如 URL、Cookie）做出负载均衡决策。也就是说，七层负载均衡器的核心是报文内容（如 URL、Cookie）层面的负载均衡，执行第七层负载均衡的设备通常被称为 <strong>反向代理服务器</strong> 。</li>\n</ul>\n<p>七层负载均衡比四层负载均衡会消耗更多的性能，不过，也相对更加灵活，能够更加智能地路由网络请求，比如说你可以根据请求的内容进行优化如缓存、压缩、加密。</p>\n<p>简单来说，<strong>四层负载均衡性能更强，七层负载均衡功能更强！</strong> 不过，对于绝大部分业务场景来说，四层负载均衡和七层负载均衡的性能差异基本可以忽略不计的。</p>\n<p>下面这段话摘自 Nginx 官网的 <a href=\"https://www.nginx.com/resources/glossary/layer-4-load-balancing/\" target=\"_blank\" rel=\"noopener noreferrer\">What Is Layer 4 Load Balancing?</a> 这篇文章。</p>\n<blockquote>\n<p>Layer 4 load balancing was a popular architectural approach to traffic handling when commodity hardware was not as powerful as it is now, and the interaction between clients and application servers was much less complex. It requires less computation than more sophisticated load balancing methods (such as Layer 7), but CPU and memory are now sufficiently fast and cheap that the performance advantage for Layer 4 load balancing has become negligible or irrelevant in most situations.</p>\n<p>第 4 层负载平衡是一种流行的流量处理体系结构方法，当时商用硬件没有现在这么强大，客户端和应用程序服务器之间的交互也不那么复杂。它比更复杂的负载平衡方法(如第 7 层)需要更少的计算量，但是 CPU 和内存现在足够快和便宜，在大多数情况下，第 4 层负载平衡的性能优势已经变得微不足道或无关紧要。</p>\n</blockquote>\n<p>在工作中，我们通常会使用 <strong>Nginx</strong> 来做七层负载均衡，LVS(Linux Virtual Server 虚拟服务器， Linux 内核的 4 层负载均衡)来做四层负载均衡。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/image-20220328105759300.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>不过，LVS 这个绝大部分公司真用不上，像阿里、百度、腾讯、eBay 等大厂才会使用到，用的最多的还是 Nginx。</p>\n<h3>客户端负载均衡</h3>\n<p><strong>客户端负载均衡</strong> 主要应用于系统内部的不同的服务之间，可以使用现成的负载均衡组件来实现。</p>\n<p>在客户端负载均衡中，客户端会自己维护一份服务器的地址列表，发送请求之前，客户端会根据对应的负载均衡算法来选择具体某一台服务器处理请求。</p>\n<p>客户端负载均衡器和服务运行在同一个进程或者说 Java 程序里，不存在额外的网络开销。不过，客户端负载均衡的实现会受到编程语言的限制，比如说 Spring Cloud Load Balancer 就只能用于 Java 语言。</p>\n<p>Java 领域主流的微服务框架 Dubbo、Spring Cloud 等都内置了开箱即用的客户端负载均衡实现。Dubbo 属于是默认自带了负载均衡功能，Spring Cloud 是通过组件的形式实现的负载均衡，属于可选项，比较常用的是 Spring Cloud Load Balancer（官方，推荐） 和 Ribbon（Netflix，已被启用）。</p>\n<p>下图是我画的一个简单的基于 Spring Cloud Load Balancer（Ribbon 也类似） 的客户端负载均衡示意图：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/load-balancing/spring-cloud-lb-gateway.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>负载均衡常见的算法有哪些？</h2>\n<h3>随机法</h3>\n<p><strong>随机法</strong> 是最简单粗暴的负载均衡算法。</p>\n<p>如果没有配置权重的话，所有的服务器被访问到的概率都是相同的。如果配置权重的话，权重越高的服务器被访问的概率就越大。</p>\n<p>未加权重的随机算法适合于服务器性能相近的集群，其中每个服务器承载相同的负载。加权随机算法适合于服务器性能不等的集群，权重的存在可以使请求分配更加合理化。</p>\n<p>不过，随机算法有一个比较明显的缺陷：部分机器在一段时间之内无法被随机到，毕竟是概率算法，就算是大家权重一样， 也可能会出现这种情况。</p>\n<p>于是，<strong>轮询法</strong> 来了！</p>\n<h3>轮询法</h3>\n<p>轮询法是挨个轮询服务器处理，也可以设置权重。</p>\n<p>如果没有配置权重的话，每个请求按时间顺序逐一分配到不同的服务器处理。如果配置权重的话，权重越高的服务器被访问的次数就越多。</p>\n<p>未加权重的轮询算法适合于服务器性能相近的集群，其中每个服务器承载相同的负载。加权轮询算法适合于服务器性能不等的集群，权重的存在可以使请求分配更加合理化。</p>\n<h3>一致性 Hash 法</h3>\n<p>相同参数的请求总是发到同一台服务器处理，比如同个 IP 的请求。</p>\n<h3>最小连接法</h3>\n<p>当有新的请求出现时，遍历服务器节点列表并选取其中活动连接数最小的一台服务器来响应当前请求。活动连接数可以理解为当前正在处理的请求数。</p>\n<p>最小连接法可以尽可能最大地使请求分配更加合理化，提高服务器的利用率。不过，这种方法实现起来也最复杂，需要监控每一台服务器处理的请求连接数。</p>\n<h2>七层负载均衡可以怎么做？</h2>\n<p>简单介绍两种项目中常用的七层负载均衡解决方案：DNS 解析和反向代理。</p>\n<p>除了我介绍的这两种解决方案之外，HTTP 重定向等手段也可以用来实现负载均衡，不过，相对来说，还是 DNS 解析和反向代理用的更多一些，也更推荐一些。</p>\n<h3>DNS 解析</h3>\n<p>DNS 解析是比较早期的七层负载均衡实现方式，非常简单。</p>\n<p>DNS 解析实现负载均衡的原理是这样的：在 DNS 服务器中为同一个主机记录配置多个 IP 地址，这些 IP 地址对应不同的服务器。当用户请求域名的时候，DNS 服务器采用轮询算法返回 IP 地址，这样就实现了轮询版负载均衡。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/load-balancing/6997605302452f07e8b28d257d349bf0.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>现在的 DNS 解析几乎都支持 IP 地址的权重配置，这样的话，在服务器性能不等的集群中请求分配会更加合理化。像我自己目前正在用的阿里云 DNS 就支持权重配置。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/aliyun-dns-weight-setting.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>反向代理</h3>\n<p>客户端将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器，获取数据后再返回给客户端。对外暴露的是反向代理服务器地址，隐藏了真实服务器 IP 地址。反向代理“代理”的是目标服务器，这一个过程对于客户端而言是透明的。</p>\n<p>Nginx 就是最常用的反向代理服务器，它可以将接收到的客户端请求以一定的规则（负载均衡策略）均匀地分配到这个服务器集群中所有的服务器上。</p>\n<p>反向代理负载均衡同样属于七层负载均衡。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/nginx-load-balance.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>客户端负载均衡通常是怎么做的？</h2>\n<p>我们上面也说了，客户端负载均衡可以使用现成的负载均衡组件来实现。</p>\n<p><strong>Netflix Ribbon</strong> 和 <strong>Spring Cloud Load Balancer</strong> 就是目前 Java 生态最流行的两个负载均衡组件。</p>\n<p>Ribbon 是老牌负载均衡组件，由 Netflix 开发，功能比较全面，支持的负载均衡策略也比较多。 Spring Cloud Load Balancer 是 Spring 官方为了取代 Ribbon 而推出的，功能相对更简单一些，支持的负载均衡也少一些。</p>\n<p>Ribbon 支持的 7 种负载均衡策略：</p>\n<ul>\n<li><code>RandomRule</code>：随机策略。</li>\n<li><code>RoundRobinRule</code>（默认）：轮询策略</li>\n<li><code>WeightedResponseTimeRule</code>：权重（根据响应时间决定权重）策略</li>\n<li><code>BestAvailableRule</code>：最小连接数策略</li>\n<li><code>RetryRule</code>：重试策略（按照轮询策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试来获取服务，如果超过指定时间依然没获取到服务实例则返回 null）</li>\n<li><code>AvailabilityFilteringRule</code>：可用敏感性策略（先过滤掉非健康的服务实例，然后再选择连接数较小的服务实例）</li>\n<li><code>ZoneAvoidanceRule</code>：区域敏感性策略（根据服务所在区域的性能和服务的可用性来选择服务实例）</li>\n</ul>\n<p>Spring Cloud Load Balancer 支持的 2 种负载均衡策略：</p>\n<ul>\n<li><code>RandomLoadBalancer</code>：随机策略</li>\n<li><code>RoundRobinLoadBalancer</code>（默认）：轮询策略</li>\n</ul>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomLoadBalancerConfiguration</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token class-name\">ReactorLoadBalancer</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ServiceInstance</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">randomLoadBalancer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Environment</span> environment<span class=\"token punctuation\">,</span>\n            <span class=\"token class-name\">LoadBalancerClientFactory</span> loadBalancerClientFactory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> environment<span class=\"token punctuation\">.</span><span class=\"token function\">getProperty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">LoadBalancerClientFactory</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PROPERTY_NAME</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RandomLoadBalancer</span><span class=\"token punctuation\">(</span>loadBalancerClientFactory\n                <span class=\"token punctuation\">.</span><span class=\"token function\">getLazyProvider</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ServiceInstanceListSupplier</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>不过，Spring Cloud Load Balancer 支持的负载均衡策略其实不止这两种，<code>ServiceInstanceListSupplier</code> 的实现类同样可以让其支持类似于 Ribbon 的负载均衡策略。这个应该是后续慢慢完善引入的，不看官方文档还真发现不了，所以说阅读官方文档真的很重要！</p>\n<p>这里举两个官方的例子：</p>\n<ul>\n<li><code>ZonePreferenceServiceInstanceListSupplier</code>：实现基于区域的负载平衡</li>\n<li><code>HintBasedServiceInstanceListSupplier</code>：实现基于 hint 提示的负载均衡</li>\n</ul>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomLoadBalancerConfiguration</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 使用基于区域的负载平衡方法</span>\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ServiceInstanceListSupplier</span> <span class=\"token function\">discoveryClientServiceInstanceListSupplier</span><span class=\"token punctuation\">(</span>\n            <span class=\"token class-name\">ConfigurableApplicationContext</span> context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">ServiceInstanceListSupplier</span><span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">withDiscoveryClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">withZonePreference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">withCaching</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>关于 Spring Cloud Load Balancer 更详细更新的介绍，推荐大家看看官方文档：<a href=\"https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer</a> ，一切以官方文档为主。</p>\n<p>轮询策略基本可以满足绝大部分项目的需求，我们的实际项目中如果没有特殊需求的话，通常使用的就是默认的轮询策略。并且，Ribbon 和 Spring Cloud Load Balancer 都支持自定义负载均衡策略。</p>\n<p>个人建议如非必需 Ribbon 某个特有的功能或者负载均衡策略的话，就优先选择 Spring 官方提供的 Spring Cloud Load Balancer。</p>\n<p>最后再说说为什么我不太推荐使用 Ribbon 。</p>\n<p>Spring Cloud 2020.0.0 版本移除了 Netflix 除 Eureka 外的所有组件。Spring Cloud Hoxton.M2 是第一个支持 Spring Cloud Load Balancer 来替代 Netfix Ribbon 的版本。</p>\n<p>我们早期学习微服务，肯定接触过 Netflix 公司开源的 Feign、Ribbon、Zuul、Hystrix、Eureka 等知名的微服务系统构建所必须的组件，直到现在依然有非常非常多的公司在使用这些组件。不夸张地说，Netflix 公司引领了 Java 技术栈下的微服务发展。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/SpringCloudNetflix.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>那为什么 Spring Cloud 这么急着移除 Netflix 的组件呢？</strong> 主要是因为在 2018 年的时候，Netflix 宣布其开源的核心组件 Hystrix、Ribbon、Zuul、Eureka 等进入维护状态，不再进行新特性开发，只修 BUG。于是，Spring 官方不得不考虑移除 Netflix 的组件。</p>\n<p><strong>Spring Cloud Alibaba</strong> 是一个不错的选择，尤其是对于国内的公司和个人开发者来说。</p>\n<h2>参考</h2>\n<ul>\n<li>干货 | eBay 的 4 层软件负载均衡实现：<a href=\"https://mp.weixin.qq.com/s/bZMxLTECOK3mjdgiLbHj-g\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/bZMxLTECOK3mjdgiLbHj-g</a></li>\n<li>HTTP Load Balancing（Nginx 官方文档）：<a href=\"https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/</a></li>\n<li>深入浅出负载均衡 - vivo 互联网技术：<a href=\"https://www.cnblogs.com/vivotech/p/14859041.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/vivotech/p/14859041.html</a></li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-performance/load-balancing/multi-service-load-balancing.drawio.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "读写分离和分库分表常见问题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/read-and-write-separation-and-library-subtable.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/read-and-write-separation-and-library-subtable.html",
      "summary": "读写分离 什么是读写分离？ 见名思意，根据读写分离的名字，我们就可以知道：读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。 我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。 读写分离示意图读写分离示意图 一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读...",
      "content_html": "<h2>读写分离</h2>\n<h3>什么是读写分离？</h3>\n<p>见名思意，根据读写分离的名字，我们就可以知道：<strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。</strong> 这样的话，就能够小幅提升写性能，大幅提升读性能。</p>\n<p>我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png\" alt=\"读写分离示意图\" tabindex=\"0\"><figcaption>读写分离示意图</figcaption></figure>\n<p>一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p>\n<h3>读写分离会带来什么问题？如何解决？</h3>\n<p>读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 <strong>主从同步延迟</strong> 。</p>\n<p>主从同步延迟问题的解决，没有特别好的一种方案（可能是我太菜了，欢迎评论区补充）。你可以根据自己的业务场景，参考一下下面几种解决办法。</p>\n<p><strong>1.强制将读请求路由到主库处理。</strong></p>\n<p>既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。</p>\n<p>比如 <code>Sharding-JDBC</code> 就是采用的这种方案。通过使用 Sharding-JDBC 的 <code>HintManager</code> 分片键值管理器，我们可以强制使用主库。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">HintManager</span> hintManager <span class=\"token operator\">=</span> <span class=\"token class-name\">HintManager</span><span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nhintManager<span class=\"token punctuation\">.</span><span class=\"token function\">setMasterRouteOnly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 继续JDBC操作</span>\n</code></pre></div><p>对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。</p>\n<p><strong>2.延迟读取。</strong></p>\n<p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。</p>\n<p>不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p>\n<p>另外，<a href=\"https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI%3D\" target=\"_blank\" rel=\"noopener noreferrer\">《MySQL 实战 45 讲》</a>这个专栏中的<a href=\"https://time.geekbang.org/column/article/77636\" target=\"_blank\" rel=\"noopener noreferrer\">《读写分离有哪些坑？》</a>这篇文章还介绍了很多其他比较实际的解决办法，感兴趣的小伙伴可以自行研究一下。</p>\n<h3>如何实现读写分离？</h3>\n<p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p>\n<ol>\n<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>\n<li>保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的<strong>主从复制</strong>。</li>\n<li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li>\n</ol>\n<p>落实到项目本身的话，常用的方式有两种：</p>\n<p><strong>1. 代理方式</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation-proxy.png\" alt=\"代理方式实现读写分离\" tabindex=\"0\"><figcaption>代理方式实现读写分离</figcaption></figure>\n<p>我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。</p>\n<p>提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>MaxScale</strong>、<strong>MyCat</strong>。</p>\n<p><strong>2. 组件方式</strong></p>\n<p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。</p>\n<p>这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p>\n<p>你可以在 shardingsphere 官方找到 <a href=\"https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/\" target=\"_blank\" rel=\"noopener noreferrer\">sharding-jdbc 关于读写分离的操作</a>。</p>\n<h3>主从复制原理是什么？</h3>\n<p>MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p>\n<p>更具体和详细的过程是这个样子的（图片来自于：<a href=\"https://www.toptal.com/mysql/mysql-master-slave-replication-tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">《MySQL Master-Slave Replication on the Same Machine》</a>）：</p>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/78816271d3ab52424bfd5ad3086c1a0f.png\" alt=\"MySQL主从复制\" tabindex=\"0\"><figcaption>MySQL主从复制</figcaption></figure>\n<ol>\n<li>主库将数据库中数据的变化写入到 binlog</li>\n<li>从库连接主库</li>\n<li>从库会创建一个 I/O 线程向主库请求更新的 binlog</li>\n<li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收</li>\n<li>从库的 I/O 线程将接收的 binlog 写入到 relay log 中。</li>\n<li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li>\n</ol>\n<p>怎么样？看了我对主从复制这个过程的讲解，你应该搞明白了吧!</p>\n<p>你一般看到 binlog 就要想到主从复制。当然，除了主从复制之外，binlog 还能帮助我们实现数据恢复。</p>\n<p>🌈 拓展一下：</p>\n<p>不知道大家有没有使用过阿里开源的一个叫做 canal 的工具。这个工具可以帮助我们实现 MySQL 和其他数据源比如 Elasticsearch 或者另外一台 MySQL 数据库之间的数据同步。很显然，这个工具的底层原理肯定也是依赖 binlog。canal 的原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。</p>\n<p>另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。</p>\n<p>🌕 简单总结一下：</p>\n<p><strong>MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</strong></p>\n<h2>分库分表</h2>\n<p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：<strong>如果 MySQL 一张表的数据量过大怎么办?</strong></p>\n<p>换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p>\n<p>答案之一就是 <strong>分库分表</strong>。</p>\n<h3>什么是分库？</h3>\n<p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>\n<p><strong>垂直分库</strong> 就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p>\n<p>举个例子：说你将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</p>\n<figure><figcaption>垂直分库</figcaption></figure>\n<p><strong>水平分库</strong> 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p>\n<p>举个例子：订单表数据量太大，你对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库。</p>\n<figure><figcaption>水平分库</figcaption></figure>\n<h3>什么是分表？</h3>\n<p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>\n<p><strong>垂直分表</strong> 是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p>\n<p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p>\n<p><strong>水平分表</strong> 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p>\n<p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>\n<p>水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，水平分表通常和水平分库同时出现。</p>\n<figure><figcaption>分表</figcaption></figure>\n<h3>什么情况下需要分库分表？</h3>\n<p>遇到下面几种场景可以考虑分库分表：</p>\n<ul>\n<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li>\n<li>数据库中的数据占用的空间越来越大，备份时间越来越长。</li>\n<li>应用的并发量太大。</li>\n</ul>\n<h3>常见的分片算法有哪些？</h3>\n<p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。</p>\n<ul>\n<li><strong>哈希分片</strong>：求指定 key（比如 id） 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。</li>\n<li><strong>范围分片</strong>：按照特性的范围区间（比如时间区间、ID 区间）来分配数据，比如 将 <code>id</code> 为 <code>1~299999</code> 的记录分到第一个库， <code>300000~599999</code> 的分到第二个库。范围分片适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。</li>\n<li><strong>地理位置分片</strong>：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。</li>\n<li><strong>融合算法</strong>：灵活组合多种分片算法，比如将哈希分片和范围分片组合。</li>\n<li>......</li>\n</ul>\n<h3>分库分表会带来什么问题呢？</h3>\n<p>记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。</p>\n<p>引入分库分表之后，会给系统带来什么挑战呢？</p>\n<ul>\n<li><strong>join 操作</strong>：同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</li>\n<li><strong>事务问题</strong>：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。</li>\n<li><strong>分布式 id</strong>：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。</li>\n<li>......</li>\n</ul>\n<p>另外，引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器，这些都属于成本。</p>\n<h3>分库分表有没有什么比较推荐的方案？</h3>\n<p>ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-0aa05fa5f54e41a44b09619fc0ee597933c.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。</p>\n<p>另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p>\n<p>艿艿之前写了一篇分库分表的实战文章，各位朋友可以看看：<a href=\"https://mp.weixin.qq.com/s/A2MYOFT7SP-7kGOon8qJaw\" target=\"_blank\" rel=\"noopener noreferrer\">《芋道 Spring Boot 分库分表入门》</a> 。</p>\n<h3>分库分表后，数据怎么迁移呢？</h3>\n<p>分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？</p>\n<p>比较简单同时也是非常常用的方案就是<strong>停机迁移</strong>，写个脚本老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p>\n<p>如果你不想停机迁移数据的话，也可以考虑<strong>双写方案</strong>。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：</p>\n<ul>\n<li>我们对老库的更新操作（增删改），同时也要写入新库（双写）。如果操作的数据不存在于新库的话，需要插入到新库中。 这样就能保证，咱们新库里的数据是最新的。</li>\n<li>在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li>\n<li>重复上一步的操作，直到老库和新库的数据一致为止。</li>\n</ul>\n<p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们可以借助上面提到的数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。</p>\n<h2>总结</h2>\n<ul>\n<li>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。</li>\n<li>读写分离基于主从复制，MySQL 主从复制是依赖于 binlog 。</li>\n<li><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上。<strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</li>\n<li>引入分库分表之后，需要系统解决事务、分布式 id、无法 join 操作问题。</li>\n<li>ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "程序人生",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/",
      "summary": "程序人生 这里主要会收录一些我看到的和程序员密切相关的非技术类的优质文章，每一篇都值得你阅读 3 遍以上！常看常新！ 练级攻略 个人经历 程序员 面试 工作",
      "content_html": "\n<p>这里主要会收录一些我看到的和程序员密切相关的非技术类的优质文章，每一篇都值得你阅读 3 遍以上！常看常新！</p>\n<h2>练级攻略</h2>\n<h2>个人经历</h2>\n<ul>\n<li><a href=\"/Note-Book/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary.html\" target=\"_blank\">从校招入职腾讯的四年工作总结</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao.html\" target=\"_blank\">我在滴滴和头条的两年后端研发工作经验分享</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary.html\" target=\"_blank\">一个中科大差生的 8 年程序员工作总结</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/personal-experience/huawei-od-275-days.html\" target=\"_blank\">华为 OD 275 天后，我进了腾讯！</a></li>\n</ul>\n<h2>程序员</h2>\n<ul>\n<li><a href=\"/Note-Book/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book.html\" target=\"_blank\">程序员怎样出版一本技术书</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide.html\" target=\"_blank\">程序员高效出书避坑和实践指南</a></li>\n</ul>\n<h2>面试</h2>\n<ul>\n<li><a href=\"/Note-Book/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies.html\" target=\"_blank\">斩获 20+ 大厂 offer 的面试经验分享</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer.html\" target=\"_blank\">一位大龄程序员所经历的面试的历炼和思考</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/interview/technical-preliminary-preparation.html\" target=\"_blank\">从面试官和候选者的角度谈如何准备技术初试</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/interview/screen-candidates-for-packaging.html\" target=\"_blank\">包装严重的 IT 行业，作为面试官，我是如何甄别应聘者的包装程度</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/interview/summary-of-spring-recruitment.html\" target=\"_blank\">普通人的春招总结（阿里、腾讯 offer）</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/interview/my-personal-experience-in-2021.html\" target=\"_blank\">2021 校招我的个人经历和经验</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology.html\" target=\"_blank\">如何在技术初试中考察程序员的技术能力</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview.html\" target=\"_blank\">阿里技术面试的一些秘密</a></li>\n</ul>\n<h2>工作</h2>\n<ul>\n<li><a href=\"/Note-Book/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company.html\" target=\"_blank\">新入职一家公司如何快速进入工作状态</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/work/32-tips-improving-career.html\" target=\"_blank\">32 条总结教你提升职场经验</a></li>\n<li><a href=\"/Note-Book/high-quality-technical-articles/work/employee-performance.html\" target=\"_blank\">聊聊大厂的绩效考核</a></li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "面试速记",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/interview-shorthand/",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/interview-shorthand/",
      "summary": "面试速记 只求面试速记，不求深入原理",
      "content_html": "\n<p>只求面试速记，不求深入原理</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "贡献指南",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/javaguide/contribution-guideline.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/javaguide/contribution-guideline.html",
      "summary": "欢迎参与 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：JavaGuide 贡献指南 。 你可以从下面几个方向来做贡献： 笔记内容大多是手敲，所以难免会有笔误，你可以帮我找错别字。 很多知识点我可能没有涉及到，所以你可以对其他知识点进行补充。 现有的知识点难免存在不完善或者错误，所以你可以对已有知识点进行修改/补充。 一定一定...",
      "content_html": "<p>欢迎参与 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：<a href=\"https://zhuanlan.zhihu.com/p/464832264\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 贡献指南</a> 。</p>\n<p>你可以从下面几个方向来做贡献：</p>\n<ul>\n<li>笔记内容大多是手敲，所以难免会有笔误，你可以帮我找错别字。</li>\n<li>很多知识点我可能没有涉及到，所以你可以对其他知识点进行补充。</li>\n<li>现有的知识点难免存在不完善或者错误，所以你可以对已有知识点进行修改/补充。</li>\n</ul>\n<p>一定一定一定要注意 <strong>排版规范</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/sparanoid/chinese-copywriting-guidelines\" target=\"_blank\" rel=\"noopener noreferrer\">中文文案排版指北 - GitHub</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20506092\" target=\"_blank\" rel=\"noopener noreferrer\">写给大家看的中文排版指南 - 知乎</a></li>\n<li><a href=\"https://dawner.top/posts/chinese-copywriting-rules/\" target=\"_blank\" rel=\"noopener noreferrer\">中文文案排版细则 - Dawner</a></li>\n<li><a href=\"https://github.com/yikeke/zh-style-guide/\" target=\"_blank\" rel=\"noopener noreferrer\">中文技术文档写作风格指南</a></li>\n</ul>\n<p>如果要提 issue/question 的话，强烈推荐阅读下面这些资料：</p>\n<ul>\n<li><a href=\"https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way\" target=\"_blank\" rel=\"noopener noreferrer\">《提问的智慧》</a></li>\n<li><a href=\"https://github.com/seajs/seajs/issues/545\" target=\"_blank\" rel=\"noopener noreferrer\">《如何向开源社区提问题》</a></li>\n<li><a href=\"http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html\" target=\"_blank\" rel=\"noopener noreferrer\">《如何有效地报告 Bug》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25795393\" target=\"_blank\" rel=\"noopener noreferrer\">《如何向开源项目提交无法解答的问题》</a>。</li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "走近项目"
      ]
    },
    {
      "title": "常见问题",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/javaguide/faq.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/javaguide/faq.html",
      "summary": "JavaGuide 是否支持 RSS？ 必须支持！推荐 RSS 订阅本网站获取最新更新。 JavaGuide 有没有 PDF 版本？ 由于 JavaGuide 内容在持续完善，所以并没有一个完全与之同步的 PDF 版本提供。如果你想要 PDF 版本的话，可以考虑 《JavaGuide 面试突击版》 ，这是对 JavaGuide 内容的浓缩总结。 《Ja...",
      "content_html": "<h2>JavaGuide 是否支持 RSS？</h2>\n<p>必须支持！推荐 RSS 订阅本网站获取最新更新。</p>\n<h2>JavaGuide 有没有 PDF 版本？</h2>\n<p>由于 JavaGuide 内容在持续完善，所以并没有一个完全与之同步的 PDF 版本提供。如果你想要 PDF 版本的话，可以考虑 <strong>《JavaGuide 面试突击版》</strong> ，这是对 JavaGuide 内容的浓缩总结。</p>\n<p>《JavaGuide 面试突击版》在我的公众号后台回复“<strong>PDF</strong>”即可获取，免费的。除了 《JavaGuide 面试突击版》之外，还会免费送你多本优质面试 PDF 手册。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"公众号\" tabindex=\"0\"><figcaption>公众号</figcaption></figure>\n<h2>如何看待 JavaGuide 的 star 数量很多？</h2>\n<p><a href=\"https://github.com/Snailclimb\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 目前已经是 Java 领域 star 数量最多的几个项目之一，登顶过很多次 GitHub Trending。</p>\n<p>不过，这个真心没啥好嘚瑟的。因为，教程类的含金量其实是比较低的，star 数量比较多主要也是因为受众面比较广，大家觉得不错，点个 star 就相当于收藏了。很多特别优秀的框架，star 数量可能只有几 K。所以，单纯看 star 数量没啥意思，就当看个笑话吧！</p>\n<p>维护这个项目的过程中，也被某些人 diss 过：“md 项目，没啥含金量，给国人丢脸！”。</p>\n<p>对于说这类话的人，我觉得对我没啥影响，就持续完善，把 JavaGuide 做的更好吧！其实，国外的很多项目也是纯 MD 啊！就比如外国的朋友发起的 awesome 系列、求职面试系列。无需多说，行动自证！凎！</p>\n<p>开源非常重要的一点就是协作。如果你开源了一个项目之后，就不再维护，别人给你提交 issue/pr，你都不处理，那开源也没啥意义了！</p>\n<h2>JavaGuide 会不会推出纸质书籍？</h2>\n<p>可以给出一个比较明确的答案：<strong>暂时没有考虑出书</strong> 。</p>\n<p>JavaGuide 这个项目诞生一年左右就有出版社的老师联系我了，由于自知个人能力尚需沉淀，我都婉拒了。这几年的话，由于项目还是有一点知名度的，找我出书的出版社老师更多了，也都被我一一婉拒了。</p>\n<p><strong>出书既能博名又能赚点钱，我为啥不考虑出书呢？</strong></p>\n<ul>\n<li>JavaGuide 的很多内容我还不是很满意，也一直在维护中，细心的小伙伴看我的<a href=\"https://github.com/Snailclimb/JavaGuide/commits/main\" target=\"_blank\" rel=\"noopener noreferrer\">提交记录</a>就明白了。</li>\n<li>开源版本更容易维护和修改，也能让更多人更方便地参与到项目的建设中，这也是我最初做这个项目的初衷。</li>\n<li>我觉得出书是一件神圣的事情，自认能力还不够。</li>\n<li>个人精力有限，不光有本职工作，还弄了一个<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>赚点外快，还要维护完善 JavaGuide。</li>\n<li>......</li>\n</ul>\n<p>这几年一直在默默完善，真心希望 JavaGuide 越来越好，帮助到更多朋友！也欢迎大家参与进来！</p>\n<h2>JavaGuide 上为什么有一些付费文章？</h2>\n<p>是这样的，JavaGuide 上确实有非常非常少的付费文章，差不多 10 篇不到吧，这对于整个网站的内容来说算是微不足道了。</p>\n<p>这些付费文章属于<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>专属，是我用来引流知识星球的，对整体阅读其实并没有什么影响的。</p>\n<p>我也知道大家不喜欢营销，所以我会让自己控制好一个度。我一不割韭菜，二不贩卖焦虑，仅仅赚一份小钱提升家人生活品质。</p>\n<p><strong>用心做内容，真心希望能帮助到其他人。</strong></p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "走近项目"
      ]
    },
    {
      "title": "网站历史",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/javaguide/history.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/javaguide/history.html",
      "summary": "由于项目内容一直持续在更新迭代，所以，这里就不记录项目内容的具体更新情况了。 你可以通过 RSS 订阅获取网站的最新更新，你还可以通过 https://javaguide.cn/article/获取到网站最新更新的文章。 这里只记录一些比较重要的一些节点： 2022-06-13：完善网站排版以及样式。 2022-04-09：添加技术书籍精选。 2021...",
      "content_html": "<p>由于项目内容一直持续在更新迭代，所以，这里就不记录项目内容的具体更新情况了。</p>\n<p>你可以通过 <a href=\"https://javaguide.cn/feed.json\" target=\"_blank\" rel=\"noopener noreferrer\">RSS 订阅</a>获取网站的最新更新，你还可以通过 <a href=\"https://javaguide.cn/article/\" target=\"_blank\" rel=\"noopener noreferrer\">https://javaguide.cn/article/</a>获取到网站最新更新的文章。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguideimage-20220614172338606.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这里只记录一些比较重要的一些节点：</p>\n<ul>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/83efb36fb56d197f2c4b471084b884c6a4f23e37\" target=\"_blank\" rel=\"noopener noreferrer\">2022-06-13</a>：完善网站排版以及样式。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/618477f96c4a976cfe5a3bba2f646c0d20e3137e\" target=\"_blank\" rel=\"noopener noreferrer\">2022-04-09</a>：添加<a href=\"https://javaguide.cn/books/\" target=\"_blank\" rel=\"noopener noreferrer\">技术书籍精选</a>。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/5c45af9c7a7cff0d3bc905b09b3bc42f2ee8a88a\" target=\"_blank\" rel=\"noopener noreferrer\">2021-03-13</a>：添加<a href=\"https://javaguide.cn/open-source-project/\" target=\"_blank\" rel=\"noopener noreferrer\">开源项目精选</a>。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/827996e7722fd51718863d4bee156a8c6c759ff5\" target=\"_blank\" rel=\"noopener noreferrer\">2021-03-03</a> : 移除了开发工具的部分内容。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/5a5f8ccb3bfb8d6ba8ac41295f1a1e4555395260\" target=\"_blank\" rel=\"noopener noreferrer\">2021-03-03</a>：vuepress-theme-hope 主题更新升级（比较重要的一次主题更新，从 1.x 版本升级到 2.x 版本，网站性能提升）。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/dc45389934b7763f4f9789168f71c72ef303d3c4\" target=\"_blank\" rel=\"noopener noreferrer\">2021-11-09</a> : 基于 vuepress 重构整个项目，提升阅读体验。</li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguideimage-20220614172338606.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "走近项目"
      ]
    },
    {
      "title": "项目介绍",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/javaguide/intro.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/javaguide/intro.html",
      "summary": "我是 19 年大学毕业的，在大三准备面试的时候，我开源了 JavaGuide 。我把自己准备面试过程中的一些总结都毫不保留地通过 JavaGuide 分享了出来。 开源 JavaGuide 初始想法源于自己的个人那一段比较迷茫的学习经历，主要目的是为了通过这个开源平台来帮助一些在学习 Java 或者面试过程中遇到问题的小伙伴。 对于 Java 初学者来...",
      "content_html": "<p>我是 19 年大学毕业的，在大三准备面试的时候，我开源了 JavaGuide 。我把自己准备面试过程中的一些总结都毫不保留地通过 JavaGuide 分享了出来。</p>\n<p>开源 JavaGuide 初始想法源于自己的个人那一段比较迷茫的学习经历，主要目的是为了通过这个开源平台来帮助一些在学习 Java 或者面试过程中遇到问题的小伙伴。</p>\n<ul>\n<li><strong>对于 Java 初学者来说：</strong> 本文档倾向于给你提供一个比较详细的学习路径，目录清晰，让你对于 Java 整体的知识体系有一个清晰认识。你可以跟着视频或者书籍学习完某个知识点之后，然后来这里找对应的总结，帮助你更好地掌握对应的知识点。</li>\n<li><strong>对于非 Java 初学者来说：</strong> 本文档更适合回顾知识，准备面试，让你搞清面试应该把重心放在哪些问题上。</li>\n</ul>\n<p><strong>由于本网站的内容完全开源，由大家共同维护完善，因此内容质量比较高。</strong> 如果你也想要参与 JavaGuide 的维护建设工作，请查阅<a href=\"/Note-Book/javaguide/contribution-guideline.html\" target=\"_blank\">贡献指南</a>。</p>\n<p>相比于其他通过 JavaGuide 学到东西或者说助力获得 offer 的朋友来说 ， JavaGuide 对我的意义更加重大。不夸张的说，有时候真的感觉像是自己的孩子一点一点长大一样，我一直用心呵护着它。虽然，我花了很长时间来维护它，但是，我觉得非常值得！非常有意义！</p>\n<p>不过，希望大家对面试不要抱有侥幸的心理，打铁还需自身硬！ <strong>我希望这个文档是为你学习 Java 指明方向，而不仅仅是用来应付面试用的。</strong></p>\n<p>另外，JavaGuide 不可能把面试中的所有内容都给涵盖住，尤其是阿里、美团这种挖的比较深入的面试。你可以根据你的目标公司进行针对性的深入学习，多看一些目标公司的面经进行查漏补缺，没事就自测一下，多多思考总结。</p>\n<p>加油！奥利给！</p>\n<h2>项目说明</h2>\n<ul>\n<li><a href=\"https://javaguide.cn\" target=\"_blank\" rel=\"noopener noreferrer\">在线阅读网站</a>基于 Vuepress 搭建，使用的是主题是 <a href=\"https://github.com/vuepress-theme-hope/vuepress-theme-hope\" target=\"_blank\" rel=\"noopener noreferrer\">vuepress-theme-hope</a>（很 Nice 的一个主题）。</li>\n<li>项目的 Markdown 格式参考：<a href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub Markdown 格式</a>，表情素材来自：<a href=\"https://www.webpagefx.com/tools/emoji-cheat-sheet/\" target=\"_blank\" rel=\"noopener noreferrer\">EMOJI CHEAT SHEET</a>。</li>\n<li>Logo 下的小图标是使用<a href=\"https://shields.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Shields.IO</a> 生成的。</li>\n</ul>\n<h2>贡献者</h2>\n<p><a href=\"https://github.com/Snailclimb/JavaGuide/graphs/contributors\" target=\"_blank\" rel=\"noopener noreferrer\">你可以点此链接查看 JavaGuide 的所有贡献者。</a> 感谢你们让 JavaGuide 变得更好！如果你们来到武汉一定要找我，我请你们吃饭玩耍。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "走近项目"
      ]
    },
    {
      "title": "使用建议",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/javaguide/use-suggestion.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/javaguide/use-suggestion.html",
      "summary": "对于不准备面试的同学来说 ，本文档倾向于给你提供一个比较详细的学习路径，目录清晰，让你对于 Java 整体的知识体系有一个清晰认识。你可以跟着视频、书籍或者官方文档学习完某个知识点之后，然后来这里找对应的总结，帮助你更好地掌握对应的知识点。甚至说，你在有编程基础的情况下，想要学习某个知识点的话，可以直接看我的总结，这样学习效率会非常高。 对于准备面试的...",
      "content_html": "<p><strong>对于不准备面试的同学来说</strong> ，本文档倾向于给你提供一个比较详细的学习路径，目录清晰，让你对于 Java 整体的知识体系有一个清晰认识。你可以跟着视频、书籍或者官方文档学习完某个知识点之后，然后来这里找对应的总结，帮助你更好地掌握对应的知识点。甚至说，你在有编程基础的情况下，想要学习某个知识点的话，可以直接看我的总结，这样学习效率会非常高。</p>\n<p><strong>对于准备面试的同学来说</strong> ，本文档涵盖 Java 程序员所需要掌握的核心知识的常见面试问题总结。</p>\n<p>大部分人看 JavaGuide 应该都是为了准备技术八股文。<strong>那如何才能更高效地准备技术八股文？</strong></p>\n<p>对于技术八股文来说，尽量不要死记硬背，这种方式非常枯燥且对自身能力提升有限！但是！想要一点不背是不太现实的，只是说要结合实际应用场景和实战来理解记忆。</p>\n<p>我一直觉得面试八股文最好是和实际应用场景和实战相结合。很多同学现在的方向都错了，上来就是直接背八股文，硬生生学成了文科，那当然无趣了。</p>\n<p>举个例子：你的项目中需要用到 Redis 来做缓存，你对照着官网简单了解并实践了简单使用 Redis 之后，你去看了 Redis 对应的八股文。你发现 Redis 可以用来做限流、分布式锁，于是你去在项目中实践了一下并掌握了对应的八股文。紧接着，你又发现 Redis 内存不够用的情况下，还能使用 Redis Cluster 来解决，于是你就又去实践了一下并掌握了对应的八股文。</p>\n<p>而且， <strong>面试中有水平的面试官都是根据你的项目经历来顺带着问一些技术八股文</strong> 。</p>\n<p>举个例子：你的项目用到了消息队列，那面试官可能就会问你：为什么使用消息队列？项目中什么模块用到了消息队列？如何保证消息不丢失？如何保证消息的顺序性?（结合你使用的具体的消息队列来准备）......。</p>\n<p><strong>一定要记住你的主要目标是理解和记关键词，而不是像背课文一样一字一句地记下来！</strong></p>\n<p>另外，记录博客或者用自己的理解把对应的知识点讲给别人听也是一个不错的选择。</p>\n<p>最后，准备技术面试的同学一定要定期复习（自测的方式非常好），不然确实会遗忘的。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "走近项目"
      ]
    },
    {
      "title": "笔记本",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/notebook/",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/notebook/",
      "summary": "笔记本",
      "content_html": "\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "实战手册",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/practice-manual/",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/practice-manual/",
      "summary": "实战手册 实战手册 实战手册 Elasticsearch 官方API文档：Elasticsearch Doc Java在线运行 Java Playground Redis命令在线学习 Redis命令学习",
      "content_html": "\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">实战手册</p>\n<p>实战手册</p>\n</div>\n<h2>Elasticsearch</h2>\n<p>官方API文档：<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html\" target=\"_blank\" rel=\"noopener noreferrer\">Elasticsearch Doc</a></p>\n<h2>Java在线运行</h2>\n<p><a href=\"https://dev.java/assets/playground/web/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java Playground</a></p>\n<h2>Redis命令在线学习</h2>\n<p><a href=\"https://try.redis.io\" target=\"_blank\" rel=\"noopener noreferrer\">Redis命令学习</a></p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html",
      "summary": "Servlet 总结 在 Java Web 程序中，Servlet主要负责接收用户请求 HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。Servlet 可以设置初始化参数，供 Servlet 内部使用。一个 Servlet 类只会有一个实例，在它初始化时调...",
      "content_html": "<h2>Servlet 总结</h2>\n<p>在 Java Web 程序中，<strong>Servlet</strong>主要负责接收用户请求 <code>HttpServletRequest</code>,在<code>doGet()</code>,<code>doPost()</code>中做相应的处理，并将回应<code>HttpServletResponse</code>反馈给用户。<strong>Servlet</strong> 可以设置初始化参数，供 Servlet 内部使用。一个 Servlet 类只会有一个实例，在它初始化时调用<code>init()</code>方法，销毁时调用<code>destroy()</code>方法**。**Servlet 需要在 web.xml 中配置（MyEclipse 中创建 Servlet 会自动配置），<strong>一个 Servlet 可以设置多个 URL 访问</strong>。<strong>Servlet 不是线程安全</strong>，因此要谨慎使用类变量。</p>\n<h2>阐述 Servlet 和 CGI 的区别?</h2>\n<h3>CGI 的不足之处</h3>\n<p>1，需要为每个请求启动一个操作 CGI 程序的系统进程。如果请求频繁，这将会带来很大的开销。</p>\n<p>2，需要为每个请求加载和运行一个 CGI 程序，这将带来很大的开销</p>\n<p>3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</p>\n<h3>Servlet 的优点</h3>\n<p>1，只需要启动一个操作系统进程以及加载一个 JVM，大大降低了系统的开销</p>\n<p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</p>\n<p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</p>\n<p>4，Servlet 能直接和 Web 服务器交互，而普通的 CGI 程序不能。Servlet 还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</p>\n<p>补充：Sun Microsystems 公司在 1996 年发布 Servlet 技术就是为了和 CGI 进行竞争，Servlet 是一个特殊的 Java 程序，一个基于 Java 的 Web 应用通常包含一个或多个 Servlet 类。Servlet 不能够自行创建并执行，它是在 Servlet 容器中运行的，容器将用户的请求传递给 Servlet 程序，并将 Servlet 的响应回传给用户。通常一个 Servlet 会关联一个或多个 JSP 页面。以前 CGI 经常因为性能开销上的问题被诟病，然而 Fast CGI 早就已经解决了 CGI 效率上的问题，所以面试的时候大可不必信口开河的诟病 CGI，事实上有很多你熟悉的网站都使用了 CGI 技术。</p>\n<p>参考：《javaweb 整合开发王者归来》P7</p>\n<h2>Servlet 接口中有哪些方法及 Servlet 生命周期探秘</h2>\n<p>Servlet 接口定义了 5 个方法，其中<strong>前三个方法与 Servlet 生命周期相关</strong>：</p>\n<ul>\n<li><code>void init(ServletConfig config) throws ServletException</code></li>\n<li><code>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</code></li>\n<li><code>void destroy()</code></li>\n<li><code>java.lang.String getServletInfo()</code></li>\n<li><code>ServletConfig getServletConfig()</code></li>\n</ul>\n<p><strong>生命周期：</strong> <strong>Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行 Servlet 的初始化；请求到达时调用 Servlet 的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet 或 doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将 Servlet 实例销毁，此时会调用 Servlet 的<strong>destroy()方法</strong>。<strong>init 方法和 destroy 方法只会执行一次，service 方法客户端每次请求 Servlet 都会执行</strong>。Servlet 中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入 init 方法中，销毁资源的代码放入 destroy 方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>\n<p>参考：《javaweb 整合开发王者归来》P81</p>\n<h2>get 和 post 请求的区别</h2>\n<p>get 和 post 请求实际上是没有区别，大家可以自行查询相关文章（参考文章：<a href=\"https://www.cnblogs.com/logsharing/p/8448446.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/logsharing/p/8448446.html</a>，知乎对应的问题链接：<a href=\"https://www.zhihu.com/question/28586791\" target=\"_blank\" rel=\"noopener noreferrer\">get 和 post 区别？</a>）！</p>\n<p>可以把 get 和 post 当作两个不同的行为，两者并没有什么本质区别，底层都是 TCP 连接。 get 请求用来从服务器上获得资源，而 post 是用来向服务器提交数据。比如你要获取人员列表可以用 get 请求，你需要创建一个人员可以用 post 。这也是 Restful API 最基本的一个要求。</p>\n<p>推荐阅读：</p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/28586791\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/28586791</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd</a></li>\n</ul>\n<h2>什么情况下调用 doGet()和 doPost()</h2>\n<p>Form 标签里的 method 的属性为 get 时调用 doGet()，为 post 时调用 doPost()。</p>\n<h2>转发(Forward)和重定向(Redirect)的区别</h2>\n<p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>\n<p><strong>转发（Forward）</strong>\n通过 RequestDispatcher 对象的 forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher 可以通过 HttpServletRequest 的 getRequestDispatcher()方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code>     request<span class=\"token punctuation\">.</span><span class=\"token function\">getRequestDispatcher</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"login_success.jsp\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forward</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 <code>HttpServletResponse</code> 的 <code>setStatus(int status)</code> 方法设置状态码。如果服务器返回 301 或者 302，则浏览器会到新的网址重新请求该资源。</p>\n<ol>\n<li>\n<p><strong>从地址栏显示来说</strong></p>\n<p>forward 是服务器请求资源,服务器直接访问目标地址的 URL,把那个 URL 的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.\nredirect 是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的 URL.</p>\n</li>\n<li>\n<p><strong>从数据共享来说</strong></p>\n<p>forward:转发页面和转发到的页面可以共享 request 里面的数据.\nredirect:不能共享数据.</p>\n</li>\n<li>\n<p><strong>从运用地方来说</strong></p>\n<p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.\nredirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p>\n</li>\n<li>\n<p>从效率来说</p>\n<p>forward:高.\nredirect:低.</p>\n</li>\n</ol>\n<h2>自动刷新(Refresh)</h2>\n<p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet 中通过 HttpServletResponse 对象设置 Header 属性实现自动刷新例如：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">Response</span><span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Refresh\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"5;URL=http://localhost:8080/servlet/example.htm\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>其中 5 为时间，单位为秒。URL 指定就是要跳转的页面（如果设置自己的路径，就会实现每过 5 秒自动刷新本页面一次）</p>\n<h2>Servlet 与线程安全</h2>\n<p><strong>Servlet 不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong> 解决的办法是尽量不要定义 name 属性，而是要把 name 变量分别定义在 doGet()和 doPost()方法内。虽然使用 synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。\n注意：多线程的并发的读写 Servlet 类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此 Servlet 里的只读属性最好定义为 final 类型的。</p>\n<p>参考：《javaweb 整合开发王者归来》P92</p>\n<h2>JSP 和 Servlet 是什么关系</h2>\n<p>其实这个问题在上面已经阐述过了，Servlet 是一个特殊的 Java 程序，它运行于服务器的 JVM 中，能够依靠服务器的支持向浏览器提供显示内容。JSP 本质上是 Servlet 的一种简易形式，JSP 会被服务器处理成一个类似于 Servlet 的 Java 程序，可以简化页面内容的生成。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为.jsp 的文件。有人说，Servlet 就是在 Java 中写 HTML，而 JSP 就是在 HTML 中写 Java 代码，当然这个说法是很片面且不够准确的。JSP 侧重于视图，Servlet 更侧重于控制逻辑，在 MVC 架构模式中，JSP 适合充当视图（view）而 Servlet 适合充当控制器（controller）。</p>\n<h2>JSP 工作原理</h2>\n<p>JSP 是一种 Servlet，但是与 HttpServlet 的工作方式不太一样。HttpServlet 是先由源代码编译为 class 文件后部署到服务器下，为先编译后部署。而 JSP 则是先部署后编译。JSP 会在客户端第一次请求 JSP 文件时被编译为 HttpJspPage 类（接口 Servlet 的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。\n工程 JspLoginDemo 下有一个名为 login.jsp 的 Jsp 文件，把工程第一次部署到服务器上后访问这个 Jsp 文件，我们发现这个目录下多了下图这两个东东。\n.class 文件便是 JSP 对应的 Servlet。编译完毕后再运行 class 文件来响应客户端请求。以后客户端访问 login.jsp 的时候，Tomcat 将不再重新编译 JSP 文件，而是直接调用 class 文件来响应客户端请求。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/1.jpeg\" alt=\"JSP工作原理\" tabindex=\"0\"><figcaption>JSP工作原理</figcaption></figure>\n<p>由于 JSP 只会在客户端第一次请求的时候被编译 ，因此第一次请求 JSP 时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的 class 文件删除，服务器也会重新编译 JSP。</p>\n<p>开发 Web 程序时经常需要修改 JSP。Tomcat 能够自动检测到 JSP 程序的改动。如果检测到 JSP 源代码发生了改动。Tomcat 会在下次客户端请求 JSP 时重新编译 JSP，而不需要重启 Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署 Web 应用的时候可以在 web.xml 中将它关掉。</p>\n<p>参考：《javaweb 整合开发王者归来》P97</p>\n<h2>JSP 有哪些内置对象、作用分别是什么</h2>\n<p><a href=\"http://blog.csdn.net/qq_34337272/article/details/64310849\" target=\"_blank\" rel=\"noopener noreferrer\">JSP 内置对象 - CSDN 博客</a></p>\n<p>JSP 有 9 个内置对象：</p>\n<ul>\n<li>request：封装客户端的请求，其中包含来自 GET 或 POST 请求的参数；</li>\n<li>response：封装服务器对客户端的响应；</li>\n<li>pageContext：通过该对象可以获取其他对象；</li>\n<li>session：封装用户会话的对象；</li>\n<li>application：封装服务器运行环境的对象；</li>\n<li>out：输出服务器响应的输出流对象；</li>\n<li>config：Web 应用的配置对象；</li>\n<li>page：JSP 页面本身（相当于 Java 程序中的 this）；</li>\n<li>exception：封装页面抛出异常的对象。</li>\n</ul>\n<h2>Request 对象的主要方法有哪些</h2>\n<ul>\n<li>setAttribute(String name,Object)：设置名字为 name 的 request 的参数值</li>\n<li>getAttribute(String name)：返回由 name 指定的属性值</li>\n<li>getAttributeNames()：返回 request 对象所有属性的名字集合，结果是一个枚举的实例</li>\n<li>getCookies()：返回客户端的所有 Cookie 对象，结果是一个 Cookie 数组</li>\n<li>getCharacterEncoding()：返回请求中的字符编码方式 = getContentLength()：返回请求的 Body 的长度</li>\n<li>getHeader(String name)：获得 HTTP 协议定义的文件头信息</li>\n<li>getHeaders(String name)：返回指定名字的 request Header 的所有值，结果是一个枚举的实例</li>\n<li>getHeaderNames()：返回所以 request Header 的名字，结果是一个枚举的实例</li>\n<li>getInputStream()：返回请求的输入流，用于获得请求中的数据</li>\n<li>getMethod()：获得客户端向服务器端传送数据的方法</li>\n<li>getParameter(String name)：获得客户端传送给服务器端的有 name 指定的参数值</li>\n<li>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li>\n<li>getParameterValues(String name)：获得有 name 指定的参数的所有值</li>\n<li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li>\n<li>getQueryString()：获得查询字符串</li>\n<li>getRequestURI()：获取发出请求字符串的客户端地址</li>\n<li>getRemoteAddr()：获取客户端的 IP 地址</li>\n<li>getRemoteHost()：获取客户端的名字</li>\n<li>getSession([Boolean create])：返回和请求相关 Session</li>\n<li>getServerName()：获取服务器的名字</li>\n<li>getServletPath()：获取客户端所请求的脚本文件的路径</li>\n<li>getServerPort()：获取服务器的端口号</li>\n<li>removeAttribute(String name)：删除请求中的一个属性</li>\n</ul>\n<h2>request.getAttribute()和 request.getParameter()有何区别</h2>\n<p><strong>从获取方向来看：</strong></p>\n<p><code>getParameter()</code>是获取 POST/GET 传递的参数值；</p>\n<p><code>getAttribute()</code>是获取对象容器中的数据值；</p>\n<p><strong>从用途来看：</strong></p>\n<p><code>getParameter()</code>用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或 url 重定向传值时接收数据用。</p>\n<p><code>getAttribute()</code> 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了\nmapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p>\n<p>另外，可以用 <code>setAttribute()</code>,<code>getAttribute()</code> 发送接收对象.而 <code>getParameter()</code> 显然只能传字符串。\n<code>setAttribute()</code> 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样<code>getAttribute()</code>就能取得你所设下的值，当然这种方法可以传对象。session 也一样，只是对象在内存中的生命周期不一样而已。<code>getParameter()</code>只是应用服务器在分析你送上来的 request 页面的文本时，取得你设在表单或 url 重定向时的值。</p>\n<p><strong>总结：</strong></p>\n<p><code>getParameter()</code>返回的是 String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p>\n<p><code>getAttribute()</code>返回的是 Object，需进行转换,可用<code>setAttribute()</code>设置成任意对象，使用很灵活，可随时用</p>\n<h2>include 指令 include 的行为的区别</h2>\n<p><strong>include 指令：</strong> JSP 可以通过 include 指令来包含其他文件。被包含的文件可以是 JSP 文件、HTML 文件或文本文件。包含的文件就好像是该 JSP 文件的一部分，会被同时编译执行。 语法格式如下：\n&lt;%@ include file=\"文件相对 url 地址\" %&gt;</p>\n<p>i<strong>nclude 动作：</strong> <code>&lt;jsp:include&gt;</code>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：\n&lt;jsp:include page=\"相对 URL 地址\" flush=\"true\" /&gt;</p>\n<h2>JSP 九大内置对象，七大动作，三大指令</h2>\n<p><a href=\"http://blog.csdn.net/qq_34337272/article/details/64310849\" target=\"_blank\" rel=\"noopener noreferrer\">JSP 九大内置对象，七大动作，三大指令总结</a></p>\n<h2>讲解 JSP 中的四种作用域</h2>\n<p>JSP 中的四种作用域包括 page、request、session 和 application，具体来说：</p>\n<ul>\n<li><strong>page</strong>代表与一个页面相关的对象和属性。</li>\n<li><strong>request</strong>代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</li>\n<li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</li>\n<li><strong>application</strong>代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li>\n</ul>\n<h2>如何实现 JSP 或 Servlet 的单线程模式</h2>\n<p>对于 JSP 页面，可以通过 page 指令进行设置。\n<code>&lt;%@page isThreadSafe=\"false\"%&gt;</code></p>\n<p>对于 Servlet，可以让自定义的 Servlet 实现 SingleThreadModel 标识接口。</p>\n<p>说明：如果将 JSP 或 Servlet 设置成单线程工作模式，会导致每个请求创建一个 Servlet 实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p>\n<h2>实现会话跟踪的技术有哪些</h2>\n<ol>\n<li>\n<p><strong>使用 Cookie</strong></p>\n<p>向客户端发送 Cookie</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">Cookie</span> c <span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Cookie</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"value\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//创建Cookie</span>\nc<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxAge</span><span class=\"token punctuation\">(</span><span class=\"token number\">60</span><span class=\"token operator\">*</span><span class=\"token number\">60</span><span class=\"token operator\">*</span><span class=\"token number\">24</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//设置最大时效，此处设置的最大时效为一天</span>\nresponse<span class=\"token punctuation\">.</span><span class=\"token function\">addCookie</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//把Cookie放入到HTTP响应中</span>\n</code></pre></div><p>从客户端读取 Cookie</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Cookie</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>cookies <span class=\"token operator\">=</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">getCookies</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cookies <span class=\"token operator\">!=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>cookies<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Cookie</span> cookie <span class=\"token operator\">=</span>cookies<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>cookis<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">//something is here.</span>\n    <span class=\"token comment\">//you can get the value</span>\n    cookie<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n   <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span>\n\n</code></pre></div><p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的 Key-Value</p>\n<p><strong>缺点:</strong> 大小受到限制，用户可以禁用 Cookie 功能，由于保存在本地，有一定的安全风险。</p>\n</li>\n<li>\n<p>URL 重写</p>\n<p>在 URL 中添加用户会话的信息作为请求的参数，或者将唯一的会话 ID 添加到 URL 结尾以标识一个会话。</p>\n<p><strong>优点：</strong> 在 Cookie 被禁用的时候依然可以使用</p>\n<p><strong>缺点：</strong> 必须对网站的 URL 进行编码，所有页面必须动态生成，不能用预先记录下来的 URL 进行访问。</p>\n</li>\n<li>\n<p>隐藏的表单域</p>\n<div class=\"language-html\" data-ext=\"html\" data-title=\"html\"><pre class=\"language-html\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>hidden<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>session<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>...<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/&gt;</span></span>\n</code></pre></div><p><strong>优点：</strong> Cookie 被禁时可以使用</p>\n<p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p>\n</li>\n<li>\n<p>HttpSession</p>\n<p>在所有会话跟踪技术中，HttpSession 对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的 HttpSession。可以通过 HttpServletRequest 对象的 getSession 方 法获得 HttpSession，通过 HttpSession 的 setAttribute 方法可以将一个值放在 HttpSession 中，通过调用 HttpSession 对象的 getAttribute 方法，同时传入属性名就可以获取保存在 HttpSession 中的对象。与上面三种方式不同的 是，HttpSession 放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的 Servlet 容器可以在内存将满时将 HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到 HttpSession 中的值可以是任意 Java 对象，这个对象最好实现了 Serializable 接口，这样 Servlet 容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p>\n</li>\n</ol>\n<h2>Cookie 和 Session 的区别</h2>\n<p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>\n<p><strong>Cookie 一般用来保存用户信息</strong> 比如 ① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>\n<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>\n<p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/1.jpeg",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "设计模式常见面试题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/system-design/design-pattern.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/system-design/design-pattern.html",
      "summary": "设计模式 相关的面试题已经整理到了 PDF 手册中，你可以在我的公众号“JavaGuide”后台回复“PDF” 获取。 JavaGuide 官方公众号JavaGuide 官方公众号 《设计模式》PDF 电子书内容概览： 《设计模式》PDF文档概览《设计模式》PDF文档概览",
      "content_html": "<p><strong>设计模式</strong> 相关的面试题已经整理到了 PDF 手册中，你可以在我的公众号“<strong>JavaGuide</strong>”后台回复“<strong>PDF</strong>” 获取。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n<p><strong>《设计模式》PDF 电子书内容概览</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/design-pattern-pdf.png\" alt=\"《设计模式》PDF文档概览\" tabindex=\"0\"><figcaption>《设计模式》PDF文档概览</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "Java 定时任务详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/system-design/schedule-task.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/system-design/schedule-task.html",
      "summary": "为什么需要定时任务？ 我们来看一下几个非常常见的业务场景： 某系统凌晨要进行数据备份。 某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。 某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。 某博客平台，支持定时发送文章。 某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。 ...... 这些场景往往都要求我们在某...",
      "content_html": "<h2>为什么需要定时任务？</h2>\n<p>我们来看一下几个非常常见的业务场景：</p>\n<ol>\n<li>某系统凌晨要进行数据备份。</li>\n<li>某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。</li>\n<li>某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。</li>\n<li>某博客平台，支持定时发送文章。</li>\n<li>某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。</li>\n<li>......</li>\n</ol>\n<p>这些场景往往都要求我们在某个特定的时间去做某个事情。</p>\n<h2>单机定时任务技术选型</h2>\n<h3>Timer</h3>\n<p><code>java.util.Timer</code>是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。</p>\n<p><code>Timer</code> 内部使用一个叫做 <code>TaskQueue</code> 的类存放定时任务，它是一个基于最小堆实现的优先级队列。<code>TaskQueue</code> 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可！</p>\n<p><code>Timer</code> 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 示例代码：</span>\n<span class=\"token class-name\">TimerTask</span> task <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TimerTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"当前时间: \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"n\"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"线程名称: \"</span> <span class=\"token operator\">+</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"当前时间: \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"n\"</span> <span class=\"token operator\">+</span>\n        <span class=\"token string\">\"线程名称: \"</span> <span class=\"token operator\">+</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Timer</span> timer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Timer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Timer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> delay <span class=\"token operator\">=</span> <span class=\"token number\">1000L</span><span class=\"token punctuation\">;</span>\ntimer<span class=\"token punctuation\">.</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">,</span> delay<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">//输出：</span>\n当前时间<span class=\"token operator\">:</span> <span class=\"token class-name\">Fri</span> <span class=\"token class-name\">May</span> <span class=\"token number\">28</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">18</span><span class=\"token operator\">:</span><span class=\"token number\">47</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2021</span>n线程名称<span class=\"token operator\">:</span> main\n当前时间<span class=\"token operator\">:</span> <span class=\"token class-name\">Fri</span> <span class=\"token class-name\">May</span> <span class=\"token number\">28</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">18</span><span class=\"token operator\">:</span><span class=\"token number\">48</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2021</span>n线程名称<span class=\"token operator\">:</span> <span class=\"token class-name\">Timer</span>\n</code></pre></div><p>不过其缺陷较多，比如一个 <code>Timer</code> 一个线程，这就导致 <code>Timer</code> 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（<code>Timer</code> 只捕获了 <code>InterruptedException</code> ）。</p>\n<p><code>Timer</code> 类上的有一段注释是这样写的：</p>\n<div class=\"language-JAVA\" data-ext=\"JAVA\" data-title=\"JAVA\"><pre class=\"language-JAVA\"><code> * This class does not offer real-time guarantees: it schedules\n * tasks using the &lt;tt&gt;Object.wait(long)&lt;/tt&gt; method.\n *Java 5.0 introduced the {@code java.util.concurrent} package and\n * one of the concurrency utilities therein is the {@link\n * java.util.concurrent.ScheduledThreadPoolExecutor\n * ScheduledThreadPoolExecutor} which is a thread pool for repeatedly\n * executing tasks at a given rate or delay.  It is effectively a more\n * versatile replacement for the {@code Timer}/{@code TimerTask}\n * combination, as it allows multiple service threads, accepts various\n * time units, and doesn't require subclassing {@code TimerTask} (just\n * implement {@code Runnable}).  Configuring {@code\n * ScheduledThreadPoolExecutor} with one thread makes it equivalent to\n * {@code Timer}.\n</code></pre></div><p>大概的意思就是：<code>ScheduledThreadPoolExecutor</code> 支持多线程执行定时任务并且功能更强大，是 <code>Timer</code> 的替代品。</p>\n<h3>ScheduledExecutorService</h3>\n<p><code>ScheduledExecutorService</code> 是一个接口，有多个实现类，比较常用的是 <code>ScheduledThreadPoolExecutor</code> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/20210607154324712.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>ScheduledThreadPoolExecutor</code> 本身就是一个线程池，支持任务并发执行。并且，其内部使用 <code>DelayedWorkQueue</code> 作为任务队列。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 示例代码：</span>\n<span class=\"token class-name\">TimerTask</span> repeatedTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TimerTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@SneakyThrows</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"当前时间: \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"n\"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"线程名称: \"</span> <span class=\"token operator\">+</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"当前时间: \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"n\"</span> <span class=\"token operator\">+</span>\n        <span class=\"token string\">\"线程名称: \"</span> <span class=\"token operator\">+</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">ScheduledExecutorService</span> executor <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newScheduledThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> delay  <span class=\"token operator\">=</span> <span class=\"token number\">1000L</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> period <span class=\"token operator\">=</span> <span class=\"token number\">1000L</span><span class=\"token punctuation\">;</span>\nexecutor<span class=\"token punctuation\">.</span><span class=\"token function\">scheduleAtFixedRate</span><span class=\"token punctuation\">(</span>repeatedTask<span class=\"token punctuation\">,</span> delay<span class=\"token punctuation\">,</span> period<span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MILLISECONDS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>delay <span class=\"token operator\">+</span> period <span class=\"token operator\">*</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nexecutor<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//输出：</span>\n当前时间<span class=\"token operator\">:</span> <span class=\"token class-name\">Fri</span> <span class=\"token class-name\">May</span> <span class=\"token number\">28</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">40</span><span class=\"token operator\">:</span><span class=\"token number\">46</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2021</span>n线程名称<span class=\"token operator\">:</span> main\n当前时间<span class=\"token operator\">:</span> <span class=\"token class-name\">Fri</span> <span class=\"token class-name\">May</span> <span class=\"token number\">28</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">40</span><span class=\"token operator\">:</span><span class=\"token number\">47</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2021</span>n线程名称<span class=\"token operator\">:</span> pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">1</span>\n当前时间<span class=\"token operator\">:</span> <span class=\"token class-name\">Fri</span> <span class=\"token class-name\">May</span> <span class=\"token number\">28</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">40</span><span class=\"token operator\">:</span><span class=\"token number\">48</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2021</span>n线程名称<span class=\"token operator\">:</span> pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">1</span>\n当前时间<span class=\"token operator\">:</span> <span class=\"token class-name\">Fri</span> <span class=\"token class-name\">May</span> <span class=\"token number\">28</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">40</span><span class=\"token operator\">:</span><span class=\"token number\">49</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2021</span>n线程名称<span class=\"token operator\">:</span> pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">2</span>\n当前时间<span class=\"token operator\">:</span> <span class=\"token class-name\">Fri</span> <span class=\"token class-name\">May</span> <span class=\"token number\">28</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">40</span><span class=\"token operator\">:</span><span class=\"token number\">50</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2021</span>n线程名称<span class=\"token operator\">:</span> pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">2</span>\n当前时间<span class=\"token operator\">:</span> <span class=\"token class-name\">Fri</span> <span class=\"token class-name\">May</span> <span class=\"token number\">28</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">40</span><span class=\"token operator\">:</span><span class=\"token number\">51</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2021</span>n线程名称<span class=\"token operator\">:</span> pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">2</span>\n当前时间<span class=\"token operator\">:</span> <span class=\"token class-name\">Fri</span> <span class=\"token class-name\">May</span> <span class=\"token number\">28</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">40</span><span class=\"token operator\">:</span><span class=\"token number\">52</span> <span class=\"token constant\">CST</span> <span class=\"token number\">2021</span>n线程名称<span class=\"token operator\">:</span> pool<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">-</span>thread<span class=\"token operator\">-</span><span class=\"token number\">2</span>\n</code></pre></div><p>不论是使用 <code>Timer</code> 还是 <code>ScheduledExecutorService</code> 都无法使用 Cron 表达式指定任务执行的具体时间。</p>\n<h3>Spring Task</h3>\n<p>我们直接通过 Spring 提供的 <code>@Scheduled</code> 注解即可定义定时任务，非常方便！</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token doc-comment comment\">/**\n * cron：使用Cron表达式。　每分钟的1，2秒运行\n */</span>\n<span class=\"token annotation punctuation\">@Scheduled</span><span class=\"token punctuation\">(</span>cron <span class=\"token operator\">=</span> <span class=\"token string\">\"1-2 * * * * ? \"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">reportCurrentTimeWithCronExpression</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cron Expression: The time is now {}\"</span><span class=\"token punctuation\">,</span> dateFormat<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre></div><p>我在大学那会做的一个 SSM 的企业级项目，就是用的 Spring Task 来做的定时任务。</p>\n<p>并且，Spring Task 还是支持 <strong>Cron 表达式</strong> 的。Cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式，非常厉害，你可以通过 Cron 表达式进行设置定时任务每天或者每个月什么时候执行等等操作。咱们要学习定时任务的话，Cron 表达式是一定是要重点关注的。推荐一个在线 Cron 表达式生成器：<a href=\"http://cron.qqe2.com/\" target=\"_blank\" rel=\"noopener noreferrer\">http://cron.qqe2.com/</a> 。</p>\n<p>但是，Spring 自带的定时调度只支持单机，并且提供的功能比较单一。之前写过一篇文章:<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485563&amp;idx=1&amp;sn=7419341f04036a10b141b74624a3f8c9&amp;chksm=cea247b0f9d5cea6440759e6d49b4e77d06f4c99470243a10c1463834e873ca90266413fbc92&amp;token=2133161636&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">《5 分钟搞懂如何在 Spring Boot 中 Schedule Tasks》</a> ，不了解的小伙伴可以参考一下。</p>\n<p>Spring Task 底层是基于 JDK 的 <code>ScheduledThreadPoolExecutor</code> 线程池来实现的。</p>\n<p><strong>优缺点总结：</strong></p>\n<ul>\n<li>优点：简单，轻量，支持 Cron 表达式</li>\n<li>缺点：功能单一</li>\n</ul>\n<h3>时间轮</h3>\n<p>Kafka、Dubbo、ZooKeeper、Netty、Caffeine、Akka 中都有对时间轮的实现。</p>\n<p>时间轮简单来说就是一个环形的队列（底层一般基于数组实现），队列中的每一个元素（时间格）都可以存放一个定时任务列表。</p>\n<p>时间轮中的每个时间格代表了时间轮的基本时间跨度或者说时间精度，假如时间一秒走一个时间格的话，那么这个时间轮的最高精度就是 1 秒（也就是说 3 s 和 3.9s 会在同一个时间格中）。</p>\n<p>下图是一个有 12 个时间格的时间轮，转完一圈需要 12 s。当我们需要新建一个 3s 后执行的定时任务，只需要将定时任务放在下标为 3 的时间格中即可。当我们需要新建一个 9s 后执行的定时任务，只需要将定时任务放在下标为 9 的时间格中即可。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/20210607171334861.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>那当我们需要创建一个 13s 后执行的定时任务怎么办呢？这个时候可以引入一叫做 <strong>圈数/轮数</strong> 的概念，也就是说这个任务还是放在下标为 3 的时间格中， 不过它的圈数为 2 。</p>\n<p>除了增加圈数这种方法之外，还有一种 <strong>多层次时间轮</strong> （类似手表），Kafka 采用的就是这种方案。</p>\n<p>针对下图的时间轮，我来举一个例子便于大家理解。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/20210607193042151.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>上图的时间轮，第 1 层的时间精度为 1 ，第 2 层的时间精度为 20 ，第 3 层的时间精度为 400。假如我们需要添加一个 350s 后执行的任务 A 的话（当前时间是 0s），这个任务会被放在第 2 层（因为第二层的时间跨度为 20*20=400&gt;350）的第 350/20=17 个时间格子。</p>\n<p>当第一层转了 17 圈之后，时间过去了 340s ，第 2 层的指针此时来到第 17 个时间格子。此时，第 2 层第 17 个格子的任务会被移动到第 1 层。</p>\n<p>任务 A 当前是 10s 之后执行，因此它会被移动到第 1 层的第 10 个时间格子。</p>\n<p>这里在层与层之间的移动也叫做时间轮的升降级。参考手表来理解就好！</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-c9e9da713a7c05ae3187364deeded318fa9.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>时间轮比较适合任务数量比较多的定时任务场景，它的任务写入和执行的时间复杂度都是 0（1）。</strong></p>\n<h2>分布式定时任务技术选型</h2>\n<p>上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。</p>\n<p>如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。</p>\n<p>通常情况下，一个定时任务的执行往往涉及到下面这些角色：</p>\n<ul>\n<li><strong>任务</strong>：首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。</li>\n<li><strong>调度器</strong>：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。</li>\n<li><strong>执行器</strong>：最后就是执行器，执行器接收调度器分派的任务并执行。</li>\n</ul>\n<h3>Quartz</h3>\n<p>一个很火的开源任务调度框架，完全由<code>Java</code>写成。<code>Quartz</code> 可以说是 Java 定时任务领域的老大哥或者说参考标准，其他的任务调度框架基本都是基于 <code>Quartz</code> 开发的，比如当当网的<code>elastic-job</code>就是基于<code>quartz</code>二次开发之后的分布式调度解决方案。</p>\n<p>使用 <code>Quartz</code> 可以很方便地与 <code>Spring</code> 集成，并且支持动态添加任务和集群。但是，<code>Quartz</code> 使用起来也比较麻烦，API 繁琐。</p>\n<p>并且，<code>Quzrtz</code> 并没有内置 UI 管理控制台，不过你可以使用 <a href=\"https://github.com/zhaopeiym/quartzui\" target=\"_blank\" rel=\"noopener noreferrer\">quartzui</a> 这个开源项目来解决这个问题。</p>\n<p>另外，<code>Quartz</code> 虽然也支持分布式任务。但是，它是在数据库层面，通过数据库的锁机制做的，有非常多的弊端比如系统侵入性严重、节点负载不均衡。有点伪分布式的味道。</p>\n<p><strong>优缺点总结：</strong></p>\n<ul>\n<li>优点：可以与 <code>Spring</code> 集成，并且支持动态添加任务和集群。</li>\n<li>缺点：分布式支持不友好，没有内置 UI 管理控制台、使用麻烦（相比于其他同类型框架来说）</li>\n</ul>\n<h3>Elastic-Job</h3>\n<p><code>Elastic-Job</code> 是当当网开源的一个基于<code>Quartz</code>和<code>ZooKeeper</code>的分布式调度解决方案，由两个相互独立的子项目 <code>Elastic-Job-Lite</code> 和 <code>Elastic-Job-Cloud</code> 组成，一般我们只要使用 <code>Elastic-Job-Lite</code> 就好。</p>\n<p><code>ElasticJob</code> 支持任务在分布式场景下的分片和高可用、任务可视化管理等功能。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-0042738eb83d32773fd3bf391baaa6951d1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>ElasticJob-Lite 的架构设计如下图所示：</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-a8f63f828666d43009d5d3497bcbd2cfb61.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>从上图可以看出，<code>Elastic-Job</code> 没有调度中心这一概念，而是使用 <code>ZooKeeper</code> 作为注册中心，注册中心负责协调分配任务到不同的节点上。</p>\n<p>Elastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token annotation punctuation\">@ElasticJobConf</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"dayJob\"</span><span class=\"token punctuation\">,</span> cron <span class=\"token operator\">=</span> <span class=\"token string\">\"0/10 * * * * ?\"</span><span class=\"token punctuation\">,</span> shardingTotalCount <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n        shardingItemParameters <span class=\"token operator\">=</span> <span class=\"token string\">\"0=AAAA,1=BBBB\"</span><span class=\"token punctuation\">,</span> description <span class=\"token operator\">=</span> <span class=\"token string\">\"简单任务\"</span><span class=\"token punctuation\">,</span> failover <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestJob</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">SimpleJob</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ShardingContext</span> shardingContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TestJob任务名：【{}】, 片数：【{}】, param=【{}】\"</span><span class=\"token punctuation\">,</span> shardingContext<span class=\"token punctuation\">.</span><span class=\"token function\">getJobName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> shardingContext<span class=\"token punctuation\">.</span><span class=\"token function\">getShardingTotalCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                shardingContext<span class=\"token punctuation\">.</span><span class=\"token function\">getShardingParameter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><strong>相关地址：</strong></p>\n<ul>\n<li>GitHub 地址：<a href=\"https://github.com/apache/shardingsphere-elasticjob%E3%80%82\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/apache/shardingsphere-elasticjob。</a></li>\n<li>官方网站：<a href=\"https://shardingsphere.apache.org/elasticjob/index_zh.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://shardingsphere.apache.org/elasticjob/index_zh.html</a> 。</li>\n</ul>\n<p><strong>优缺点总结：</strong></p>\n<ul>\n<li>优点：可以与 <code>Spring</code> 集成、支持分布式、支持集群、性能不错</li>\n<li>缺点：依赖了额外的中间件比如 Zookeeper（复杂度增加，可靠性降低、维护成本变高）</li>\n</ul>\n<h3>XXL-JOB</h3>\n<p><code>XXL-JOB</code> 于 2015 年开源，是一款优秀的轻量级分布式任务调度框架，支持任务可视化管理、弹性扩容缩容、任务失败重试和告警、任务分片等功能，</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-111a63288ee9057f754ca08e3c3ac86a295.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>根据 <code>XXL-JOB</code> 官网介绍，其解决了很多 <code>Quartz</code> 的不足。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-57071c34a4c57c3ea6084a363c85d645c23.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>XXL-JOB</code> 的架构设计如下图所示：</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-b8ecc6acf651f112c4dfae98243d72adea3.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>从上图可以看出，<code>XXL-JOB</code> 由 <strong>调度中心</strong> 和 <strong>执行器</strong> 两大部分组成。调度中心主要负责任务管理、执行器管理以及日志管理。执行器主要是接收调度信号并处理。另外，调度中心进行任务调度时，是通过自研 RPC 来实现的。</p>\n<p>不同于 <code>Elastic-Job</code> 的去中心化设计， <code>XXL-JOB</code> 的这种设计也被称为中心化设计（调度中心调度多个执行器执行任务）。</p>\n<p>和 <code>Quzrtz</code> 类似 <code>XXL-JOB</code> 也是基于数据库锁调度任务，存在性能瓶颈。不过，一般在任务量不是特别大的情况下，没有什么影响的，可以满足绝大部分公司的要求。</p>\n<p>不要被 <code>XXL-JOB</code> 的架构图给吓着了，实际上，我们要用 <code>XXL-JOB</code> 的话，只需要重写 <code>IJobHandler</code> 自定义任务执行逻辑就可以了，非常易用！</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token annotation punctuation\">@JobHandler</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">=</span><span class=\"token string\">\"myApiJobHandler\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyApiJobHandler</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IJobHandler</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ReturnT</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> param<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//......</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">ReturnT</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SUCCESS</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>还可以直接基于注解定义任务。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token annotation punctuation\">@XxlJob</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myAnnotationJobHandler\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ReturnT</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">myAnnotationJobHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> param<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//......</span>\n  <span class=\"token keyword\">return</span> <span class=\"token class-name\">ReturnT</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SUCCESS</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><figure><img src=\"https://oscimg.oschina.net/oscnet/up-07715bc445ef1db927bc6ec101dace5028e.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>相关地址：</strong></p>\n<ul>\n<li>GitHub 地址：<a href=\"https://github.com/xuxueli/xxl-job/%E3%80%82\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/xuxueli/xxl-job/。</a></li>\n<li>官方介绍：<a href=\"https://www.xuxueli.com/xxl-job/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.xuxueli.com/xxl-job/</a> 。</li>\n</ul>\n<p><strong>优缺点总结：</strong></p>\n<ul>\n<li>优点：开箱即用（学习成本比较低）、与 Spring 集成、支持分布式、支持集群、内置了 UI 管理控制台。</li>\n<li>缺点：不支持动态添加任务（如果一定想要动态创建任务也是支持的，参见：<a href=\"https://github.com/xuxueli/xxl-job/issues/277\" target=\"_blank\" rel=\"noopener noreferrer\">xxl-job issue277</a>）。</li>\n</ul>\n<h3>PowerJob</h3>\n<p>非常值得关注的一个分布式任务调度框架，分布式任务调度领域的新星。目前，已经有很多公司接入比如 OPPO、京东、中通、思科。</p>\n<p>这个框架的诞生也挺有意思的，PowerJob 的作者当时在阿里巴巴实习过，阿里巴巴那会使用的是内部自研的 SchedulerX（阿里云付费产品）。实习期满之后，PowerJob 的作者离开了阿里巴巴。想着说自研一个 SchedulerX，防止哪天 SchedulerX 满足不了需求，于是 PowerJob 就诞生了。</p>\n<p>更多关于 PowerJob 的故事，小伙伴们可以去看看 PowerJob 作者的视频 <a href=\"https://www.bilibili.com/video/BV1SK411A7F3/\" target=\"_blank\" rel=\"noopener noreferrer\">《我和我的任务调度中间件》</a>。简单点概括就是：“游戏没啥意思了，我要扛起了新一代分布式任务调度与计算框架的大旗！”。</p>\n<p>由于 SchedulerX 属于人民币产品，我这里就不过多介绍。PowerJob 官方也对比过其和 QuartZ、XXL-JOB 以及 SchedulerX。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-795f5e9b0d875063717b1ee6a08f2ff1c01.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>总结</h2>\n<p>这篇文章中，我主要介绍了：</p>\n<ul>\n<li><strong>定时任务的相关概念</strong>：为什么需要定时任务、定时任务中的核心角色、分布式定时任务。</li>\n<li><strong>定时任务的技术选型</strong>：XXL-JOB 2015 年推出，已经经过了很多年的考验。XXL-JOB 轻量级，并且使用起来非常简单。虽然存在性能瓶颈，但是，在绝大多数情况下，对于企业的基本需求来说是没有影响的。PowerJob 属于分布式任务调度领域里的新星，其稳定性还有待继续考察。ElasticJob 由于在架构设计上是基于 Zookeeper ，而 XXL-JOB 是基于数据库，性能方面的话，ElasticJob 略胜一筹。</li>\n</ul>\n<p>这篇文章并没有介绍到实际使用，但是，并不代表实际使用不重要。我在写这篇文章之前，已经动手写过相应的 Demo。像 Quartz，我在大学那会就用过。不过，当时用的是 Spring 。为了能够更好地体验，我自己又在 Spring Boot 上实际体验了一下。如果你并没有实际使用某个框架，就直接说它并不好用的话，是站不住脚的。</p>\n<p>最后，这篇文章要感谢艿艿的帮助，写这篇文章的时候向艿艿询问过一些问题。推荐一篇艿艿写的偏实战类型的硬核文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247490679&amp;idx=1&amp;sn=25374dbdcca95311d41be5d7b7db454d&amp;chksm=fa4963c6cd3eead055bb9cd10cca13224bb35d0f7373a27aa22a55495f71e24b8273a7603314&amp;scene=27#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">《Spring Job？Quartz？XXL-Job？年轻人才做选择，艿艿全莽~》</a> 。</p>\n",
      "image": "https://oss.javaguide.cn/javaguide/20210607154324712.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "Web 实时消息推送详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/system-design/web-real-time-message-push.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/system-design/web-real-time-message-push.html",
      "summary": "原文地址：https://juejin.cn/post/7122014462181113887，JavaGuide 对本文进行了完善总结。 我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。 站内信 Web 消息推送站内信 Web 消息推送 不过他还没想好用什么方式做，这里我帮他整理了一...",
      "content_html": "<blockquote>\n<p>原文地址：<a href=\"https://juejin.cn/post/7122014462181113887%EF%BC%8CJavaGuide\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/7122014462181113887，JavaGuide</a> 对本文进行了完善总结。</p>\n</blockquote>\n<p>我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png\" alt=\"站内信 Web 消息推送\" tabindex=\"0\"><figcaption>站内信 Web 消息推送</figcaption></figure>\n<p>不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。</p>\n<h2>什么是消息推送？</h2>\n<p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。</p>\n<p>消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备 APP 进行的主动消息推送。</p>\n<p>消息推送一般又分为 Web 端消息推送和移动端消息推送。</p>\n<p>移动端消息推送示例：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/IKleJ9auR1Ojdicyr0bH.png\" alt=\"移动端消息推送示例\" tabindex=\"0\"><figcaption>移动端消息推送示例</figcaption></figure>\n<p>Web 端消息推送示例：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/image-20220819100512941.png\" alt=\"Web 端消息推送示例\" tabindex=\"0\"><figcaption>Web 端消息推送示例</figcaption></figure>\n<p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），Web 页面的通知小红点就会实时的 <code>+1</code> 就可以了。</p>\n<p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192384.png\" alt=\"消息推送表\" tabindex=\"0\"><figcaption>消息推送表</figcaption></figure>\n<p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。</p>\n<h2>消息推送常见方案</h2>\n<h3>短轮询</h3>\n<p><strong>轮询(polling)</strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p>\n<p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p>\n<p>一个简单的 JS 定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p>\n<div class=\"language-typescript\" data-ext=\"ts\" data-title=\"ts\"><pre class=\"language-typescript\"><code><span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 方法请求</span>\n  <span class=\"token function\">messageCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>code <span class=\"token operator\">===</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>messageCount <span class=\"token operator\">=</span> res<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p>\n<h3>长轮询</h3>\n<p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。</p>\n<p><a href=\"https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg\" target=\"_blank\" rel=\"noopener noreferrer\">Nacos 配置中心交互模型是 push 还是 pull？</a>一文中我详细介绍过 Nacos 长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。</p>\n<p>长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，如果服务端的数据没有发生变更，会 一直 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。</p>\n<p>这次我使用 Apollo 配置中心实现长轮询的方式，应用了一个类<code>DeferredResult</code>，它是在 Servlet3.0 后经过 Spring 封装提供的一种异步请求机制，直意就是延迟结果。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192386.png\" alt=\"长轮询示意图\" tabindex=\"0\"><figcaption>长轮询示意图</figcaption></figure>\n<p><code>DeferredResult</code>可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用<code>DeferredResult.setResult(200)</code>提交响应结果。</p>\n<p>下边我们用长轮询来实现消息推送。</p>\n<p>因为一个 ID 可能会被多个长轮询请求监听，所以我采用了 Guava 包提供的<code>Multimap</code>结构存放长轮询，一个 key 可以对应多个 value。一旦监听到 key 发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token annotation punctuation\">@Controller</span>\n<span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/polling\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PollingController</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// 存放监听某个Id的长轮询集合</span>\n    <span class=\"token comment\">// 线程同步结构</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Multimap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">DeferredResult</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> watchRequests <span class=\"token operator\">=</span> <span class=\"token class-name\">Multimaps</span><span class=\"token punctuation\">.</span><span class=\"token function\">synchronizedMultimap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HashMultimap</span><span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 设置监听\n     */</span>\n    <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span>path <span class=\"token operator\">=</span> <span class=\"token string\">\"watch/{id}\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@ResponseBody</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">DeferredResult</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">watch</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@PathVariable</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 延迟对象设置超时时间</span>\n        <span class=\"token class-name\">DeferredResult</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span></span> deferredResult <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DeferredResult</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token constant\">TIME_OUT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 异步请求完成时移除 key，防止内存溢出</span>\n        deferredResult<span class=\"token punctuation\">.</span><span class=\"token function\">onCompletion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-&gt;</span> <span class=\"token punctuation\">{</span>\n            watchRequests<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> deferredResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 注册长轮询请求</span>\n        watchRequests<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> deferredResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> deferredResult<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 变更数据\n     */</span>\n    <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span>path <span class=\"token operator\">=</span> <span class=\"token string\">\"publish/{id}\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@ResponseBody</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">publish</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@PathVariable</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 数据变更 取出监听ID的所有长轮询请求，并一一响应处理</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>watchRequests<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">DeferredResult</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> deferredResults <span class=\"token operator\">=</span> watchRequests<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">DeferredResult</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span></span> deferredResult <span class=\"token operator\">:</span> deferredResults<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                deferredResult<span class=\"token punctuation\">.</span><span class=\"token function\">setResult</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我更新了\"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"success\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre></div><p>当请求超过设置的超时时间，会抛出<code>AsyncRequestTimeoutException</code>异常，这里直接用<code>@ControllerAdvice</code>全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。</p>\n<div class=\"language-kotlin\" data-ext=\"kt\" data-title=\"kt\"><pre class=\"language-kotlin\"><code><span class=\"token annotation builtin\">@ControllerAdvice</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> AsyncRequestTimeoutHandler <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation builtin\">@ResponseStatus</span><span class=\"token punctuation\">(</span>HttpStatus<span class=\"token punctuation\">.</span>NOT_MODIFIED<span class=\"token punctuation\">)</span>\n    <span class=\"token annotation builtin\">@ResponseBody</span>\n    <span class=\"token annotation builtin\">@ExceptionHandler</span><span class=\"token punctuation\">(</span>AsyncRequestTimeoutException<span class=\"token punctuation\">.</span>class<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">asyncRequestTimeoutHandler</span><span class=\"token punctuation\">(</span>AsyncRequestTimeoutException e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"异步请求超时\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"304\"</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>我们来测试一下，首先页面发起长轮询请求<code>/polling/watch/10086</code>监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据<code>/polling/publish/10086</code>，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。</p>\n<p>长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。</p>\n<h3>iframe 流</h3>\n<p>iframe 流就是在页面中插入一个隐藏的<code>&lt;iframe&gt;</code>标签，通过在<code>src</code>中请求消息数量 API 接口，由此在服务端和客户端之间创建一条长连接，服务端持续向<code>iframe</code>传输数据。</p>\n<p>传输的数据通常是 HTML、或是内嵌的 JavaScript 脚本，来达到实时更新页面的效果。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192388.png\" alt=\"iframe 流示意图\" tabindex=\"0\"><figcaption>iframe 流示意图</figcaption></figure>\n<p>这种方式实现简单，前端只要一个<code>&lt;iframe&gt;</code>标签搞定了</p>\n<div class=\"language-html\" data-ext=\"html\" data-title=\"html\"><pre class=\"language-html\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>iframe</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/iframe/message<span class=\"token punctuation\">\"</span></span> <span class=\"token special-attr\"><span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value css language-css\"><span class=\"token property\">display</span><span class=\"token punctuation\">:</span>none</span><span class=\"token punctuation\">\"</span></span></span><span class=\"token punctuation\">&gt;</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>iframe</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre></div><p>服务端直接组装 HTML、JS 脚本数据向 response 写入就行了</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token annotation punctuation\">@Controller</span>\n<span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/iframe\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">IframeController</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span>path <span class=\"token operator\">=</span> <span class=\"token string\">\"message\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">message</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletResponse</span> response<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            response<span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Pragma\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"no-cache\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            response<span class=\"token punctuation\">.</span><span class=\"token function\">setDateHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Expires\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            response<span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cache-Control\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"no-cache,no-store\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            response<span class=\"token punctuation\">.</span><span class=\"token function\">setStatus</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletResponse</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SC_OK</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            response<span class=\"token punctuation\">.</span><span class=\"token function\">getWriter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" &lt;script type=\\\"text/javascript\\\"&gt;\\n\"</span> <span class=\"token operator\">+</span>\n                    <span class=\"token string\">\"parent.document.getElementById('clock').innerHTML = \\\"\"</span> <span class=\"token operator\">+</span> count<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\\";\"</span> <span class=\"token operator\">+</span>\n                    <span class=\"token string\">\"parent.document.getElementById('count').innerHTML = \\\"\"</span> <span class=\"token operator\">+</span> count<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\\";\"</span> <span class=\"token operator\">+</span>\n                    <span class=\"token string\">\"&lt;/script&gt;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>iframe 流的服务器开销很大，而且 IE、Chrome 等浏览器一直会处于 loading 状态，图标会不停旋转，简直是强迫症杀手。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192389.png\" alt=\"iframe 流效果\" tabindex=\"0\"><figcaption>iframe 流效果</figcaption></figure>\n<p>iframe 流非常不友好，强烈不推荐。</p>\n<h3>SSE (我的方式)</h3>\n<p>很多人可能不知道，服务端向客户端推送消息，其实除了可以用<code>WebSocket</code>这种耳熟能详的机制外，还有一种服务器发送事件(Server-Sent Events)，简称 SSE。这是一种服务器端到客户端(浏览器)的单向消息推送。</p>\n<p>SSE 基于 HTTP 协议的，我们知道一般意义上的 HTTP 协议是无法做到服务端主动向客户端推送消息的，但 SSE 是个例外，它变换了一种思路。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192390.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>SSE 在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是<code>text/event-stream</code>类型的数据流信息，在有数据变更时从服务器流式传输到客户端。</p>\n<p>整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192391.png\" alt=\"SSE 示意图\" tabindex=\"0\"><figcaption>SSE 示意图</figcaption></figure>\n<p>SSE 与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p>\n<ul>\n<li>SSE 是基于 HTTP 协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket 需单独服务器来处理协议。</li>\n<li>SSE 单向通信，只能由服务端向客户端单向通信；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。</li>\n<li>SSE 实现简单开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。</li>\n<li>SSE 默认支持断线重连；WebSocket 则需要自己实现。</li>\n<li>SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。</li>\n</ul>\n<p><strong>SSE 与 WebSocket 该如何选择？</strong></p>\n<blockquote>\n<p>技术并没有好坏之分，只有哪个更合适</p>\n</blockquote>\n<p>SSE 好像一直不被大家所熟知，一部分原因是出现了 WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p>\n<p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。</p>\n<p>前端只需进行一次 HTTP 请求，带上唯一 ID，打开事件流，监听服务端推送的事件就可以了</p>\n<div class=\"language-javascript\" data-ext=\"js\" data-title=\"js\"><pre class=\"language-javascript\"><code><span class=\"token operator\">&lt;</span>script<span class=\"token operator\">&gt;</span>\n    <span class=\"token keyword\">let</span> source <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> userId <span class=\"token operator\">=</span> <span class=\"token number\">7777</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>EventSource<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 建立连接</span>\n        source <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">EventSource</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://localhost:7777/sse/sub/'</span><span class=\"token operator\">+</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setMessageInnerHTML</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"连接用户=\"</span> <span class=\"token operator\">+</span> userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token doc-comment comment\">/**\n         * 连接一旦建立，就会触发open事件\n         * 另一种写法：source.onopen = function (event) <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n         */</span>\n        source<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'open'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setMessageInnerHTML</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"建立连接。。。\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token doc-comment comment\">/**\n         * 客户端收到服务器发来的数据\n         * 另一种写法：source.onmessage = function (event) <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n         */</span>\n        source<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setMessageInnerHTML</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setMessageInnerHTML</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"你的浏览器不支持SSE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">&gt;</span>\n</code></pre></div><p>服务端的实现更简单，创建一个<code>SseEmitter</code>对象放入<code>sseEmitterMap</code>进行管理</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">SseEmitter</span><span class=\"token punctuation\">&gt;</span></span> sseEmitterMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token doc-comment comment\">/**\n * 创建连接\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">SseEmitter</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> userId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 设置超时时间，0表示不过期。默认30秒</span>\n        <span class=\"token class-name\">SseEmitter</span> sseEmitter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SseEmitter</span><span class=\"token punctuation\">(</span><span class=\"token number\">0L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 注册回调</span>\n        sseEmitter<span class=\"token punctuation\">.</span><span class=\"token function\">onCompletion</span><span class=\"token punctuation\">(</span><span class=\"token function\">completionCallBack</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sseEmitter<span class=\"token punctuation\">.</span><span class=\"token function\">onError</span><span class=\"token punctuation\">(</span><span class=\"token function\">errorCallBack</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sseEmitter<span class=\"token punctuation\">.</span><span class=\"token function\">onTimeout</span><span class=\"token punctuation\">(</span><span class=\"token function\">timeoutCallBack</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sseEmitterMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">,</span> sseEmitter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        count<span class=\"token punctuation\">.</span><span class=\"token function\">getAndIncrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> sseEmitter<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"创建新的sse连接异常，当前用户：{}\"</span><span class=\"token punctuation\">,</span> userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token doc-comment comment\">/**\n * 给指定用户发送消息\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sendMessage</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> userId<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sseEmitterMap<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            sseEmitterMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            log<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"用户[{}]推送异常:{}\"</span><span class=\"token punctuation\">,</span> userId<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">removeUser</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><strong>注意：</strong> SSE 不支持 IE 浏览器，对其他主流浏览器兼容性做的还不错。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192393.png\" alt=\"SSE 兼容性\" tabindex=\"0\"><figcaption>SSE 兼容性</figcaption></figure>\n<h3>Websocket</h3>\n<p>Websocket 应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲 SSE 的时候也和 Websocket 进行过比较。</p>\n<p>是一种在 TCP 连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192394.png\" alt=\"Websocket 示意图\" tabindex=\"0\"><figcaption>Websocket 示意图</figcaption></figure>\n<p>SpringBoot 整合 Websocket，先引入 Websocket 相关的工具包，和 SSE 相比额外的开发成本。</p>\n<div class=\"language-xml\" data-ext=\"xml\" data-title=\"xml\"><pre class=\"language-xml\"><code><span class=\"token comment\">&lt;!-- 引入websocket --&gt;</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>spring-boot-starter-websocket<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre></div><p>服务端使用<code>@ServerEndpoint</code>注解标注当前类为一个 WebSocket 服务器，客户端可以通过<code>ws://localhost:7777/webSocket/10086</code>来连接到 WebSocket 服务器端。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token annotation punctuation\">@Slf4j</span>\n<span class=\"token annotation punctuation\">@ServerEndpoint</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/websocket/{userId}\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WebSocketServer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//与某个客户端的连接会话，需要通过它来给客户端发送数据</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Session</span> session<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">CopyOnWriteArraySet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">WebSocketServer</span><span class=\"token punctuation\">&gt;</span></span> webSockets <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CopyOnWriteArraySet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 用来存在线连接数</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Session</span><span class=\"token punctuation\">&gt;</span></span> sessionPool <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Session</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token doc-comment comment\">/**\n     * 链接成功调用的方法\n     */</span>\n    <span class=\"token annotation punctuation\">@OnOpen</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onOpen</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Session</span> session<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@PathParam</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"userId\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> userId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>session <span class=\"token operator\">=</span> session<span class=\"token punctuation\">;</span>\n            webSockets<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            sessionPool<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">,</span> session<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"websocket消息: 有新的连接，总数为:\"</span> <span class=\"token operator\">+</span> webSockets<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token doc-comment comment\">/**\n     * 收到客户端消息后调用的方法\n     */</span>\n    <span class=\"token annotation punctuation\">@OnMessage</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onMessage</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"websocket消息: 收到客户端消息:\"</span> <span class=\"token operator\">+</span> message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token doc-comment comment\">/**\n     * 此为单点消息\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sendOneMessage</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> userId<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Session</span> session <span class=\"token operator\">=</span> sessionPool<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>session <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> session<span class=\"token punctuation\">.</span><span class=\"token function\">isOpen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"websocket消: 单点消息:\"</span> <span class=\"token operator\">+</span> message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                session<span class=\"token punctuation\">.</span><span class=\"token function\">getAsyncRemote</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sendText</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>前端初始化打开 WebSocket 连接，并监听连接状态，接收服务端数据或向服务端发送数据。</p>\n<div class=\"language-javascript\" data-ext=\"js\" data-title=\"js\"><pre class=\"language-javascript\"><code><span class=\"token operator\">&lt;</span>script<span class=\"token operator\">&gt;</span>\n    <span class=\"token keyword\">var</span> ws <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebSocket</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ws://localhost:7777/webSocket/10086'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 获取连接状态</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ws连接状态：'</span> <span class=\"token operator\">+</span> ws<span class=\"token punctuation\">.</span>readyState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//监听是否连接成功</span>\n    ws<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onopen</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ws连接状态：'</span> <span class=\"token operator\">+</span> ws<span class=\"token punctuation\">.</span>readyState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//连接成功则发送一个数据</span>\n        ws<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 接听服务器发回的信息并处理展示</span>\n    ws<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onmessage</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'接收到来自服务器的消息：'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//完成通信后关闭WebSocket连接</span>\n        ws<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 监听连接关闭事件</span>\n    ws<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onclose</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 监听整个过程中websocket的状态</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ws连接状态：'</span> <span class=\"token operator\">+</span> ws<span class=\"token punctuation\">.</span>readyState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 监听并处理error事件</span>\n    ws<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onerror</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">sendMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> content <span class=\"token operator\">=</span> <span class=\"token function\">$</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"#message\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        $<span class=\"token punctuation\">.</span><span class=\"token function\">ajax</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n            <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'/socket/publish?userId=10086&amp;message='</span> <span class=\"token operator\">+</span> content<span class=\"token punctuation\">,</span>\n            <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token literal-property property\">data</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token string-property property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"7777\"</span><span class=\"token punctuation\">,</span> <span class=\"token string-property property\">\"content\"</span><span class=\"token operator\">:</span> content <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token function-variable function\">success</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">&gt;</span>\n</code></pre></div><p>页面初始化建立 WebSocket 连接，之后就可以进行双向通信了，效果还不错。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192395.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>MQTT</h3>\n<p><strong>什么是 MQTT 协议？</strong></p>\n<p>MQTT (Message Queue Telemetry Transport)是一种基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet of Thing）中的一个标准传输协议。</p>\n<p>该协议将消息的发布者（publisher）与订阅者（subscriber）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的 MQ 有点类似。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000022986325.png\" alt=\"MQTT 协议示例\" tabindex=\"0\"><figcaption>MQTT 协议示例</figcaption></figure>\n<p>TCP 协议位于传输层，MQTT 协议位于应用层，MQTT 协议构建于 TCP/IP 协议上，也就是说只要支持 TCP/IP 协议栈的地方，都可以使用 MQTT 协议。</p>\n<p><strong>为什么要用 MQTT 协议？</strong></p>\n<p>MQTT 协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 HTTP 协议呢？</p>\n<ul>\n<li>首先 HTTP 协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合 IOT 应用程序。</li>\n<li>HTTP 是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li>\n<li>通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP 要实现这样的功能不但很困难，而且成本极高。</li>\n</ul>\n<p>具体的 MQTT 协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。</p>\n<ul>\n<li>MQTT 协议的介绍：<a href=\"https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA\" target=\"_blank\" rel=\"noopener noreferrer\">我也没想到 SpringBoot + RabbitMQ 做智能家居，会这么简单</a></li>\n<li>MQTT 实现消息推送：<a href=\"https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg\" target=\"_blank\" rel=\"noopener noreferrer\">未读消息（小红点），前端 与 RabbitMQ 实时消息推送实践，贼简单~</a></li>\n</ul>\n<h2>总结</h2>\n<blockquote>\n<p>以下内容为 JavaGuide 补充</p>\n</blockquote>\n<p>|           | 介绍                                                                                                          | 优点                   | 缺点                                                 |\n|</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "[E] 移动零",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/algorithm/two-pointers/move-zeros.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/algorithm/two-pointers/move-zeros.html",
      "summary": "LeetCode地址：移动零 题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2: 输入: nums = [0] 输出: [0] 思路 “同时保...",
      "content_html": "<p>LeetCode地址：<a href=\"https://leetcode.cn/problems/move-zeroes\" target=\"_blank\" rel=\"noopener noreferrer\">移动零</a></p>\n<h2>题目</h2>\n<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>\n<p>示例 1:</p>\n<p>输入: nums = [0,1,0,3,12]\n输出: [1,3,12,0,0]</p>\n<p>示例 2:</p>\n<p>输入: nums = [0]\n输出: [0]</p>\n<h2>思路</h2>\n<ol>\n<li>“同时保持非零元素的相对顺序”：说明不能将该数组进行排序了，因为排序可能会打乱数组的相对顺序</li>\n<li>“原地对数组进行操作”：说明就要用交换的方式来移动0了</li>\n</ol>\n<h2>题解</h2>\n<h3>双指针（一次遍历）</h3>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">moveZeroes</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> right <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> right<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                nums<span class=\"token punctuation\">[</span>left<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><h3>移动非0再补0（两次遍历）</h3>\n<p>巧妙地利用指针标记非0元素个数的同时，指向最后一个非0元素的下标</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">moveZeroes</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 第一次遍历的时候，只要是非0的统统都赋给nums[nonZero]，并且记录非0的个数，</span>\n        <span class=\"token comment\">// 遍历完后，nonZero指针的下标指向的是最后一个非0元素的下标</span>\n        <span class=\"token keyword\">int</span> nonZero <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num <span class=\"token operator\">:</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                nums<span class=\"token punctuation\">[</span>nonZero<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> num<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 非0元素统计完了，剩下的都是0了</span>\n        <span class=\"token comment\">// 第二次遍历把末尾的元素都赋为0即可</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> nonZero<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>",
      "date_published": "2024-03-01T00:00:00.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "TwoPointers"
      ]
    },
    {
      "title": "MongoDB常见面试题总结（上）",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mongodb/mongodb-questions-01.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mongodb/mongodb-questions-01.html",
      "summary": "少部分内容参考了 MongoDB 官方文档的描述，在此说明一下。 MongoDB 基础 MongoDB 是什么？ MongoDB 是一个基于 分布式文件存储 的开源 NoSQL 数据库系统，由 C++ 编写的。MongoDB 提供了 面向文档 的存储方式，操作起来比较简单和容易，支持“无模式”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 文...",
      "content_html": "<blockquote>\n<p>少部分内容参考了 MongoDB 官方文档的描述，在此说明一下。</p>\n</blockquote>\n<h2>MongoDB 基础</h2>\n<h3>MongoDB 是什么？</h3>\n<p>MongoDB 是一个基于 <strong>分布式文件存储</strong> 的开源 NoSQL 数据库系统，由 <strong>C++</strong> 编写的。MongoDB 提供了 <strong>面向文档</strong> 的存储方式，操作起来比较简单和容易，支持“<strong>无模式</strong>”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 <strong>文档类型数据库</strong> 。</p>\n<p>在高负载的情况下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点/实例，以保证服务性能和可用性。在许多场景下，MongoDB 可以用于代替传统的关系型数据库或键/值存储方式，皆在为 Web 应用提供可扩展的高可用高性能数据存储解决方案。</p>\n<h3>MongoDB 的存储结构是什么？</h3>\n<p>MongoDB 的存储结构区别于传统的关系型数据库，主要由如下三个单元组成：</p>\n<ul>\n<li><strong>文档（Document）</strong>：MongoDB 中最基本的单元，由 BSON 键值对（key-value）组成，类似于关系型数据库中的行（Row）。</li>\n<li><strong>集合（Collection）</strong>：一个集合可以包含多个文档，类似于关系型数据库中的表（Table）。</li>\n<li><strong>数据库（Database）</strong>：一个数据库中可以包含多个集合，可以在 MongoDB 中创建多个数据库，类似于关系型数据库中的数据库（Database）。</li>\n</ul>\n<p>也就是说，MongoDB 将数据记录存储为文档 （更具体来说是<a href=\"https://www.mongodb.com/docs/manual/core/document/#std-label-bson-document-format\" target=\"_blank\" rel=\"noopener noreferrer\">BSON 文档</a>），这些文档在集合中聚集在一起，数据库中存储一个或多个文档集合。</p>\n<p><strong>SQL 与 MongoDB 常见术语对比</strong>：</p>\n<p>| SQL                      | MongoDB                         |\n|</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/mongodb/crud-annotated-document..png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MongoDB常见面试题总结（下）",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mongodb/mongodb-questions-02.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mongodb/mongodb-questions-02.html",
      "summary": "MongoDB 索引 MongoDB 索引有什么用? 和关系型数据库类似，MongoDB 中也有索引。索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须执行 集合扫描 ，即扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量。并且，MongoDB 可以使...",
      "content_html": "<h2>MongoDB 索引</h2>\n<h3>MongoDB 索引有什么用?</h3>\n<p>和关系型数据库类似，MongoDB 中也有索引。索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须执行 <strong>集合扫描</strong> ，即扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量。并且，MongoDB 可以使用索引中的排序返回排序后的结果。</p>\n<p>虽然索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。在执行写入操作时，除了要更新文档之外，还必须更新索引，这必然会影响写入的性能。因此，当有大量写操作而读操作少时，或者不考虑读操作的性能时，都不推荐建立索引。</p>\n<h3>MongoDB 支持哪些类型的索引？</h3>\n<p><strong>MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</strong></p>\n<ul>\n<li><strong>单字段索引：</strong> 建立在单个字段上的索引，索引创建的排序顺序无所谓，MongoDB 可以头/尾开始遍历。</li>\n<li><strong>复合索引：</strong> 建立在多个字段上的索引，也可以称之为组合索引、联合索引。</li>\n<li><strong>多键索引</strong>：MongoDB 的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。</li>\n<li><strong>哈希索引</strong>：按数据的哈希值索引，用在哈希分片集群上。</li>\n<li><strong>文本索引：</strong> 支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。</li>\n<li><strong>地理位置索引：</strong> 基于经纬度的索引，适合 2D 和 3D 的位置查询。</li>\n<li><strong>唯一索引</strong>：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。</li>\n<li><strong>TTL 索引</strong>：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除。</li>\n<li>......</li>\n</ul>\n<h3>复合索引中字段的顺序有影响吗？</h3>\n<p>复合索引中字段的顺序非常重要，例如下图中的复合索引由<code>{userid:1, score:-1}</code>组成，则该复合索引首先按照<code>userid</code>升序排序；然后再每个<code>userid</code>的值内，再按照<code>score</code>降序排序。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/mongodb-composite-index.png\" alt=\"复合索引\" tabindex=\"0\"><figcaption>复合索引</figcaption></figure>\n<p>在复合索引中，按照何种方式排序，决定了该索引在查询中是否能被应用到。</p>\n<p>走复合索引的排序：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code>db<span class=\"token punctuation\">.</span>s2<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>{<span class=\"token string\">\"userid\"</span>: <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"score\"</span>: <span class=\"token operator\">-</span><span class=\"token number\">1</span>}<span class=\"token punctuation\">)</span>\ndb<span class=\"token punctuation\">.</span>s2<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>{<span class=\"token string\">\"userid\"</span>: <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"score\"</span>: <span class=\"token number\">1</span>}<span class=\"token punctuation\">)</span>\n</code></pre></div><p>不走复合索引的排序：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code>db<span class=\"token punctuation\">.</span>s2<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>{<span class=\"token string\">\"userid\"</span>: <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"score\"</span>: <span class=\"token number\">1</span>}<span class=\"token punctuation\">)</span>\ndb<span class=\"token punctuation\">.</span>s2<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>{<span class=\"token string\">\"userid\"</span>: <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"score\"</span>: <span class=\"token operator\">-</span><span class=\"token number\">1</span>}<span class=\"token punctuation\">)</span>\ndb<span class=\"token punctuation\">.</span>s2<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>{<span class=\"token string\">\"score\"</span>: <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"userid\"</span>: <span class=\"token operator\">-</span><span class=\"token number\">1</span>}<span class=\"token punctuation\">)</span>\ndb<span class=\"token punctuation\">.</span>s2<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>{<span class=\"token string\">\"score\"</span>: <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"userid\"</span>: <span class=\"token number\">1</span>}<span class=\"token punctuation\">)</span>\ndb<span class=\"token punctuation\">.</span>s2<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>{<span class=\"token string\">\"score\"</span>: <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"userid\"</span>: <span class=\"token operator\">-</span><span class=\"token number\">1</span>}<span class=\"token punctuation\">)</span>\ndb<span class=\"token punctuation\">.</span>s2<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>{<span class=\"token string\">\"score\"</span>: <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"userid\"</span>: <span class=\"token number\">1</span>}<span class=\"token punctuation\">)</span>\n</code></pre></div><p>我们可以通过 explain 进行分析：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code>db<span class=\"token punctuation\">.</span>s2<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>{<span class=\"token string\">\"score\"</span>: <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"userid\"</span>: <span class=\"token number\">1</span>}<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">explain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre></div><h3>复合索引遵循左前缀原则吗？</h3>\n<p><strong>MongoDB 的复合索引遵循左前缀原则</strong>：拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。比如说，有一个类似 <code>{a: 1, b: 1, c: 1, ..., z: 1}</code> 这样的索引，那么实际上也等于有了 <code>{a: 1}</code>、<code>{a: 1, b: 1}</code>、<code>{a: 1, b: 1, c: 1}</code> 等一系列索引，但是不会有 <code>{b: 1}</code> 这样的非左前缀的索引。</p>\n<h3>什么是 TTL 索引？</h3>\n<p>TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间 <code>expireAfterSeconds</code> ，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 <code>expireAfterSeconds</code> 属性外，和普通索引一样。</p>\n<p>数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。</p>\n<p><strong>TTL 索引运行原理</strong>：</p>\n<ul>\n<li>MongoDB 会开启一个后台线程读取该 TTL 索引的值来判断文档是否过期，但不会保证已过期的数据会立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。</li>\n<li>对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除是由主库删除后产生的 oplog 来做同步。</li>\n</ul>\n<p><strong>TTL 索引限制</strong>：</p>\n<ul>\n<li>TTL 索引是单字段索引。复合索引不支持 TTL</li>\n<li><code>_id</code>字段不支持 TTL 索引。</li>\n<li>无法在上限集合(Capped Collection)上创建 TTL 索引，因为 MongoDB 无法从上限集合中删除文档。</li>\n<li>如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。</li>\n</ul>\n<h3>什么是覆盖索引查询？</h3>\n<p>根据官方文档介绍，覆盖查询是以下的查询：</p>\n<ul>\n<li>所有的查询字段是索引的一部分。</li>\n<li>结果中返回的所有字段都在同一索引中。</li>\n<li>查询中没有字段等于<code>null</code>。</li>\n</ul>\n<p>由于所有出现在查询中的字段是索引的一部分， MongoDB 无需在整个数据文档中检索匹配查询条件和返回使用相同索引的查询结果。因为索引存在于内存中，从索引中获取数据比通过扫描文档读取数据要快得多。</p>\n<p>举个例子：我们有如下 <code>users</code> 集合:</p>\n<div class=\"language-json\" data-ext=\"json\" data-title=\"json\"><pre class=\"language-json\"><code><span class=\"token punctuation\">{</span>\n   <span class=\"token property\">\"_id\"</span><span class=\"token operator\">:</span> ObjectId(<span class=\"token string\">\"53402597d852426020000002\"</span>)<span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"contact\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"987654321\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"dob\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"01-01-1991\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"gender\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"M\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Tom Benzamin\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"user_name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"tombenzamin\"</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>我们在 <code>users</code> 集合中创建联合索引，字段为 <code>gender</code> 和 <code>user_name</code> :</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code>db<span class=\"token punctuation\">.</span>users<span class=\"token punctuation\">.</span>ensureIndex<span class=\"token punctuation\">(</span>{gender:<span class=\"token number\">1</span><span class=\"token punctuation\">,</span>user_name:<span class=\"token number\">1</span>}<span class=\"token punctuation\">)</span>\n</code></pre></div><p>现在，该索引会覆盖以下查询：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code>db<span class=\"token punctuation\">.</span>users<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span>{gender:<span class=\"token string\">\"M\"</span>}<span class=\"token punctuation\">,</span>{user_name:<span class=\"token number\">1</span><span class=\"token punctuation\">,</span>_id:<span class=\"token number\">0</span>}<span class=\"token punctuation\">)</span>\n</code></pre></div><p>为了让指定的索引覆盖查询，必须显式地指定 <code>_id: 0</code> 来从结果中排除 <code>_id</code> 字段，因为索引不包括 <code>_id</code> 字段。</p>\n<h2>MongoDB 高可用</h2>\n<h3>复制集群</h3>\n<h4>什么是复制集群？</h4>\n<p>MongoDB 的复制集群又称为副本集群，是一组维护相同数据集合的 mongod 进程。</p>\n<p>客户端连接到整个 Mongodb 复制集群，主节点机负责整个复制集群的写，从节点可以进行读操作，但默认还是主节点负责整个复制集群的读。主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</p>\n<p>通常来说，一个复制集群包含 1 个主节点（Primary），多个从节点（Secondary）以及零个或 1 个仲裁节点（Arbiter）。</p>\n<ul>\n<li><strong>主节点</strong>：整个集群的写操作入口，接收所有的写操作，并将集合所有的变化记录到操作日志中，即 oplog。主节点挂掉之后会自动选出新的主节点。</li>\n<li><strong>从节点</strong>：从主节点同步数据，在主节点挂掉之后选举新节点。不过，从节点可以配置成 0 优先级，阻止它在选举中成为主节点。</li>\n<li><strong>仲裁节点</strong>：这个是为了节约资源或者多机房容灾用，只负责主节点选举时投票不存数据，保证能有节点获得多数赞成票。</li>\n</ul>\n<p>下图是一个典型的三成员副本集群：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/replica-set-read-write-operations-primary.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>主节点与备节点之间是通过 <strong>oplog（操作日志）</strong> 来同步数据的。oplog 是 local 库下的一个特殊的 <strong>上限集合(Capped Collection)</strong> ，用来保存写操作所产生的增量日志，类似于 MySQL 中 的 Binlog。</p>\n<blockquote>\n<p>上限集合类似于定长的循环队列，数据顺序追加到集合的尾部，当集合空间达到上限时，它会覆盖集合中最旧的文档。上限集合的数据将会被顺序写入到磁盘的固定空间内，所以，I/O 速度非常快，如果不建立索引，性能更好。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/replica-set-primary-with-two-secondaries.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>当主节点上的一个写操作完成后，会向 oplog 集合写入一条对应的日志，而从节点则通过这个 oplog 不断拉取到新的日志，在本地进行回放以达到数据同步的目的。</p>\n<p>副本集最多有一个主节点。 如果当前主节点不可用，一个选举会抉择出新的主节点。MongoDB 的节点选举规则能够保证在 Primary 挂掉之后选取的新节点一定是集群中数据最全的一个。</p>\n<h4>为什么要用复制集群？</h4>\n<ul>\n<li><strong>实现 failover</strong>：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li>\n<li><strong>实现读写分离</strong>：我们可以设置从节点上可以读取数据，主节点负责写入数据，这样的话就实现了读写分离，减轻了主节点读写压力过大的问题。MongoDB 4.0 之前版本如果主库压力不大,不建议读写分离，因为写会阻塞读，除非业务对响应时间不是非常关注以及读取历史数据接受一定时间延迟。</li>\n</ul>\n<h3>分片集群</h3>\n<h4>什么是分片集群？</h4>\n<p>分片集群是 MongoDB 的分布式版本，相较副本集，分片集群数据被均衡的分布在不同分片中， 不仅大幅提升了整个集群的数据容量上限，也将读写的压力分散到不同分片，以解决副本集性能瓶颈的难题。</p>\n<p>MongoDB 的分片集群由如下三个部分组成（下图来源于<a href=\"https://www.mongodb.com/docs/manual/sharding/\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档对分片集群的介绍</a>）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/sharded-cluster-production-architecture.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<ul>\n<li><strong>Config Servers</strong>：配置服务器，本质上是一个 MongoDB 的副本集，负责存储集群的各种元数据和配置，如分片地址、Chunks 等</li>\n<li><strong>Mongos</strong>：路由服务，不存具体数据，从 Config 获取集群配置讲请求转发到特定的分片，并且整合分片结果返回给客户端。</li>\n<li><strong>Shard</strong>：每个分片是整体数据的一部分子集，从 MongoDB3.6 版本开始，每个 Shard 必须部署为副本集（replica set）架构</li>\n</ul>\n<h4>为什么要用分片集群？</h4>\n<p>随着系统数据量以及吞吐量的增长，常见的解决办法有两种：垂直扩展和水平扩展。</p>\n<p>垂直扩展通过增加单个服务器的能力来实现，比如磁盘空间、内存容量、CPU 数量等；水平扩展则通过将数据存储到多个服务器上来实现，根据需要添加额外的服务器以增加容量。</p>\n<p>类似于 Redis Cluster，MongoDB 也可以通过分片实现 <strong>水平扩展</strong> 。水平扩展这种方式更灵活，可以满足更大数据量的存储需求，支持更高吞吐量。并且，水平扩展所需的整体成本更低，仅仅需要相对较低配置的单机服务器即可，代价是增加了部署的基础设施和维护的复杂性。</p>\n<p>也就是说当你遇到如下问题时，可以使用分片集群解决：</p>\n<ul>\n<li>存储容量受单机限制，即磁盘资源遭遇瓶颈。</li>\n<li>读写能力受单机限制，可能是 CPU、内存或者网卡等资源遭遇瓶颈，导致读写能力无法扩展。</li>\n</ul>\n<h4>什么是分片键？</h4>\n<p><strong>分片键（Shard Key）</strong> 是数据分区的前提， 从而实现数据分发到不同服务器上，减轻服务器的负担。也就是说，分片键决定了集合内的文档如何在集群的多个分片间的分布状况。</p>\n<p>分片键就是文档里面的一个字段，但是这个字段不是普通的字段，有一定的要求：</p>\n<ul>\n<li>它必须在所有文档中都出现。</li>\n<li>它必须是集合的一个索引，可以是单索引或复合索引的前缀索引，不能是多索引、文本索引或地理空间位置索引。</li>\n<li>MongoDB 4.2 之前的版本，文档的分片键字段值不可变。MongoDB 4.2 版本开始，除非分片键字段是不可变的 <code>_id</code> 字段，否则您可以更新文档的分片键值。MongoDB 5.0 版本开始，实现了实时重新分片（live resharding），可以实现分片键的完全重新选择。</li>\n<li>它的大小不能超过 512 字节。</li>\n</ul>\n<h4>如何选择分片键？</h4>\n<p>选择合适的片键对 sharding 效率影响很大，主要基于如下四个因素（摘自<a href=\"https://cloud.tencent.com/document/product/240/44611\" target=\"_blank\" rel=\"noopener noreferrer\">分片集群使用注意事项 - - 腾讯云文档</a>）：</p>\n<ul>\n<li><strong>取值基数</strong> 取值基数建议尽可能大，如果用小基数的片键，因为备选值有限，那么块的总数量就有限，随着数据增多，块的大小会越来越大，导致水平扩展时移动块会非常困难。 例如：选择年龄做一个基数，范围最多只有 100 个，随着数据量增多，同一个值分布过多时，导致 chunck 的增长超出 chuncksize 的范围，引起 jumbo chunk，从而无法迁移，导致数据分布不均匀，性能瓶颈。</li>\n<li><strong>取值分布</strong> 取值分布建议尽量均匀，分布不均匀的片键会造成某些块的数据量非常大，同样有上面数据分布不均匀，性能瓶颈的问题。</li>\n<li><strong>查询带分片</strong> 查询时建议带上分片，使用分片键进行条件查询时，mongos 可以直接定位到具体分片，否则 mongos 需要将查询分发到所有分片，再等待响应返回。</li>\n<li><strong>避免单调递增或递减</strong> 单调递增的 sharding key，数据文件挪动小，但写入会集中，导致最后一篇的数据量持续增大，不断发生迁移，递减同理。</li>\n</ul>\n<p>综上，在选择片键时要考虑以上 4 个条件，尽可能满足更多的条件，才能降低 MoveChunks 对性能的影响，从而获得最优的性能体验。</p>\n<h4>分片策略有哪些？</h4>\n<p>MongoDB 支持两种分片算法来满足不同的查询需求（摘自<a href=\"https://help.aliyun.com/document_detail/64561.html?spm=a2c4g.11186623.0.0.3121565eQhUGGB#h2--shard-key-3\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 分片集群介绍 - 阿里云文档</a>）：</p>\n<p><strong>1、基于范围的分片</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/example-of-scope-based-sharding.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>MongoDB 按照分片键（Shard Key）的值的范围将数据拆分为不同的块（Chunk），每个块包含了一段范围内的数据。当分片键的基数大、频率低且值非单调变更时，范围分片更高效。</p>\n<ul>\n<li>优点：Mongos 可以快速定位请求需要的数据，并将请求转发到相应的 Shard 节点中。</li>\n<li>缺点：可能导致数据在 Shard 节点上分布不均衡，容易造成读写热点，且不具备写分散性。</li>\n<li>适用场景：分片键的值不是单调递增或单调递减、分片键的值基数大且重复的频率低、需要范围查询等业务场景。</li>\n</ul>\n<p><strong>2、基于 Hash 值的分片</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/example-of-hash-based-sharding.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>MongoDB 计算单个字段的哈希值作为索引值，并以哈希值的范围将数据拆分为不同的块（Chunk）。</p>\n<ul>\n<li>优点：可以将数据更加均衡地分布在各 Shard 节点中，具备写分散性。</li>\n<li>缺点：不适合进行范围查询，进行范围查询时，需要将读请求分发到所有的 Shard 节点。</li>\n<li>适用场景：分片键的值存在单调递增或递减、片键的值基数大且重复的频率低、需要写入的数据随机分发、数据读取随机性较大等业务场景。</li>\n</ul>\n<p>除了上述两种分片策略，您还可以配置 <strong>复合片键</strong> ，例如由一个低基数的键和一个单调递增的键组成。</p>\n<h4>分片数据如何存储？</h4>\n<p><strong>Chunk（块）</strong> 是 MongoDB 分片集群的一个核心概念，其本质上就是由一组 Document 组成的逻辑数据单元。每个 Chunk 包含一定范围片键的数据，互不相交且并集为全部数据，即离散数学中<strong>划分</strong>的概念。</p>\n<p>分片集群不会记录每条数据在哪个分片上，而是记录 Chunk 在哪个分片上一级这个 Chunk 包含哪些数据。</p>\n<p>默认情况下，一个 Chunk 的最大值默认为 64MB（可调整，取值范围为 1~1024 MB。如无特殊需求，建议保持默认值），进行数据插入、更新、删除时，如果此时 Mongos 感知到了目标 Chunk 的大小或者其中的数据量超过上限，则会触发 <strong>Chunk 分裂</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/chunk-splitting-shard-a.png\" alt=\"Chunk 分裂\" tabindex=\"0\"><figcaption>Chunk 分裂</figcaption></figure>\n<p>数据的增长会让 Chunk 分裂得越来越多。这个时候，各个分片上的 Chunk 数量可能会不平衡。Mongos 中的 <strong>均衡器(Balancer)</strong> 组件就会执行自动平衡，尝试使各个 Shard 上 Chunk 的数量保持均衡，这个过程就是 <strong>再平衡（Rebalance）</strong>。默认情况下，数据库和集合的 Rebalance 是开启的。</p>\n<p>如下图所示，随着数据插入，导致 Chunk 分裂，让 AB 两个分片有 3 个 Chunk，C 分片只有一个，这个时候就会把 B 分配的迁移一个到 C 分片实现集群数据均衡。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/mongo-reblance-three-shards.png\" alt=\"Chunk 迁移\" tabindex=\"0\"><figcaption>Chunk 迁移</figcaption></figure>\n<blockquote>\n<p>Balancer 是 MongoDB 的一个运行在 Config Server 的 Primary 节点上(自 MongoDB 3.4 版本起)的后台进程，它监控每个分片上 Chunk 数量，并在某个分片上 Chunk 数量达到阈值进行迁移。</p>\n</blockquote>\n<p>Chunk 只会分裂，不会合并，即使 chunkSize 的值变大。</p>\n<p>Rebalance 操作是比较耗费系统资源的，我们可以通过在业务低峰期执行、预分片或者设置 Rebalance 时间窗等方式来减少其对 MongoDB 正常使用所带来的影响。</p>\n<h4>Chunk 迁移原理是什么？</h4>\n<p>关于 Chunk 迁移原理的详细介绍，推荐阅读 MongoDB 中文社区的<a href=\"https://mongoing.com/archives/77479\" target=\"_blank\" rel=\"noopener noreferrer\">一文读懂 MongoDB chunk 迁移</a>这篇文章。</p>\n<h2>学习资料推荐</h2>\n<ul>\n<li><a href=\"https://docs.mongoing.com/\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 中文手册|官方文档中文版</a>（推荐）：基于 4.2 版本，不断与官方最新版保持同步。</li>\n<li><a href=\"https://mongoing.com/archives/docs/mongodb%e5%88%9d%e5%ad%a6%e8%80%85%e6%95%99%e7%a8%8b/mongodb%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e9%9b%86%e5%90%88\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 初学者教程——7 天学习 MongoDB</a>：快速入门。</li>\n<li><a href=\"https://www.cnblogs.com/dxflqm/p/16643981.html\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot 整合 MongoDB 实战 - 2022</a>：很不错的一篇 MongoDB 入门文章，主要围绕 MongoDB 的 Java 客户端使用进行基本的增删改查操作介绍。</li>\n</ul>\n<h2>参考</h2>\n<ul>\n<li>MongoDB 官方文档（主要参考资料，以官方文档为准）：<a href=\"https://www.mongodb.com/docs/manual/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/docs/manual/</a></li>\n<li>《MongoDB 权威指南》</li>\n<li>Indexes - MongoDB 官方文档：<a href=\"https://www.mongodb.com/docs/manual/indexes/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/docs/manual/indexes/</a></li>\n<li>MongoDB - 索引知识 - 程序员翔仔 - 2022：<a href=\"https://fatedeity.cn/posts/database/mongodb-index-knowledge.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://fatedeity.cn/posts/database/mongodb-index-knowledge.html</a></li>\n<li>MongoDB - 索引: <a href=\"https://www.cnblogs.com/Neeo/articles/14325130.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/Neeo/articles/14325130.html</a></li>\n<li>Sharding - MongoDB 官方文档：<a href=\"https://www.mongodb.com/docs/manual/sharding/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/docs/manual/sharding/</a></li>\n<li>MongoDB 分片集群介绍 - 阿里云文档：<a href=\"https://help.aliyun.com/document_detail/64561.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://help.aliyun.com/document_detail/64561.html</a></li>\n<li>分片集群使用注意事项 - - 腾讯云文档：<a href=\"https://cloud.tencent.com/document/product/240/44611\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.tencent.com/document/product/240/44611</a></li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/mongodb/mongodb-composite-index.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "一千行 MySQL 学习笔记",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/a-thousand-lines-of-mysql-study-notes.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/a-thousand-lines-of-mysql-study-notes.html",
      "summary": "原文地址：https://shockerli.net/post/1000-line-mysql-note/ ，JavaGuide 对本文进行了简答排版，新增了目录。 非常不错的总结，强烈建议保存下来，需要的时候看一看。 基本操作 数据库操作 表的操作 数据操作 字符集编码 数据类型(列类型) 列属性(列约束) 建表规范 SELECT UNION 子查询...",
      "content_html": "<blockquote>\n<p>原文地址：https://shockerli.net/post/1000-line-mysql-note/ ，JavaGuide 对本文进行了简答排版，新增了目录。</p>\n</blockquote>\n<p>非常不错的总结，强烈建议保存下来，需要的时候看一看。</p>\n<h3>基本操作</h3>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token comment\">/* Windows服务 */</span>\n<span class=\"token comment\">-- 启动 MySQL</span>\n\t\t\tnet <span class=\"token keyword\">start</span> mysql\n<span class=\"token comment\">-- 创建Windows服务</span>\n\t\t\t\tsc <span class=\"token keyword\">create</span> mysql binPath<span class=\"token operator\">=</span> mysqld_bin_path<span class=\"token punctuation\">(</span>注意：等号与值之间有空格<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">/* 连接与断开服务器 */</span>\n<span class=\"token comment\">-- 连接 MySQL</span>\n\t\t\t\tmysql <span class=\"token operator\">-</span>h 地址 <span class=\"token operator\">-</span>P 端口 <span class=\"token operator\">-</span>u 用户名 <span class=\"token operator\">-</span>p 密码\n<span class=\"token comment\">-- 显示哪些线程正在运行</span>\n\t\t\t\t<span class=\"token keyword\">SHOW</span> PROCESSLIST\n<span class=\"token comment\">-- 显示系统变量信息</span>\n\t\t\t\t<span class=\"token keyword\">SHOW</span> VARIABLES\n</code></pre></div><h3>数据库操作</h3>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token comment\">/* 数据库操作 */</span>\n<span class=\"token comment\">-- 查看当前数据库</span>\n    <span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DATABASE</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 显示当前时间、用户名、数据库版本</span>\n    <span class=\"token keyword\">SELECT</span> <span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> version<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 创建库</span>\n    <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span><span class=\"token punctuation\">[</span> <span class=\"token keyword\">IF</span> <span class=\"token operator\">NOT</span> <span class=\"token keyword\">EXISTS</span><span class=\"token punctuation\">]</span> 数据库名 数据库选项\n    数据库选项：\n        <span class=\"token keyword\">CHARACTER</span> <span class=\"token keyword\">SET</span> charset_name\n        <span class=\"token keyword\">COLLATE</span> collation_name\n<span class=\"token comment\">-- 查看已有库</span>\n    <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">DATABASES</span><span class=\"token punctuation\">[</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'PATTERN'</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">-- 查看当前库信息</span>\n    <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DATABASE</span> 数据库名\n<span class=\"token comment\">-- 修改库的选项信息</span>\n    <span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">DATABASE</span> 库名 选项信息\n<span class=\"token comment\">-- 删除库</span>\n    <span class=\"token keyword\">DROP</span> <span class=\"token keyword\">DATABASE</span><span class=\"token punctuation\">[</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span><span class=\"token punctuation\">]</span> 数据库名\n        同时删除该数据库相关的目录及其目录内容\n</code></pre></div><h3>表的操作</h3>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token comment\">/* 表的操作  */</span>\n<span class=\"token comment\">-- 创建表</span>\n    <span class=\"token keyword\">CREATE</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">TEMPORARY</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">TABLE</span><span class=\"token punctuation\">[</span> <span class=\"token keyword\">IF</span> <span class=\"token operator\">NOT</span> <span class=\"token keyword\">EXISTS</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>库名<span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span>表名 <span class=\"token punctuation\">(</span> 表的结构定义 <span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span> 表选项<span class=\"token punctuation\">]</span>\n        每个字段必须有数据类型\n        最后一个字段后不能有逗号\n        <span class=\"token keyword\">TEMPORARY</span> 临时表，会话结束时表自动消失\n        对于字段的定义：\n            字段名 数据类型 <span class=\"token punctuation\">[</span><span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token operator\">|</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">DEFAULT</span> default_value<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">UNIQUE</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">KEY</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">PRIMARY</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">-- 表选项</span>\n    <span class=\"token comment\">-- 字符集</span>\n        <span class=\"token keyword\">CHARSET</span> <span class=\"token operator\">=</span> charset_name\n        如果表没有设定，则使用数据库字符集\n    <span class=\"token comment\">-- 存储引擎</span>\n        <span class=\"token keyword\">ENGINE</span> <span class=\"token operator\">=</span> engine_name\n        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同\n        常见的引擎：<span class=\"token keyword\">InnoDB</span> MyISAM Memory<span class=\"token operator\">/</span>Heap <span class=\"token keyword\">BDB</span> <span class=\"token keyword\">Merge</span> Example CSV MaxDB Archive\n        不同的引擎在保存表的结构和数据时采用不同的方式\n        MyISAM表文件含义：<span class=\"token punctuation\">.</span>frm表定义，<span class=\"token punctuation\">.</span>MYD表数据，<span class=\"token punctuation\">.</span>MYI表索引\n        <span class=\"token keyword\">InnoDB</span>表文件含义：<span class=\"token punctuation\">.</span>frm表定义，表空间数据和日志文件\n        <span class=\"token keyword\">SHOW</span> ENGINES <span class=\"token comment\">-- 显示存储引擎的状态信息</span>\n        <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">ENGINE</span> 引擎名 {LOGS<span class=\"token operator\">|</span><span class=\"token keyword\">STATUS</span>} <span class=\"token comment\">-- 显示存储引擎的日志或状态信息</span>\n    <span class=\"token comment\">-- 自增起始数</span>\n    \t<span class=\"token keyword\">AUTO_INCREMENT</span> <span class=\"token operator\">=</span> 行数\n    <span class=\"token comment\">-- 数据文件目录</span>\n        <span class=\"token keyword\">DATA</span> DIRECTORY <span class=\"token operator\">=</span> <span class=\"token string\">'目录'</span>\n    <span class=\"token comment\">-- 索引文件目录</span>\n        <span class=\"token keyword\">INDEX</span> DIRECTORY <span class=\"token operator\">=</span> <span class=\"token string\">'目录'</span>\n    <span class=\"token comment\">-- 表注释</span>\n        <span class=\"token keyword\">COMMENT</span> <span class=\"token operator\">=</span> <span class=\"token string\">'string'</span>\n    <span class=\"token comment\">-- 分区选项</span>\n        <span class=\"token keyword\">PARTITION</span> <span class=\"token keyword\">BY</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>详细见手册<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 查看所有表</span>\n    <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">TABLES</span><span class=\"token punctuation\">[</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">TABLES</span> <span class=\"token keyword\">FROM</span>  库名\n<span class=\"token comment\">-- 查看表结构</span>\n    <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> 表名 （信息更详细）\n    <span class=\"token keyword\">DESC</span> 表名 <span class=\"token operator\">/</span> <span class=\"token keyword\">DESCRIBE</span> 表名 <span class=\"token operator\">/</span> <span class=\"token keyword\">EXPLAIN</span> 表名 <span class=\"token operator\">/</span> <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">COLUMNS</span> <span class=\"token keyword\">FROM</span> 表名 <span class=\"token punctuation\">[</span><span class=\"token operator\">LIKE</span> <span class=\"token string\">'PATTERN'</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">STATUS</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">FROM</span> db_name<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">LIKE</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">-- 修改表</span>\n    <span class=\"token comment\">-- 修改表本身的选项</span>\n        <span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> 表名 表的选项\n        eg: <span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> 表名 <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span>MYISAM<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">-- 对表进行重命名</span>\n        <span class=\"token keyword\">RENAME</span> <span class=\"token keyword\">TABLE</span> 原表名 <span class=\"token keyword\">TO</span> 新表名\n        <span class=\"token keyword\">RENAME</span> <span class=\"token keyword\">TABLE</span> 原表名 <span class=\"token keyword\">TO</span> 库名<span class=\"token punctuation\">.</span>表名 （可将表移动到另一个数据库）\n        <span class=\"token comment\">-- RENAME可以交换两个表名</span>\n    <span class=\"token comment\">-- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span>\n        <span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> 表名 操作名\n        <span class=\"token comment\">-- 操作名</span>\n            <span class=\"token keyword\">ADD</span><span class=\"token punctuation\">[</span> <span class=\"token keyword\">COLUMN</span><span class=\"token punctuation\">]</span> 字段定义       <span class=\"token comment\">-- 增加字段</span>\n                <span class=\"token keyword\">AFTER</span> 字段名          <span class=\"token comment\">-- 表示增加在该字段名后面</span>\n                <span class=\"token keyword\">FIRST</span>               <span class=\"token comment\">-- 表示增加在第一个</span>\n            <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">(</span>字段名<span class=\"token punctuation\">)</span>   <span class=\"token comment\">-- 创建主键</span>\n            <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token punctuation\">[</span>索引名<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>字段名<span class=\"token punctuation\">)</span><span class=\"token comment\">-- 创建唯一索引</span>\n            <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> <span class=\"token punctuation\">[</span>索引名<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>字段名<span class=\"token punctuation\">)</span> <span class=\"token comment\">-- 创建普通索引</span>\n            <span class=\"token keyword\">DROP</span><span class=\"token punctuation\">[</span> <span class=\"token keyword\">COLUMN</span><span class=\"token punctuation\">]</span> 字段名      <span class=\"token comment\">-- 删除字段</span>\n            <span class=\"token keyword\">MODIFY</span><span class=\"token punctuation\">[</span> <span class=\"token keyword\">COLUMN</span><span class=\"token punctuation\">]</span> 字段名 字段属性     <span class=\"token comment\">-- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span>\n            CHANGE<span class=\"token punctuation\">[</span> <span class=\"token keyword\">COLUMN</span><span class=\"token punctuation\">]</span> 原字段名 新字段名 字段属性      <span class=\"token comment\">-- 支持对字段名修改</span>\n            <span class=\"token keyword\">DROP</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span>    <span class=\"token comment\">-- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span>\n            <span class=\"token keyword\">DROP</span> <span class=\"token keyword\">INDEX</span> 索引名 <span class=\"token comment\">-- 删除索引</span>\n            <span class=\"token keyword\">DROP</span> <span class=\"token keyword\">FOREIGN</span> <span class=\"token keyword\">KEY</span> 外键    <span class=\"token comment\">-- 删除外键</span>\n<span class=\"token comment\">-- 删除表</span>\n    <span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TABLE</span><span class=\"token punctuation\">[</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span><span class=\"token punctuation\">]</span> 表名 <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token comment\">-- 清空表数据</span>\n    <span class=\"token keyword\">TRUNCATE</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">TABLE</span><span class=\"token punctuation\">]</span> 表名\n<span class=\"token comment\">-- 复制表结构</span>\n    <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> 表名 <span class=\"token operator\">LIKE</span> 要复制的表名\n<span class=\"token comment\">-- 复制表结构和数据</span>\n    <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> 表名 <span class=\"token punctuation\">[</span><span class=\"token keyword\">AS</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> 要复制的表名\n<span class=\"token comment\">-- 检查表是否有错误</span>\n    <span class=\"token keyword\">CHECK</span> <span class=\"token keyword\">TABLE</span> tbl_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> tbl_name<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">option</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token comment\">-- 优化表</span>\n    <span class=\"token keyword\">OPTIMIZE</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">LOCAL</span> <span class=\"token operator\">|</span> NO_WRITE_TO_BINLOG<span class=\"token punctuation\">]</span> <span class=\"token keyword\">TABLE</span> tbl_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> tbl_name<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token comment\">-- 修复表</span>\n    REPAIR <span class=\"token punctuation\">[</span><span class=\"token keyword\">LOCAL</span> <span class=\"token operator\">|</span> NO_WRITE_TO_BINLOG<span class=\"token punctuation\">]</span> <span class=\"token keyword\">TABLE</span> tbl_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> tbl_name<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">QUICK</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">EXTENDED</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>USE_FRM<span class=\"token punctuation\">]</span>\n<span class=\"token comment\">-- 分析表</span>\n    <span class=\"token keyword\">ANALYZE</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">LOCAL</span> <span class=\"token operator\">|</span> NO_WRITE_TO_BINLOG<span class=\"token punctuation\">]</span> <span class=\"token keyword\">TABLE</span> tbl_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> tbl_name<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n</code></pre></div><h3>数据操作</h3>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token comment\">/* 数据操作 */</span> </code></pre></div>",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "SQL语句在MySQL中的执行过程",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/how-sql-executed-in-mysql.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/how-sql-executed-in-mysql.html",
      "summary": "本文来自木木匠投稿。 本篇文章会分析下一个 SQL 语句在 MySQL 中的执行流程，包括 SQL 的查询在 MySQL 内部会怎么流转，SQL 语句的更新是怎么完成的。 在分析之前我会先带着你看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。 一 MySQL 基础架构分析 1.1...",
      "content_html": "<blockquote>\n<p>本文来自<a href=\"https://github.com/kinglaw1204\" target=\"_blank\" rel=\"noopener noreferrer\">木木匠</a>投稿。</p>\n</blockquote>\n<p>本篇文章会分析下一个 SQL 语句在 MySQL 中的执行流程，包括 SQL 的查询在 MySQL 内部会怎么流转，SQL 语句的更新是怎么完成的。</p>\n<p>在分析之前我会先带着你看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。</p>\n<h2>一 MySQL 基础架构分析</h2>\n<h3>1.1 MySQL 基本架构概览</h3>\n<p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>\n<p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p>\n<ul>\n<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>\n<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>\n<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>\n<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>\n<li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 -</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p>\n<ul>\n<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。</li>\n<li><strong>存储引擎</strong>：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</strong></li>\n</ul>\n<h3>1.2 Server 层基本组件介绍</h3>\n<h4>1) 连接器</h4>\n<p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>\n<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p>\n<h4>2) 查询缓存(MySQL 8.0 版本后移除)</h4>\n<p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>\n<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>\n<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>\n<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>\n<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>\n<h4>3) 分析器</h4>\n<p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>\n<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>\n<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</p>\n<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>\n<h4>4) 优化器</h4>\n<p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>\n<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>\n<h4>5) 执行器</h4>\n<p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>\n<h2>二 语句分析</h2>\n<h3>2.1 查询语句</h3>\n<p>说了以上这么多，那么究竟一条 SQL 语句是如何执行的呢？其实我们的 SQL 可以分为两种，一种是查询，一种是更新（增加，修改，删除）。我们先分析下查询语句，语句如下：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_student  A <span class=\"token keyword\">where</span> A<span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span><span class=\"token string\">'18'</span> <span class=\"token operator\">and</span> A<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">' 张三 '</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>结合上面的说明，我们分析下这个语句的执行流程：</p>\n<ul>\n<li>\n<p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>\n</li>\n<li>\n<p>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>\n</li>\n<li>\n<p>接下来就是优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：</p>\n<pre><code>  a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。\n  b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。\n</code></pre>\n<p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>\n</li>\n<li>\n<p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>\n</li>\n</ul>\n<h3>2.2 更新语句</h3>\n<p>以上就是一条查询 SQL 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？SQL 语句如下：</p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>update tb_student A set A.age='19' where A.name=' 张三 ';\n</code></pre></div><p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>\n<ul>\n<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>\n<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>\n<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>\n<li>更新完成。</li>\n</ul>\n<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>\n<p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>\n<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>\n<ul>\n<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>\n<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>\n</ul>\n<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？\n这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>\n<ul>\n<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>\n<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>\n</ul>\n<p>这样就解决了数据一致性的问题。</p>\n<h2>三 总结</h2>\n<ul>\n<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li>\n<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>\n<li>查询语句的执行流程如下：权限校验（如果命中缓存）</li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL隐式转换造成索引失效",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/index-invalidation-caused-by-implicit-conversion.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/index-invalidation-caused-by-implicit-conversion.html",
      "summary": "本次测试使用的 MySQL 版本是 5.7.26，随着 MySQL 版本的更新某些特性可能会发生改变，本文不代表所述观点和结论于 MySQL 所有版本均准确无误，版本差异请自行甄别。 原文：https://www.guitu18.com/post/2019/11/24/61.html 前言 数据库优化是一个任重而道远的任务，想要做优化必须深入理解数据库...",
      "content_html": "<blockquote>\n<p>本次测试使用的 MySQL 版本是 <code>5.7.26</code>，随着 MySQL 版本的更新某些特性可能会发生改变，本文不代表所述观点和结论于 MySQL 所有版本均准确无误，版本差异请自行甄别。</p>\n<p>原文：https://www.guitu18.com/post/2019/11/24/61.html</p>\n</blockquote>\n<h2>前言</h2>\n<p>数据库优化是一个任重而道远的任务，想要做优化必须深入理解数据库的各种特性。在开发过程中我们经常会遇到一些原因很简单但造成的后果却很严重的疑难杂症，这类问题往往还不容易定位，排查费时费力最后发现是一个很小的疏忽造成的，又或者是因为不了解某个技术特性产生的。</p>\n<p>于数据库层面，最常见的恐怕就是索引失效了，且一开始因为数据量小还不易被发现。但随着业务的拓展数据量的提升，性能问题慢慢的就体现出来了，处理不及时还很容易造成雪球效应，最终导致数据库卡死甚至瘫痪。造成索引失效的原因可能有很多种，相关技术博客已经有太多了，今天我要记录的是<strong>隐式转换造成的索引失效</strong>。</p>\n<h2>数据准备</h2>\n<p>首先使用存储过程生成 1000 万条测试数据，\n测试表一共建立了 7 个字段（包括主键），<code>num1</code>和<code>num2</code>保存的是和<code>ID</code>一样的顺序数字，其中<code>num2</code>是字符串类型。\n<code>type1</code>和<code>type2</code>保存的都是主键对 5 的取模，目的是模拟实际应用中常用类似 type 类型的数据，但是<code>type2</code>是没有建立索引的。\n<code>str1</code>和<code>str2</code>都是保存了一个 20 位长度的随机字符串，<code>str1</code>不能为<code>NULL</code>，<code>str2</code>允许为<code>NULL</code>，相应的生成测试数据的时候我也会在<code>str2</code>字段生产少量<code>NULL</code>值（每 100 条数据产生一个<code>NULL</code>值）。</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token comment\">-- 创建测试数据表</span>\n<span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span> test1<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>test1<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span>\n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num1<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num2<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type1<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type2<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str1<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str2<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num1<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>num1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num2<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>num2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type1<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>type1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str1<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>str1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str2<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>str2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 创建存储过程</span>\n<span class=\"token keyword\">DROP</span> <span class=\"token keyword\">PROCEDURE</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span> pre_test1<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">DELIMITER</span> <span class=\"token comment\">//</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">PROCEDURE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>pre_test1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">BEGIN</span>\n    <span class=\"token keyword\">DECLARE</span> i <span class=\"token keyword\">INT</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">SET</span> autocommit <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">WHILE</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000000</span> <span class=\"token keyword\">DO</span>\n        <span class=\"token keyword\">SET</span> i <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">SET</span> <span class=\"token variable\">@str1</span> <span class=\"token operator\">=</span> SUBSTRING<span class=\"token punctuation\">(</span>MD5<span class=\"token punctuation\">(</span>RAND<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">-- 每100条数据str2产生一个null值</span>\n        <span class=\"token keyword\">IF</span> i <span class=\"token operator\">%</span> <span class=\"token number\">100</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token keyword\">THEN</span>\n            <span class=\"token keyword\">SET</span> <span class=\"token variable\">@str2</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">ELSE</span>\n            <span class=\"token keyword\">SET</span> <span class=\"token variable\">@str2</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@str1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">END</span> <span class=\"token keyword\">IF</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> test1 <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span>\n        <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span>CONCAT<span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> CONCAT<span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        CONCAT<span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> i<span class=\"token operator\">%</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> i<span class=\"token operator\">%</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">@str1</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">@str2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">-- 事务优化，每一万条数据提交一次事务</span>\n        <span class=\"token keyword\">IF</span> i <span class=\"token operator\">%</span> <span class=\"token number\">10000</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token keyword\">THEN</span>\n            <span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">END</span> <span class=\"token keyword\">IF</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">END</span> <span class=\"token keyword\">WHILE</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">END</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// DELIMITER ;</span>\n<span class=\"token comment\">-- 执行存储过程</span>\n<span class=\"token keyword\">CALL</span> pre_test1<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>数据量比较大，还涉及使用<code>MD5</code>生成随机字符串，所以速度有点慢，稍安勿躁，耐心等待即可。</p>\n<p>1000 万条数据，我用了 33 分钟才跑完（实际时间跟你电脑硬件配置有关）。这里贴几条生成的数据，大致长这样。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-01.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>SQL 测试</h2>\n<p>先来看这组 SQL，一共四条，我们的测试数据表<code>num1</code>是<code>int</code>类型，<code>num2</code>是<code>varchar</code>类型，但是存储的数据都是跟主键<code>id</code>一样的顺序数字，两个字段都建立有索引。</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token number\">1</span>: <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>test1<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">WHERE</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2</span>: <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>test1<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">WHERE</span> num1 <span class=\"token operator\">=</span> <span class=\"token string\">'10000'</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">3</span>: <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>test1<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">WHERE</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">4</span>: <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>test1<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">WHERE</span> num2 <span class=\"token operator\">=</span> <span class=\"token string\">'10000'</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>这四条 SQL 都是有针对性写的，12 查询的字段是 int 类型，34 查询的字段是<code>varchar</code>类型。12 或 34 查询的字段虽然都相同，但是一个条件是数字，一个条件是用引号引起来的字符串。这样做有什么区别呢？先不看下边的测试结果你能猜出这四条 SQL 的效率顺序吗？</p>\n<p>经测试这四条 SQL 最后的执行结果却相差很大，其中 124 三条 SQL 基本都是瞬间出结果，大概在 0.001~0.005 秒，在千万级的数据量下这样的结果可以判定这三条 SQL 性能基本没差别了。但是第三条 SQL，多次测试耗时基本在 4.5~4.8 秒之间。</p>\n<p>为什么 34 两条 SQL 效率相差那么大，但是同样做对比的 12 两条 SQL 却没什么差别呢？查看一下执行计划，下边分别 1234 条 SQL 的执行计划数据：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-02.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>可以看到，124 三条 SQL 都能使用到索引，连接类型都为<code>ref</code>，扫描行数都为 1，所以效率非常高。再看看第三条 SQL，没有用上索引，所以为全表扫描，<code>rows</code>直接到达 1000 万了，所以性能差别才那么大。</p>\n<p>仔细观察你会发现，34 两条 SQL 查询的字段<code>num2</code>是<code>varchar</code>类型的，查询条件等号右边加引号的第 4 条 SQL 是用到索引的，那么是查询的数据类型和字段数据类型不一致造成的吗？如果是这样那 12 两条 SQL 查询的字段<code>num1</code>是<code>int</code>类型，但是第 2 条 SQL 查询条件右边加了引号为什么还能用上索引呢。</p>\n<p>查阅 MySQL 相关文档发现是隐式转换造成的，看一下官方的描述：</p>\n<blockquote>\n<p>官方文档：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html?spm=5176.100239.blogcont47339.5.1FTben\" target=\"_blank\" rel=\"noopener noreferrer\">12.2 Type Conversion in Expression Evaluation</a></p>\n<p>当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL 会根据需要自动将字符串转换为数字，反之亦然。以下规则描述了比较操作的转换方式：</p>\n<ol>\n<li>两个参数至少有一个是<code>NULL</code>时，比较的结果也是<code>NULL</code>，特殊的情况是使用<code>&lt;=&gt;</code>对两个<code>NULL</code>做比较时会返回<code>1</code>，这两种情况都不需要做类型转换</li>\n<li>两个参数都是字符串，会按照字符串来比较，不做类型转换</li>\n<li>两个参数都是整数，按照整数来比较，不做类型转换</li>\n<li>十六进制的值和非数字做比较时，会被当做二进制串</li>\n<li>有一个参数是<code>TIMESTAMP</code>或<code>DATETIME</code>，并且另外一个参数是常量，常量会被转换为<code>timestamp</code></li>\n<li>有一个参数是<code>decimal</code>类型，如果另外一个参数是<code>decimal</code>或者整数，会将整数转换为<code>decimal</code>后进行比较，如果另外一个参数是浮点数，则会把<code>decimal</code>转换为浮点数进行比较</li>\n<li><strong>所有其他情况下，两个参数都会被转换为浮点数再进行比较</strong></li>\n</ol>\n</blockquote>\n<p>根据官方文档的描述，我们的第 23 两条 SQL 都发生了隐式转换，第 2 条 SQL 的查询条件<code>num1 = '10000'</code>，左边是<code>int</code>类型右边是字符串，第 3 条 SQL 相反，那么根据官方转换规则第 7 条，左右两边都会转换为浮点数再进行比较。</p>\n<p>先看第 2 条 SQL：<code>SELECT * FROM</code>test1<code>WHERE num1 = '10000';</code> <strong>左边为 int 类型</strong><code>10000</code>，转换为浮点数还是<code>10000</code>，右边字符串类型<code>'10000'</code>，转换为浮点数也是<code>10000</code>。两边的转换结果都是唯一确定的，所以不影响使用索引。</p>\n<p>第 3 条 SQL：<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code> <strong>左边是字符串类型</strong><code>'10000'</code>，转浮点数为 10000 是唯一的，右边<code>int</code>类型<code>10000</code>转换结果也是唯一的。但是，因为左边是检索条件，<code>'10000'</code>转到<code>10000</code>虽然是唯一，但是其他字符串也可以转换为<code>10000</code>，比如<code>'10000a'</code>，<code>'010000'</code>，<code>'10000'</code>等等都能转为浮点数<code>10000</code>，这样的情况下，是不能用到索引的。</p>\n<p>关于这个<strong>隐式转换</strong>我们可以通过查询测试验证一下，先插入几条数据，其中<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>test1<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'10000001'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'10000'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'10000a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2df3d9465ty2e4hd523'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2df3d9465ty2e4hd523'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>test1<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'10000002'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'10000'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'010000'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2df3d9465ty2e4hd523'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2df3d9465ty2e4hd523'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>test1<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>num2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>type2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str1<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>str2<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'10000003'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'10000'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">' 10000'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2df3d9465ty2e4hd523'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2df3d9465ty2e4hd523'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>然后使用第三条 SQL 语句<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code>进行查询：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-03.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>从结果可以看到，后面插入的三条数据也都匹配上了。那么这个字符串隐式转换的规则是什么呢？为什么<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>这三种情形都能匹配上呢？查阅相关资料发现规则如下：</p>\n<ol>\n<li><strong>不以数字开头</strong>的字符串都将转换为<code>0</code>。如<code>'abc'</code>、<code>'a123bc'</code>、<code>'abc123'</code>都会转化为<code>0</code>；</li>\n<li><strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>'123abc'</code>会转换为<code>123</code>，<code>'012abc'</code>会转换为<code>012</code>也就是<code>12</code>，<code>'5.3a66b78c'</code>会转换为<code>5.3</code>，其他同理。</li>\n</ol>\n<p>现对以上规则做如下测试验证：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-04.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如此也就印证了之前的查询结果了。</p>\n<p>再次写一条 SQL 查询 str1 字段：<code>SELECT * FROM</code>test1<code>WHERE str1 = 1234;</code></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-05.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>分析和总结</h2>\n<p>通过上面的测试我们发现 MySQL 使用操作符的一些特性：</p>\n<ol>\n<li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li>\n<li>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li>\n<li>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li>\n<li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</li>\n</ol>\n<p>所以，我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描。</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-01.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "InnoDB存储引擎对MVCC的实现",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/innodb-implementation-of-mvcc.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/innodb-implementation-of-mvcc.html",
      "summary": "一致性非锁定读和锁定读 一致性非锁定读 对于 一致性非锁定读（Consistent Nonlocking Reads）的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见 在 InnoDB 存储引擎中，多版本控制 ...",
      "content_html": "<h2>一致性非锁定读和锁定读</h2>\n<h3>一致性非锁定读</h3>\n<p>对于 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>一致性非锁定读（Consistent Nonlocking Reads）</strong></a>的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</p>\n<p>在 <code>InnoDB</code> 存储引擎中，<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html\" target=\"_blank\" rel=\"noopener noreferrer\">多版本控制 (multi versioning)</a> 就是对非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行上锁的释放。相反地，<code>InnoDB</code> 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)</p>\n<p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读（MVCC）</code>。并且在 <code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读</p>\n<h3>锁定读</h3>\n<p>如果执行的是下列语句，就是 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>锁定读（Locking Reads）</strong></a></p>\n<ul>\n<li><code>select ... lock in share mode</code></li>\n<li><code>select ... for update</code></li>\n<li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li>\n</ul>\n<p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p>\n<ul>\n<li>\n<p><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</p>\n</li>\n<li>\n<p><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</p>\n</li>\n</ul>\n<p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong></p>\n<h2>InnoDB 对 MVCC 的实现</h2>\n<p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>\n<h3>隐藏字段</h3>\n<p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html\" target=\"_blank\" rel=\"noopener noreferrer\">隐藏字段</a>：</p>\n<ul>\n<li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li>\n<li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li>\n<li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li>\n</ul>\n<h3>ReadView</h3>\n<div class=\"language-c\" data-ext=\"c\" data-title=\"c\"><pre class=\"language-c\"><code>class ReadView <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* ... */</span>\nprivate<span class=\"token operator\">:</span>\n  <span class=\"token class-name\">trx_id_t</span> m_low_limit_id<span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 大于等于这个 ID 的事务均不可见 */</span>\n\n  <span class=\"token class-name\">trx_id_t</span> m_up_limit_id<span class=\"token punctuation\">;</span>       <span class=\"token comment\">/* 小于这个 ID 的事务均可见 */</span>\n\n  <span class=\"token class-name\">trx_id_t</span> m_creator_trx_id<span class=\"token punctuation\">;</span>    <span class=\"token comment\">/* 创建该 Read View 的事务ID */</span>\n\n  <span class=\"token class-name\">trx_id_t</span> m_low_limit_no<span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span>\n\n  <span class=\"token class-name\">ids_t</span> m_ids<span class=\"token punctuation\">;</span>                  <span class=\"token comment\">/* 创建 Read View 时的活跃事务列表 */</span>\n\n  m_closed<span class=\"token punctuation\">;</span>                     <span class=\"token comment\">/* 标记 Read View 是否 close */</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><a href=\"https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L298\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Read View</code></a> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</p>\n<p>主要有以下字段：</p>\n<ul>\n<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>\n<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>\n<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>\n<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>\n</ul>\n<p><strong>事务可见性示意图</strong>（<a href=\"https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1\" target=\"_blank\" rel=\"noopener noreferrer\">图源</a>）：</p>\n<figure><figcaption>trans_visible</figcaption></figure>\n<h3>undo-log</h3>\n<p><code>undo log</code> 主要有两个作用：</p>\n<ul>\n<li>当事务回滚时用于将数据恢复到修改前的样子</li>\n<li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li>\n</ul>\n<p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种：<code>insert undo log</code> 和 <code>update undo log</code>：</strong></p>\n<ol>\n<li><strong><code>insert undo log</code></strong>：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作</li>\n</ol>\n<p><strong><code>insert</code> 时的数据初始状态：</strong></p>\n<figure><figcaption></figcaption></figure>\n<ol start=\"2\">\n<li><strong><code>update undo log</code></strong>：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</li>\n</ol>\n<p><strong>数据第一次被修改时：</strong></p>\n<figure><figcaption></figcaption></figure>\n<p><strong>数据第二次被修改时：</strong></p>\n<figure><figcaption></figcaption></figure>\n<p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 <code>undo log</code> 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</p>\n<h3>数据可见性算法</h3>\n<p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</p>\n<p><a href=\"https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L161\" target=\"_blank\" rel=\"noopener noreferrer\">具体的比较算法</a>如下(<a href=\"https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1\" target=\"_blank\" rel=\"noopener noreferrer\">图源</a>)：</p>\n<figure><figcaption></figcaption></figure>\n<ol>\n<li>\n<p>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</p>\n</li>\n<li>\n<p>如果 DB_TRX_ID &gt;= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</p>\n</li>\n<li>\n<p>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</p>\n</li>\n<li>\n<p>如果 m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）</p>\n<ul>\n<li>\n<p>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</p>\n</li>\n<li>\n<p>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</p>\n</li>\n</ul>\n</li>\n<li>\n<p>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</p>\n</li>\n</ol>\n<h2>RC 和 RR 隔离级别下 MVCC 的差异</h2>\n<p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p>\n<ul>\n<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li>\n<li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li>\n</ul>\n<h2>MVCC 解决不可重复读问题</h2>\n<p>虽然 RC 和 RR 都通过 <code>MVCC</code> 来读取快照数据，但由于 <strong>生成 Read View 时机不同</strong>，从而在 RR 级别下实现可重复读</p>\n<p>举个例子：</p>\n<figure><figcaption></figcaption></figure>\n<h3>在 RC 下 ReadView 生成情况</h3>\n<p><strong>1. 假设时间线来到 T4 ，那么此时数据行 id = 1 的版本链为：</strong></p>\n<figure><figcaption></figcaption></figure>\n<p>由于 RC 级别下每次查询都会生成<code>Read View</code> ，并且事务 101、102 并未提交，此时 <code>103</code> 事务生成的 <code>Read View</code> 中活跃的事务 <strong><code>m_ids</code> 为：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>\n<ul>\n<li>此时最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li>\n<li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</li>\n<li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></li>\n</ul>\n<p><strong>2. 时间线来到 T6 ，数据的版本链为：</strong></p>\n<figure><figcaption></figcaption></figure>\n<p>因为在 RC 级别下，重新生成 <code>Read View</code>，这时事务 101 已经提交，102 并未提交，所以此时 <code>Read View</code> 中活跃的事务 <strong><code>m_ids</code>：[102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：102，<code>m_creator_trx_id</code>为：103</p>\n<ul>\n<li>\n<p>此时最新记录的 <code>DB_TRX_ID</code> 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</p>\n</li>\n<li>\n<p>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 为 101，满足 101 &lt; m_up_limit_id，记录可见，所以在 <code>T6</code> 时间点查询到数据为 <code>name = 李四</code>，与时间 T4 查询到的结果不一致，不可重复读！</p>\n</li>\n</ul>\n<p><strong>3. 时间线来到 T9 ，数据的版本链为：</strong></p>\n<figure><figcaption></figcaption></figure>\n<p>重新生成 <code>Read View</code>， 这时事务 101 和 102 都已经提交，所以 <strong>m_ids</strong> 为空，则 m_up_limit_id = m_low_limit_id = 104，最新版本事务 ID 为 102，满足 102 &lt; m_low_limit_id，可见，查询结果为 <code>name = 赵六</code></p>\n<blockquote>\n<p><strong>总结：</strong> <strong>在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</strong></p>\n</blockquote>\n<h3>在 RR 下 ReadView 生成情况</h3>\n<p>在可重复读级别下，只会在事务开始后第一次读取数据时生成一个 Read View（m_ids 列表）</p>\n<p><strong>1. 在 T4 情况下的版本链为：</strong></p>\n<figure><figcaption></figcaption></figure>\n<p>在当前执行 <code>select</code> 语句时生成一个 <code>Read View</code>，此时 <strong><code>m_ids</code>：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>\n<p>此时和 RC 级别下一样：</p>\n<ul>\n<li>最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li>\n<li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</li>\n<li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></li>\n</ul>\n<p><strong>2. 时间点 T6 情况下：</strong></p>\n<figure><figcaption></figcaption></figure>\n<p>在 RR 级别下只会生成一次<code>Read View</code>，所以此时依然沿用 <strong><code>m_ids</code>：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>\n<ul>\n<li>\n<p>最新记录的 <code>DB_TRX_ID</code> 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</p>\n</li>\n<li>\n<p>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 为 101，不可见</p>\n</li>\n<li>\n<p>继续根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</p>\n</li>\n<li>\n<p>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></p>\n</li>\n</ul>\n<p><strong>3. 时间点 T9 情况下：</strong></p>\n<figure><figcaption></figcaption></figure>\n<p>此时情况跟 T6 完全一样，由于已经生成了 <code>Read View</code>，此时依然沿用 <strong><code>m_ids</code>：[101,102]</strong> ，所以查询结果依然是 <code>name = 菜花</code></p>\n<h2>MVCC➕Next-key-Lock 防止幻读</h2>\n<p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p>\n<p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p>\n<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p>\n<p><strong>2、执行 select...for update/lock in share mode、insert、update、delete 等当前读</strong></p>\n<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks\" target=\"_blank\" rel=\"noopener noreferrer\">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>\n<h2>参考</h2>\n<ul>\n<li><strong>《MySQL 技术内幕 InnoDB 存储引擎第 2 版》</strong></li>\n<li><a href=\"https://tech.meituan.com/2014/08/20/innodb-lock.html\" target=\"_blank\" rel=\"noopener noreferrer\">Innodb 中的事务隔离级别和锁的关系</a></li>\n<li><a href=\"https://blog.csdn.net/qq_35190492/article/details/109044141\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 事务与 MVCC 如何实现的隔离级别</a></li>\n<li><a href=\"https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/\" target=\"_blank\" rel=\"noopener noreferrer\">InnoDB 事务分析-MVCC</a></li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL自增主键一定是连续的吗",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-auto-increment-primary-key-continuous.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-auto-increment-primary-key-continuous.html",
      "summary": "作者：飞天小牛肉 原文：https://mp.weixin.qq.com/s/qci10h9rJx_COZbHV3aygQ 众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率。 但实际上，MySQL 的自增主键并不能保证一定是连续递增的。 下面举个例子来看下，如下所示创建一张表： 自增值保存在哪里？ 使用 ins...",
      "content_html": "<blockquote>\n<p>作者：飞天小牛肉</p>\n<p>原文：https://mp.weixin.qq.com/s/qci10h9rJx_COZbHV3aygQ</p>\n</blockquote>\n<p>众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率。</p>\n<p>但实际上，MySQL 的自增主键并不能保证一定是连续递增的。</p>\n<p>下面举个例子来看下，如下所示创建一张表：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e6b80ba50cb425386b80924e3da0d23~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>自增值保存在哪里？</h2>\n<p>使用 <code>insert into test_pk values(null, 1, 1)</code> 插入一行数据，再执行 <code>show create table</code> 命令来看一下表的结构定义：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c17e46230bd34150966f0d86b2ad5e91~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>上述表的结构定义存放在后缀名为 <code>.frm</code> 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 <code>.frm</code> 文件：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec0514dd7be423d80b9e7f2d52f5902~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>从上述表结构可以看到，表定义里面出现了一个 <code>AUTO_INCREMENT=2</code>，表示下一次插入数据时，如果需要自动生成自增值，会生成 id = 2。</p>\n<p>但需要注意的是，自增值并不会保存在这个表结构也就是 <code>.frm</code> 文件中，不同的引擎对于自增值的保存策略不同：</p>\n<p>1）MyISAM 引擎的自增值保存在数据文件中</p>\n<p>2）InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 <code>max(id)</code>，然后将 <code>max(id)+1</code> 作为这个表当前的自增值。</p>\n<p>举个例子：我们现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT=2，对吧。这时候，我们删除 id=1 的行，AUTO_INCREMENT 还是 2。</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61b8dc9155624044a86d91c368b20059~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿ 也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27fdb15375664249a31f88b64e6e5e66~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dee15f93e65d44d384345a03404f3481~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>以上，是在我本地 MySQL 5.x 版本的实验，实际上，<strong>到了 MySQL 8.0 版本后，自增值的变更记录被放在了 redo log 中，提供了自增值持久化的能力</strong> ，也就是实现了“如果发生重启，表的自增值可以根据 redo log 恢复为 MySQL 重启前的值”</p>\n<p>也就是说对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。</p>\n<p>理解了 MySQL 自增值到底保存在哪里以后，我们再来看看自增值的修改机制，并以此引出第一种自增值不连续的场景。</p>\n<h2>自增值不连续的场景</h2>\n<h3>自增值不连续场景 1</h3>\n<p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p>\n<ul>\n<li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li>\n<li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li>\n</ul>\n<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 <code>insert_num</code>，当前的自增值是 <code>autoIncrement_num</code>：</p>\n<ul>\n<li>如果 <code>insert_num &lt; autoIncrement_num</code>，那么这个表的自增值不变</li>\n<li>如果 <code>insert_num &gt;= autoIncrement_num</code>，就需要把当前自增值修改为新的自增值</li>\n</ul>\n<p>也就是说，如果插入的 id 是 100，当前的自增值是 90，<code>insert_num &gt;= autoIncrement_num</code>，那么自增值就会被修改为新的自增值即 101</p>\n<p>一定是这样吗？</p>\n<p>非也~</p>\n<p>了解过分布式 id 的小伙伴一定知道，为了避免两个库生成的主键发生冲突，我们可以让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数</p>\n<p>这个奇数偶数其实是通过 <code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 这两个参数来决定的，这俩分别用来表示自增的初始值和步长，默认值都是 1。</p>\n<p>所以，上面的例子中生成新的自增值的步骤实际是这样的：从 <code>auto_increment_offset</code> 开始，以 <code>auto_increment_increment</code> 为步长，持续叠加，直到找到第一个大于 100 的值，作为新的自增值。</p>\n<p>所以，这种情况下，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。</p>\n<p>更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的</p>\n<h3>自增值不连续场景 2</h3>\n<p>举个例子，我们现在往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT= 2，对吧</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c22c4f2cea234c7ea496025eb826c3bc~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这时我再执行一条插入 <code>(null,1,1)</code> 的命令，很显然会报错 <code>Duplicate entry</code>，因为我们设置了一个唯一索引字段 <code>a</code>：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0325e31398d4fa6bb1cbe08ef797b7f~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但是，你会惊奇的发现，虽然插入失败了，但自增值仍然从 2 增加到了 3！</p>\n<p>这是为啥？</p>\n<p>我们来分析下这个 insert 语句的执行流程：</p>\n<ol>\n<li>执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1);</li>\n<li>InnoDB 发现用户没有指定自增 id 的值，则获取表 <code>test_pk</code> 当前的自增值 2；</li>\n<li>将传入的记录改成 (2,1,1);</li>\n<li>将表的自增值改成 3；</li>\n<li>继续执行插入数据操作，由于已经存在 a=1 的记录，所以报 Duplicate key error，语句返回</li>\n</ol>\n<p>可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。</p>\n<p>这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id = 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。</p>\n<p>至此，我们已经罗列了两种自增主键不连续的情况：</p>\n<ol>\n<li>自增初始值和自增步长设置不为 1</li>\n<li>唯一键冲突</li>\n</ol>\n<p>除此之外，事务回滚也会导致这种情况</p>\n<h3>自增值不连续场景 3</h3>\n<p>我们现在表里有一行 <code>(1,1,1)</code> 的记录，AUTO_INCREMENT = 3：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6220fcf7dac54299863e43b6fb97de3e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>我们先插入一行数据 <code>(null, 2, 2)</code>，也就是 (3, 2, 2) 嘛，并且 AUTO_INCREMENT 变为 4：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f02d46437d643c3b3d9f44a004ab269~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>再去执行这样一段 SQL：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faf5ce4a2920469cae697f845be717f5~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>虽然我们插入了一条 (null, 3, 3) 记录，但是使用 rollback 进行回滚了，所以数据库中是没有这条记录的：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cb4c02722674dd399939d3d03a431c1~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在这种事务回滚的情况下，自增值并没有同样发生回滚！如下图所示，自增值仍然固执地从 4 增加到了 5：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6eea1c927424ac7bda34a511ca521ae~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>所以这时候我们再去插入一条数据（null, 3, 3）的时候，主键 id 就会被自动赋为 <code>5</code> 了：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80da69dd13b543c4a32d6ed832a3c568~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>那么，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去呢？回退回去的话不就不会发生自增 id 不连续了吗？</p>\n<p>事实上，这么做的主要原因是为了提高性能。</p>\n<p>我们直接用反证法来验证：假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？</p>\n<p>现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请，对吧。</p>\n<ol>\n<li>假设事务 A 申请到了 id = 1， 事务 B 申请到 id=2，那么这时候表 t 的自增值是 3，之后继续执行。</li>\n<li>事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id = 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id = 2 的行，而当前的自增 id 值是 1。</li>\n<li>接下来，继续执行的其他事务就会申请到 id=2。这时，就会出现插入语句报错“主键冲突”。</li>\n</ol>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f26f02e60f643c9a7cab88a9f1bdce9~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>而为了解决这个主键冲突，有两种方法：</p>\n<ol>\n<li>每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id</li>\n<li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id</li>\n</ol>\n<p>很显然，上述两个方法的成本都比较高，会导致性能问题。而究其原因呢，是我们假设的这个 “允许自增 id 回退”。</p>\n<p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。</p>\n<p>综上，已经分析了三种自增值不连续的场景，还有第四种场景：批量插入数据。</p>\n<h3>自增值不连续场景 4</h3>\n<p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p>\n<ol>\n<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>\n<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>\n<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>\n<li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>\n</ol>\n<p>注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！，因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p>\n<p>而对于 <code>insert … select</code>、replace … select 和 load data 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种批量申请的策略，毕竟一个一个申请的话实在太慢了。</p>\n<p>举个例子，假设我们现在这个表有下面这些数据：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6453cfc107f94e3bb86c95072d443472~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>我们创建一个和当前表 <code>test_pk</code> 有相同结构定义的表 <code>test_pk2</code>：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45248a6dc34f431bba14d434bee2c79e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>然后使用 <code>insert...select</code> 往 <code>teset_pk2</code> 表中批量插入数据：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1b061e86bae484694d15ceb703b10ca~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>可以看到，成功导入了数据。</p>\n<p>再来看下 <code>test_pk2</code> 的自增值是多少：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ff9039366154c738331d64ebaf88d3b~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如上分析，是 8 而不是 6</p>\n<p>具体来说，insert…select 实际上往表中插入了 5 行数据 （1 1）（2 2）（3 3）（4 4）（5 5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：</p>\n<ul>\n<li>第一次申请到了一个 id：id=1</li>\n<li>第二次被分配了两个 id：id=2 和 id=3</li>\n<li>第三次被分配到了 4 个 id：id=4、id = 5、id = 6、id=7</li>\n</ul>\n<p>由于这条语句实际只用上了 5 个 id，所以 id=6 和 id=7 就被浪费掉了。之后，再执行 <code>insert into test_pk2 values(null,6,6)</code>，实际上插入的数据就是（8,6,6)：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51612fbac3804cff8c5157df21d6e355~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>小结</h2>\n<p>本文总结下自增值不连续的 4 个场景：</p>\n<ol>\n<li>自增初始值和自增步长设置不为 1</li>\n<li>唯一键冲突</li>\n<li>事务回滚</li>\n<li>批量插入（如 <code>insert...select</code> 语句）</li>\n</ol>\n",
      "image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e6b80ba50cb425386b80924e3da0d23~tplv-k3u1fbpfcp-zoom-1.image",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL高性能优化规范建议总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-high-performance-optimization-specification-recommendations.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-high-performance-optimization-specification-recommendations.html",
      "summary": "作者: 听风 原文地址: https://www.cnblogs.com/huchong/p/10219318.html。 JavaGuide 已获得作者授权，并对原文内容进行了完善。 数据库命名规范 所有数据库对象名称必须使用小写字母并用下划线分割 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来...",
      "content_html": "<blockquote>\n<p>作者: 听风 原文地址: <a href=\"https://www.cnblogs.com/huchong/p/10219318.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/huchong/p/10219318.html</a>。</p>\n<p>JavaGuide 已获得作者授权，并对原文内容进行了完善。</p>\n</blockquote>\n<h2>数据库命名规范</h2>\n<ul>\n<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>\n<li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>\n<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>\n<li>临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀，备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀</li>\n<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>\n</ul>\n<h2>数据库基本设计规范</h2>\n<h3>所有表必须使用 InnoDB 存储引擎</h3>\n<p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。</p>\n<p>InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>\n<h3>数据库和表的字符集统一使用 UTF8</h3>\n<p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/horses/article/details/107243447\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 字符集不一致导致索引失效的一个真实案例</a></li>\n<li><a href=\"/Note-Book/database/character-set.html\" target=\"_blank\">MySQL 字符集详解</a></li>\n</ul>\n<h3>所有表和字段都需要添加注释</h3>\n<p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p>\n<h3>尽量控制单表数据量的大小，建议控制在 500 万以内</h3>\n<p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>\n<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>\n<h3>谨慎使用 MySQL 分区表</h3>\n<p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>\n<p>谨慎选择分区键，跨分区查询效率可能更低；</p>\n<p>建议采用物理分表的方式管理大数据。</p>\n<h3>经常一起使用的列放到一个表中</h3>\n<p>避免更多的关联操作。</p>\n<h3>禁止在表中建立预留字段</h3>\n<ul>\n<li>预留字段的命名很难做到见名识义。</li>\n<li>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</li>\n<li>对预留字段类型的修改，会对表进行锁定。</li>\n</ul>\n<h3>禁止在数据库中存储文件（比如图片）这类大的二进制数据</h3>\n<p>在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。</p>\n<p>文件（比如图片）这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息。</p>\n<h3>不要被数据库范式所束缚</h3>\n<p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p>\n<h3>禁止在线上做数据库压力测试</h3>\n<h3>禁止从开发环境,测试环境直接连接生产环境数据库</h3>\n<p>安全隐患极大，要对生产环境抱有敬畏之心！</p>\n<h2>数据库字段设计规范</h2>\n<h3>优先选择符合存储需要的最小的数据类型</h3>\n<p>存储字节越小，占用也就空间越小，性能也越好。</p>\n<p><strong>a.某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据。</strong></p>\n<p>数字是连续的，性能更好，占用空间也更小。</p>\n<p>MySQL 提供了两个方法来处理 ip 地址</p>\n<ul>\n<li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li>\n<li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li>\n</ul>\n<p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p>\n<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。</strong></p>\n<p>无符号相对于有符号可以多出一倍的存储空间</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code>SIGNED <span class=\"token keyword\">INT</span> <span class=\"token operator\">-</span><span class=\"token number\">2147483648</span><span class=\"token operator\">~</span><span class=\"token number\">2147483647</span>\n<span class=\"token keyword\">UNSIGNED</span> <span class=\"token keyword\">INT</span> <span class=\"token number\">0</span><span class=\"token operator\">~</span><span class=\"token number\">4294967295</span>\n</code></pre></div><p><strong>c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p>\n<h3>避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h3>\n<p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p>\n<p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>\n<p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 <code>select *</code>而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>\n<p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p>\n<p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>\n<h3>避免使用 ENUM 类型</h3>\n<ul>\n<li>修改 ENUM 值需要使用 ALTER 语句；</li>\n<li>ENUM 类型的 ORDER BY 操作效率低，需要额外操作；</li>\n<li>ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。</li>\n</ul>\n<p>相关阅读：<a href=\"https://www.zhihu.com/question/404422255/answer/1661698499\" target=\"_blank\" rel=\"noopener noreferrer\">是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎</a> 。</p>\n<h3>尽可能把所有列定义为 NOT NULL</h3>\n<p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p>\n<ul>\n<li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li>\n<li>进行比较和计算时要对 NULL 值做特别的处理。</li>\n</ul>\n<p>相关阅读：<a href=\"https://opensource.actionsky.com/20190710-mysql/\" target=\"_blank\" rel=\"noopener noreferrer\">技术分享 | MySQL 默认值选型（是空，还是 NULL）</a> 。</p>\n<h3>使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h3>\n<p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p>\n<p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p>\n<p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>\n<p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p>\n<ul>\n<li>缺点 1：无法用日期函数进行计算和比较</li>\n<li>缺点 2：用字符串存储日期要占用更多的空间</li>\n</ul>\n<h3>同财务相关的金额类数据必须使用 decimal 类型</h3>\n<ul>\n<li><strong>非精准浮点</strong>：float,double</li>\n<li><strong>精准浮点</strong>：decimal</li>\n</ul>\n<p>decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据</p>\n<p>不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p>\n<h3>单表不要包含过多字段</h3>\n<p>如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。</p>\n<h2>索引设计规范</h2>\n<h3>限制每张表上的索引数量,建议单张表索引不超过 5 个</h3>\n<p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>\n<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>\n<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>\n<h3>禁止使用全文索引</h3>\n<p>全文索引不适用于 OLTP 场景。</p>\n<h3>禁止给表中的每一列都建立单独的索引</h3>\n<p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>\n<h3>每个 InnoDB 表必须有个主键</h3>\n<p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>\n<p>InnoDB 是按照主键索引的顺序来组织表的</p>\n<ul>\n<li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li>\n<li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li>\n<li>主键建议使用自增 ID 值</li>\n</ul>\n<h3>常见索引列建议</h3>\n<ul>\n<li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>\n<li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li>\n<li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li>\n<li>多表 join 的关联列</li>\n</ul>\n<h3>如何选择索引列的顺序</h3>\n<p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>\n<ul>\n<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li>\n<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>\n<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>\n</ul>\n<h3>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h3>\n<ul>\n<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>\n<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>\n</ul>\n<h3>对于频繁的查询优先考虑使用覆盖索引</h3>\n<blockquote>\n<p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p>\n</blockquote>\n<p><strong>覆盖索引的好处：</strong></p>\n<ul>\n<li><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>\n<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL索引详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-index.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-index.html",
      "summary": "感谢WT-AHA对本文的完善，相关 PR：https://github.com/Snailclimb/JavaGuide/pull/1648 。 但凡经历过几场面试的小伙伴，应该都清楚，数据库索引这个知识点在面试中出现的频率高到离谱。 除了对于准备面试来说非常重要之外，善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。 索引...",
      "content_html": "<blockquote>\n<p>感谢<a href=\"https://github.com/WT-AHA\" target=\"_blank\" rel=\"noopener noreferrer\">WT-AHA</a>对本文的完善，相关 PR：https://github.com/Snailclimb/JavaGuide/pull/1648 。</p>\n</blockquote>\n<p>但凡经历过几场面试的小伙伴，应该都清楚，数据库索引这个知识点在面试中出现的频率高到离谱。</p>\n<p>除了对于准备面试来说非常重要之外，善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。</p>\n<h2>索引介绍</h2>\n<p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>\n<p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>\n<p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p>\n<h2>索引的优缺点</h2>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>\n<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>\n<h2>索引底层数据结构选型</h2>\n<h3>Hash 表</h3>\n<p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>\n<p><strong>为何能够通过 key 快速取出 value 呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code>hash <span class=\"token operator\">=</span> <span class=\"token function\">hashfunc</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\nindex <span class=\"token operator\">=</span> hash <span class=\"token operator\">%</span> array_size\n</code></pre></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mysql20210513092328171.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mysql20210513092224836.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p>\n<p>既然哈希表这么快，<strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong> 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p>\n<p>试想一种情况:</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token constant\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token constant\">FROM</span> tb1 <span class=\"token constant\">WHERE</span> id <span class=\"token operator\">&lt;</span> <span class=\"token number\">500</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>\n<h3>二叉查找树(BST)</h3>\n<p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p>\n<ol>\n<li>左子树所有节点的值均小于根节点的值。</li>\n<li>右子树所有节点的值均大于根节点的值。</li>\n<li>左右子树也分别为二叉查找树。</li>\n</ol>\n<p>当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 O(log2(N))，具有比较高的效率。然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为 O（N）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/oblique-tree.png\" alt=\"斜树\" tabindex=\"0\"><figcaption>斜树</figcaption></figure>\n<p>也就是说，<strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p>\n<p>为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。</p>\n<h3>AVL 树</h3>\n<p>AVL 树是计算机科学中最早被发明的自平衡二叉查找树，它的名称来自于发明者 G.M. Adelson-Velsky 和 E.M. Landis 的名字缩写。AVL 树的特点是保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/avl-tree.png\" alt=\"AVL 树\" tabindex=\"0\"><figcaption>AVL 树</figcaption></figure>\n<p>AVL 树采用了旋转操作来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。</p>\n<p>由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</strong></p>\n<p>实际应用中，AVL 树使用的并不多。</p>\n<h3>红黑树</h3>\n<p>红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：</p>\n<ol>\n<li>每个节点非红即黑；</li>\n<li>根节点总是黑色的；</li>\n<li>每个叶子节点都是黑色的空节点（NIL 节点）；</li>\n<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>\n<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/red-black-tree.png\" alt=\"红黑树\" tabindex=\"0\"><figcaption>红黑树</figcaption></figure>\n<p>和 AVL 树不同的是，红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。也正因如此，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。</p>\n<p><strong>红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</strong></p>\n<h3>B 树&amp; B+树</h3>\n<p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>\n<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>\n<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>\n<ul>\n<li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>\n<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>\n<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>\n<li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li>\n</ul>\n<p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>\n<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>\n<blockquote>\n<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p>\n<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>\n</blockquote>\n<h2>索引类型总结</h2>\n<p>按照数据结构维度划分：</p>\n<ul>\n<li>BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</li>\n<li>哈希索引：类似键值对的形式，一次即可定位。</li>\n<li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>\n<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>\n</ul>\n<p>按照底层存储方式角度划分：</p>\n<ul>\n<li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li>\n<li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li>\n</ul>\n<p>按照应用维度划分：</p>\n<ul>\n<li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li>\n<li>普通索引：仅加速查询。</li>\n<li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li>\n<li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li>\n<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>\n<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>\n</ul>\n<p>MySQL 8.x 中实现的索引新特性：</p>\n<ul>\n<li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li>\n<li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li>\n<li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>\n</ul>\n<h2>主键索引(Primary Key)</h2>\n<p>数据表的主键列使用的就是主键索引。</p>\n<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>\n<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/open-source-project/cluster-index.png\" alt=\"主键索引\" tabindex=\"0\"><figcaption>主键索引</figcaption></figure>\n<h2>二级索引</h2>\n<p><strong>二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>\n<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>\n<p>PS: 不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</p>\n<ol>\n<li><strong>唯一索引(Unique Key)</strong>：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>\n<li><strong>普通索引(Index)</strong>：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>\n<li><strong>前缀索引(Prefix)</strong>：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，\n因为只取前几个字符。</li>\n<li><strong>全文索引(Full Text)</strong>：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>\n</ol>\n<p>二级索引:</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/open-source-project/no-cluster-index.png\" alt=\"二级索引\" tabindex=\"0\"><figcaption>二级索引</figcaption></figure>\n<h2>聚簇索引与非聚簇索引</h2>\n<h3>聚簇索引（聚集索引）</h3>\n<h4>聚簇索引介绍</h4>\n<p><strong>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong></p>\n<p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>\n<h4>聚簇索引的优缺点</h4>\n<p><strong>优点</strong>：</p>\n<ul>\n<li><strong>查询速度非常快</strong>：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li>\n<li><strong>对排序查找和范围查找优化</strong>：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>\n<li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>\n</ul>\n<h3>非聚簇索引（非聚集索引）</h3>\n<h4>非聚簇索引介绍</h4>\n<p><strong>非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</strong></p>\n<p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p>\n<h4>非聚簇索引的优缺点</h4>\n<p><strong>优点</strong>：</p>\n<p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li>\n<li><strong>可能会二次查询(回表)</strong>：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>\n</ul>\n<p>这是 MySQL 的表的文件截图:</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mysql20210420165311654.png\" alt=\"MySQL 表的文件\" tabindex=\"0\"><figcaption>MySQL 表的文件</figcaption></figure>\n<p>聚簇索引和非聚簇索引:</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mysql20210420165326946.png\" alt=\"聚簇索引和非聚簇索引\" tabindex=\"0\"><figcaption>聚簇索引和非聚簇索引</figcaption></figure>\n<h4>非聚簇索引一定回表查询吗(覆盖索引)?</h4>\n<p><strong>非聚簇索引不一定回表查询。</strong></p>\n<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code> <span class=\"token keyword\">SELECT</span> name <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">WHERE</span> name<span class=\"token operator\">=</span><span class=\"token string\">'guang19'</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>\n<p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢?</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> id <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>\n<h2>覆盖索引和联合索引</h2>\n<h3>覆盖索引</h3>\n<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 <strong>覆盖索引（Covering Index）</strong> 。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>\n<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>\n<blockquote>\n<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，\n那么直接根据这个索引就可以查到数据，也无需回表。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mysql20210420165341868.png\" alt=\"覆盖索引\" tabindex=\"0\"><figcaption>覆盖索引</figcaption></figure>\n<p>我们这里简单演示一下覆盖索引的效果。</p>\n<p>1、创建一个名为 <code>cus_order</code> 的表，来实际测试一下这种排序方式。为了测试方便， <code>cus_order</code> 这张表只有 <code>id</code>、<code>score</code>、<code>name</code>这 3 个字段。</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>cus_order<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">unsigned</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>score<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>name<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token operator\">=</span><span class=\"token number\">100000</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8mb4<span class=\"token punctuation\">;</span>\n</code></pre></div><p>2、定义一个简单的存储过程（PROCEDURE）来插入 100w 测试数据。</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">DEFINER</span><span class=\"token operator\">=</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>root<span class=\"token punctuation\">`</span></span><span class=\"token variable\">@`%`</span> <span class=\"token keyword\">PROCEDURE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>BatchinsertDataToCusOder<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">IN</span> start_num <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span><span class=\"token operator\">IN</span> max_num <span class=\"token keyword\">INT</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">BEGIN</span>\n      <span class=\"token keyword\">DECLARE</span> i <span class=\"token keyword\">INT</span> <span class=\"token keyword\">default</span> start_num<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">WHILE</span> i <span class=\"token operator\">&lt;</span> max_num <span class=\"token keyword\">DO</span>\n          <span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>cus_order<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>score<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>name<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">values</span> <span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span>RAND<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">,</span>CONCAT<span class=\"token punctuation\">(</span><span class=\"token string\">'user'</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">SET</span> i <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">END</span> <span class=\"token keyword\">WHILE</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">END</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span>\n</code></pre></div><p>存储过程定义完成之后，我们执行存储过程即可！</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">CALL</span> BatchinsertDataToCusOder<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\"># 插入100w+的随机数据</span>\n</code></pre></div><p>等待一会，100w 的测试数据就插入完成了！</p>\n<p>3、创建覆盖索引并使用 <code>EXPLAIN</code> 命令分析。</p>\n<p>为了能够对这 100w 数据按照 <code>score</code> 进行排序，我们需要执行下面的 SQL 语句。</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>score<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>name<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">FROM</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>cus_order<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>score<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">;</span><span class=\"token comment\">#降序排序</span>\n</code></pre></div><p>使用 <code>EXPLAIN</code> 命令分析这条 SQL 语句，通过 <code>Extra</code> 这一列的 <code>Using filesort</code> ，我们发现是没有用到覆盖索引的。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/mysql/not-using-covering-index-demo.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>不过这也是理所应当，毕竟我们现在还没有创建索引呢！</p>\n<p>我们这里以 <code>score</code> 和 <code>name</code> 两个字段建立联合索引：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>cus_order<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> id_score_name<span class=\"token punctuation\">(</span>score<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>创建完成之后，再用 <code>EXPLAIN</code> 命令分析再次分析这条 SQL 语句。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/mysql/using-covering-index-demo.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>通过 <code>Extra</code> 这一列的 <code>Using index</code> ，说明这条 SQL 语句成功使用了覆盖索引。</p>\n<p>关于 <code>EXPLAIN</code> 命令的详细介绍请看：<a href=\"/Note-Book/database/mysql/mysql-query-execution-plan.html\" target=\"_blank\">MySQL 执行计划分析</a>这篇文章。</p>\n<h3>联合索引</h3>\n<p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p>\n<p>以 <code>score</code> 和 <code>name</code> 两个字段建立联合索引：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>cus_order<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> id_score_name<span class=\"token punctuation\">(</span>score<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><h3>最左前缀匹配原则</h3>\n<p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code></strong>、<strong><code>&lt;</code></strong>）才会停止匹配。对于 <strong><code>&gt;=</code></strong>、<strong><code>&lt;=</code></strong>、<strong><code>BETWEEN</code></strong>、<strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>\n<p>相关阅读：<a href=\"https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ\" target=\"_blank\" rel=\"noopener noreferrer\">联合索引的最左匹配原则全网都在说的一个错误结论</a>。</p>\n<h2>索引下推</h2>\n<p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p>\n<h2>正确使用索引的一些建议</h2>\n<h3>选择合适的字段创建索引</h3>\n<ul>\n<li><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>\n<li><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段。</li>\n<li><strong>被作为条件查询的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>\n<li><strong>频繁需要排序的字段</strong>：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>\n<li><strong>被经常频繁用于连接的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>\n</ul>\n<h3>被频繁更新的字段应该慎重建立索引</h3>\n<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>\n<h3>限制每张表上的索引数量</h3>\n<p>索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。</p>\n<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>\n<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>\n<h3>尽可能的考虑建立联合索引而不是单列索引</h3>\n<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>\n<h3>注意避免冗余索引</h3>\n<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>\n<h3>字符串类型的字段使用前缀索引代替普通索引</h3>\n<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>\n<h3>避免索引失效</h3>\n<p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p>\n<ul>\n<li><s>使用 <code>SELECT *</code> 进行查询;</s> <code>SELECT *</code> 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;</li>\n<li>创建了组合索引，但查询条件未遵守最左匹配原则;</li>\n<li>在索引列上进行计算、函数、类型转换等操作;</li>\n<li>以 <code>%</code> 开头的 LIKE 查询比如 <code>like '%abc'</code>;</li>\n<li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li>\n<li>发生<a href=\"/Note-Book/database/mysql/index-invalidation-caused-by-implicit-conversion.html\" target=\"_blank\">隐式转换</a>;</li>\n<li>......</li>\n</ul>\n<h3>删除长期未使用的索引</h3>\n<p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。</p>\n<p>MySQL 5.7 可以通过查询 <code>sys</code> 库的 <code>schema_unused_indexes</code> 视图来查询哪些索引从未被使用。</p>\n<h3>知道如何分析语句是否走索引查询</h3>\n<p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p>\n<p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>\n<p><code>EXPLAIN</code> 的输出格式如下：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code>mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>score<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>name<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">FROM</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>cus_order<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>score<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">+</span></code></pre></div>",
      "image": "https://oss.javaguide.cn/github/javaguide/database/mysql20210513092328171.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL三大日志(binlog、redo log和undo log)详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-logs.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-logs.html",
      "summary": "本文来自公号程序猿阿星投稿，JavaGuide 对其做了补充完善。 前言 MySQL 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 binlog（归档日志）和事务日志 redo log（重做日志）和 undo log（回滚日志）。 今天就来聊聊 redo log（重做日志）、binlog（归...",
      "content_html": "<blockquote>\n<p>本文来自公号程序猿阿星投稿，JavaGuide 对其做了补充完善。</p>\n</blockquote>\n<h2>前言</h2>\n<p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/01.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>今天就来聊聊 <code>redo log</code>（重做日志）、<code>binlog</code>（归档日志）、两阶段提交、<code>undo log</code> （回滚日志）。</p>\n<h2>redo log</h2>\n<p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>\n<p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/02.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>\n<p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>\n<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p>\n<p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/03.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<blockquote>\n<p>图片笔误提示：第 4 步 “清空 redo log buffe 刷盘到 redo 日志中”这句话中的 buffe 应该是 buffer。</p>\n</blockquote>\n<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>\n<blockquote>\n<p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>\n</blockquote>\n<h3>刷盘时机</h3>\n<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>\n<ul>\n<li><strong>0</strong>：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li>\n<li><strong>1</strong>：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>\n<li><strong>2</strong>：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>\n</ul>\n<p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p>\n<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/04.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p>\n<p><strong>为什么呢？</strong></p>\n<p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/05.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。</p>\n<p>下面是不同刷盘策略的流程图。</p>\n<h4>innodb_flush_log_at_trx_commit=0</h4>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/06.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p>\n<h4>innodb_flush_log_at_trx_commit=1</h4>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/07.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>\n<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p>\n<h4>innodb_flush_log_at_trx_commit=2</h4>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/09.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>\n<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p>\n<h3>日志文件组</h3>\n<p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>\n<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p>\n<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/10.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p>\n<ul>\n<li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li>\n<li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li>\n</ul>\n<p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p>\n<p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p>\n<p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/11.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/12.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>redo log 小结</h3>\n<p>相信大家都知道 <code>redo log</code> 的作用和它的刷盘时机、存储形式。</p>\n<p>现在我们来思考一个问题：<strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>\n<p>它们不都是刷盘么？差别在哪里？</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token number\">1</span> <span class=\"token class-name\">Byte</span> <span class=\"token operator\">=</span> <span class=\"token number\">8</span>bit\n<span class=\"token number\">1</span> <span class=\"token constant\">KB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token class-name\">Byte</span>\n<span class=\"token number\">1</span> <span class=\"token constant\">MB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token constant\">KB</span>\n<span class=\"token number\">1</span> <span class=\"token constant\">GB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token constant\">MB</span>\n<span class=\"token number\">1</span> <span class=\"token constant\">TB</span> <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token constant\">GB</span>\n</code></pre></div><p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p>\n<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>\n<p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移\n量、更新值，再加上是顺序写，所以刷盘速度很快。</p>\n<p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>\n<blockquote>\n<p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲 <code>Buffer Pool</code>的时候会对这块细说</p>\n</blockquote>\n<h2>binlog</h2>\n<p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>\n<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>\n<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p>\n<p>那 <code>binlog</code> 到底是用来干嘛的？</p>\n<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/01-20220305234724956.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>\n<h3>记录格式</h3>\n<p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>\n<ul>\n<li><strong>statement</strong></li>\n<li><strong>row</strong></li>\n<li><strong>mixed</strong></li>\n</ul>\n<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/02-20220305234738688.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>\n<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/03-20220305234742460.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>\n<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>\n<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>\n<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>\n<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>\n<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>\n<h3>写入机制</h3>\n<p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p>\n<p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>\n<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p>\n<p><code>binlog</code>日志刷盘流程如下</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/04-20220305234747840.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<ul>\n<li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>\n<li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li>\n</ul>\n<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p>\n<p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/05-20220305234754405.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binlog 会丢失。</p>\n<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</p>\n<p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/06-20220305234801592.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在出现<code>IO</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p>\n<p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</p>\n<h2>两阶段提交</h2>\n<p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>\n<p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>\n<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>\n<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/01-20220305234816065.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>回到正题，<code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</p>\n<p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p>\n<p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/02-20220305234828662.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/03-20220305235104445.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p>\n<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/04-20220305234956774.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/05-20220305234937243.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/06-20220305234907651.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p>\n<h2>undo log</h2>\n<blockquote>\n<p>这部分内容为 JavaGuide 的补充：</p>\n</blockquote>\n<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>\n<p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>\n<h2>总结</h2>\n<blockquote>\n<p>这部分内容为 JavaGuide 的补充：</p>\n</blockquote>\n<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>\n<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>\n<h2>站在巨人的肩膀上</h2>\n<ul>\n<li>《MySQL 实战 45 讲》</li>\n<li>《从零开始带你成为 MySQL 实战优化高手》</li>\n<li>《MySQL 是怎样运行的：从根儿上理解 MySQL》</li>\n<li>《MySQL 技术 Innodb 存储引擎》</li>\n</ul>\n<h2>MySQL 好文推荐</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/R-1km7r0z3oWfwYQV8iiqA\" target=\"_blank\" rel=\"noopener noreferrer\">CURD 这么多年，你有了解过 MySQL 的架构设计吗？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/7Kab4IQsNcU_bZdbv_MuOg\" target=\"_blank\" rel=\"noopener noreferrer\">浅谈 MySQL InnoDB 的内存组件</a></li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/01.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL查询缓存详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-query-cache.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-query-cache.html",
      "summary": "缓存是一个有效且实用的系统性能优化的手段，不论是操作系统还是各种软件和网站或多或少都用到了缓存。 然而，有经验的 DBA 都建议生产环境中把 MySQL 自带的 Query Cache（查询缓存）给关掉。而且，从 MySQL 5.7.20 开始，就已经默认弃用查询缓存了。在 MySQL 8.0 及之后，更是直接删除了查询缓存的功能。 这又是为什么呢？查...",
      "content_html": "<p>缓存是一个有效且实用的系统性能优化的手段，不论是操作系统还是各种软件和网站或多或少都用到了缓存。</p>\n<p>然而，有经验的 DBA 都建议生产环境中把 MySQL 自带的 Query Cache（查询缓存）给关掉。而且，从 MySQL 5.7.20 开始，就已经默认弃用查询缓存了。在 MySQL 8.0 及之后，更是直接删除了查询缓存的功能。</p>\n<p>这又是为什么呢？查询缓存真就这么鸡肋么?</p>\n<p>带着如下几个问题，我们正式进入本文。</p>\n<ul>\n<li>MySQL 查询缓存是什么？适用范围？</li>\n<li>MySQL 缓存规则是什么？</li>\n<li>MySQL 缓存的优缺点是什么？</li>\n<li>MySQL 缓存对性能有什么影响？</li>\n</ul>\n<h2>MySQL 查询缓存介绍</h2>\n<p>MySQL 体系架构如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/mysql/mysql-architecture.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为了提高完全相同的查询语句的响应速度，MySQL Server 会对查询语句进行 Hash 计算得到一个 Hash 值。MySQL Server 不会对 SQL 做任何处理，SQL 必须完全一致 Hash 值才会一样。得到 Hash 值之后，通过该 Hash 值到查询缓存中匹配该查询的结果。</p>\n<ul>\n<li>如果匹配（命中），则将查询的结果集直接返回给客户端，不必再解析、执行查询。</li>\n<li>如果没有匹配（未命中），则将 Hash 值和结果集保存在查询缓存中，以便以后使用。</li>\n</ul>\n<p>也就是说，<strong>一个查询语句（select）到了 MySQL Server 之后，会先到查询缓存看看，如果曾经执行过的话，就直接返回结果集给客户端。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>MySQL 查询缓存管理和配置</h2>\n<p>通过 <code>show variables like '%query_cache%'</code>命令可以查看查询缓存相关的信息。</p>\n<p>8.0 版本之前的话，打印的信息可能是下面这样的：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code>mysql<span class=\"token operator\">&gt;</span> show variables like <span class=\"token string\">'%query_cache%'</span><span class=\"token punctuation\">;</span>\n+</code></pre></div>",
      "image": "https://oss.javaguide.cn/github/javaguide/mysql/mysql-architecture.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL执行计划分析",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-query-execution-plan.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-query-execution-plan.html",
      "summary": "本文来自公号 MySQL 技术，JavaGuide 对其做了补充完善。原文地址：https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g 优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL EXPLAIN 执行计划相关知识。 什么是执行计划？ 执行计划 是指一条 SQL...",
      "content_html": "<blockquote>\n<p>本文来自公号 MySQL 技术，JavaGuide 对其做了补充完善。原文地址：https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g</p>\n</blockquote>\n<p>优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL <code>EXPLAIN</code> 执行计划相关知识。</p>\n<h2>什么是执行计划？</h2>\n<p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化会后，具体的执行方式。</p>\n<p>执行计划通常用于 SQL 性能分析、优化等场景。通过 <code>EXPLAIN</code> 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。</p>\n<h2>如何获取执行计划？</h2>\n<p>MySQL 为我们提供了 <code>EXPLAIN</code> 命令，来获取执行计划的相关信息。</p>\n<p>需要注意的是，<code>EXPLAIN</code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>\n<p><code>EXPLAIN</code> 执行计划支持 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句。我们一般多用于分析 <code>SELECT</code> 查询语句，使用起来非常简单，语法如下：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">EXPLAIN</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">SELECT</span> 查询语句；\n</code></pre></div><p>我们简单来看下一条查询语句的执行计划：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code>mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">explain</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> dept_emp <span class=\"token keyword\">WHERE</span> emp_no <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> emp_no <span class=\"token keyword\">FROM</span> dept_emp <span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> emp_no <span class=\"token keyword\">HAVING</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>emp_no<span class=\"token punctuation\">)</span><span class=\"token operator\">&gt;</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">+</span></code></pre></div>",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL常见面试题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-questions-01.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/mysql-questions-01.html",
      "summary": "MySQL 基础 什么是关系型数据库？ 顾名思义，关系型数据库（RDBMS，Relational Database Management System）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。 关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数...",
      "content_html": "<h2>MySQL 基础</h2>\n<h3>什么是关系型数据库？</h3>\n<p>顾名思义，关系型数据库（RDBMS，Relational Database Management System）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p>\n<p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png\" alt=\"关系型数据库表关系\" tabindex=\"0\"><figcaption>关系型数据库表关系</figcaption></figure>\n<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</p>\n<p><strong>有哪些常见的关系型数据库呢？</strong></p>\n<p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ......。</p>\n<h3>什么是 SQL？</h3>\n<p>SQL 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。</p>\n<p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p>\n<p>SQL 可以帮助我们：</p>\n<ul>\n<li>新建数据库、数据表、字段；</li>\n<li>在数据库中增加，删除，修改，查询数据；</li>\n<li>新建视图、函数、存储过程；</li>\n<li>对数据库中的数据进行简单的数据分析；</li>\n<li>搭配 Hive，Spark SQL 做大数据；</li>\n<li>搭配 SQLFlow 做机器学习；</li>\n<li>......</li>\n</ul>\n<h3>什么是 MySQL？</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/20210327143351823.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p>\n<p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong>3306</strong>。</p>\n<h3>MySQL 有什么优点？</h3>\n<p>这个问题本质上是在问 MySQL 如此流行的原因。</p>\n<p>MySQL 主要具有下面这些优点：</p>\n<ol>\n<li>成熟稳定，功能完善。</li>\n<li>开源免费。</li>\n<li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li>\n<li>开箱即用，操作简单，维护成本低。</li>\n<li>兼容性好，支持常见的操作系统，支持多种开发语言。</li>\n<li>社区活跃，生态完善。</li>\n<li>事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li>\n<li>支持分库分表、读写分离、高可用。</li>\n</ol>\n<h2>MySQL 基础架构</h2>\n<blockquote>\n<p>建议配合 <a href=\"/Note-Book/database/mysql/how-sql-executed-in-mysql.html\" target=\"_blank\">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。另外，“一个 SQL 语句在 MySQL 中的执行流程”也是面试中比较常问的一个问题。</p>\n</blockquote>\n<p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>从上图可以看出， MySQL 主要由下面几部分构成：</p>\n<ul>\n<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>\n<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>\n<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>\n<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>\n<li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li>\n<li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>\n</ul>\n<h2>MySQL 存储引擎</h2>\n<p>MySQL 核心在于存储引擎，想要深入学习 MySQL，必定要深入研究 MySQL 存储引擎。</p>\n<h3>MySQL 支持哪些存储引擎？默认使用哪个？</h3>\n<p>MySQL 支持多种存储引擎，你可以通过 <code>SHOW ENGINES</code> 命令来查看 MySQL 支持的所有存储引擎。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/mysql/image-20220510105408703.png\" alt=\"查看 MySQL 提供的所有存储引擎\" tabindex=\"0\"><figcaption>查看 MySQL 提供的所有存储引擎</figcaption></figure>\n<p>从上图我们可以查看出， MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>\n<p>我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。</p>\n<p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>\n<p>你可以通过 <code>SELECT VERSION()</code> 命令查看你的 MySQL 版本。</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code>mysql<span class=\"token operator\">&gt;</span> SELECT VERSION<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n+</code></pre></div>",
      "image": "https://oss.javaguide.cn/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL时间类型数据存储建议",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/some-thoughts-on-database-storage-time.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/some-thoughts-on-database-storage-time.html",
      "summary": "我们平时开发中不可避免的就是要存储时间，比如我们要记录操作表中这条记录的时间、记录转账的交易时间、记录出发时间等等。你会发现时间这个东西与我们开发的联系还是非常紧密的，用的好与不好会给我们的业务甚至功能带来很大的影响。所以，我们有必要重新出发，好好认识一下这个东西。 这是一篇短小精悍的文章，仔细阅读一定能学到不少东西！ 不要用字符串存储日期 我记得我在...",
      "content_html": "<p>我们平时开发中不可避免的就是要存储时间，比如我们要记录操作表中这条记录的时间、记录转账的交易时间、记录出发时间等等。你会发现时间这个东西与我们开发的联系还是非常紧密的，用的好与不好会给我们的业务甚至功能带来很大的影响。所以，我们有必要重新出发，好好认识一下这个东西。</p>\n<p>这是一篇短小精悍的文章，仔细阅读一定能学到不少东西！</p>\n<h2>不要用字符串存储日期</h2>\n<p>我记得我在大学的时候就这样干过，而且现在很多对数据库不太了解的新手也会这样干，可见，这种存储日期的方式的优点还是有的，就是简单直白，容易上手。</p>\n<p>但是，这是不正确的做法，主要会有下面两个问题：</p>\n<ol>\n<li>字符串占用的空间更大！</li>\n<li>字符串存储的日期效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较。</li>\n</ol>\n<h2>Datetime 和 Timestamp 之间抉择</h2>\n<p>Datetime 和 Timestamp 是 MySQL 提供的两种比较相似的保存时间的数据类型。他们两者究竟该如何选择呢？</p>\n<p><strong>通常我们都会首选 Timestamp。</strong> 下面说一下为什么这样做!</p>\n<h3>DateTime 类型没有时区信息</h3>\n<p><strong>DateTime 类型是没有时区信息的（时区无关）</strong> ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。</p>\n<p><strong>Timestamp 和时区有关</strong>。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。</p>\n<p>下面实际演示一下！</p>\n<p>建表 SQL 语句：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>time_zone_test<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>date_time<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">datetime</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>time_stamp<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">timestamp</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CURRENT_TIMESTAMP</span> <span class=\"token keyword\">ON</span> <span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">CURRENT_TIMESTAMP</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n</code></pre></div><p>插入数据：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> time_zone_test<span class=\"token punctuation\">(</span>date_time<span class=\"token punctuation\">,</span>time_stamp<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span><span class=\"token function\">NOW</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">NOW</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>查看数据：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">select</span> date_time<span class=\"token punctuation\">,</span>time_stamp <span class=\"token keyword\">from</span> time_zone_test<span class=\"token punctuation\">;</span>\n</code></pre></div><p>结果：</p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>+</code></pre></div>",
      "image": "https://oss.javaguide.cn/github/javaguide/FhRGUVHFK0ujRPNA75f6CuOXQHTE.jpeg",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL事务隔离级别详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/transaction-isolation-level.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/mysql/transaction-isolation-level.html",
      "summary": "本文由 SnailClimb 和 guang19 共同完成。 关于事务基本概览的介绍，请看这篇文章的介绍： 事务隔离级别总结 SQL 标准定义了四个隔离级别： READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)：允许读取并发事务已经提...",
      "content_html": "<blockquote>\n<p>本文由 <a href=\"https://github.com/Snailclimb\" target=\"_blank\" rel=\"noopener noreferrer\">SnailClimb</a> 和 <a href=\"https://github.com/guang19\" target=\"_blank\" rel=\"noopener noreferrer\">guang19</a> 共同完成。</p>\n</blockquote>\n<p>关于事务基本概览的介绍，请看这篇文章的介绍：<a href=\"/Note-Book/database/mysql/mysql-questions-01.html#MySQL-%E4%BA%8B%E5%8A%A1\" target=\"_blank\">MySQL 常见知识点&amp;面试题总结</a></p>\n<h2>事务隔离级别总结</h2>\n<p>SQL 标准定义了四个隔离级别：</p>\n<ul>\n<li><strong>READ-UNCOMMITTED(读取未提交)</strong>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>\n<li><strong>READ-COMMITTED(读取已提交)</strong>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>\n<li><strong>REPEATABLE-READ(可重复读)</strong>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>\n<li><strong>SERIALIZABLE(可串行化)</strong>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "3种常用的缓存读写策略详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/3-commonly-used-cache-read-and-write-strategies.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/3-commonly-used-cache-read-and-write-strategies.html",
      "summary": "看到很多小伙伴简历上写了“熟练使用缓存”，但是被我问到“缓存常用的 3 种读写策略”的时候却一脸懵逼。 在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单了写一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。 但是，搞懂 3 种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！ 下面...",
      "content_html": "<p>看到很多小伙伴简历上写了“<strong>熟练使用缓存</strong>”，但是被我问到“<strong>缓存常用的 3 种读写策略</strong>”的时候却一脸懵逼。</p>\n<p>在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单了写一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。</p>\n<p>但是，搞懂 3 种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！</p>\n<p><strong>下面介绍到的三种模式各有优劣，不存在最佳模式，根据具体的业务场景选择适合自己的缓存读写模式。</strong></p>\n<h3>Cache Aside Pattern（旁路缓存模式）</h3>\n<p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>\n<p>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。</p>\n<p>下面我们来看一下这个策略模式下的缓存读写步骤。</p>\n<p><strong>写</strong>：</p>\n<ul>\n<li>先更新 db</li>\n<li>然后直接删除 cache 。</li>\n</ul>\n<p>简单画了一张图帮助大家理解写的步骤。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-write.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>读</strong> :</p>\n<ul>\n<li>从 cache 中读取数据，读取到就直接返回</li>\n<li>cache 中读取不到的话，就从 db 中读取数据返回</li>\n<li>再把数据放到 cache 中。</li>\n</ul>\n<p>简单画了一张图帮助大家理解读的步骤。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-read.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。</p>\n<p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong>”</p>\n<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>的问题。</p>\n<p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。</p>\n<p>这个过程可以简单描述为：</p>\n<blockquote>\n<p>请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p>\n</blockquote>\n<p>当你这样回答之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong>”</p>\n<p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p>\n<p>举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。</p>\n<p>这个过程可以简单描述为：</p>\n<blockquote>\n<p>请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -&gt; 请求 1 将数据 A 写入 cache</p>\n</blockquote>\n<p>现在我们再来分析一下 <strong>Cache Aside Pattern 的缺陷</strong>。</p>\n<p><strong>缺陷 1：首次请求数据一定不在 cache 的问题</strong></p>\n<p>解决办法：可以将热点数据可以提前放入 cache 中。</p>\n<p><strong>缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>\n<p>解决办法：</p>\n<ul>\n<li>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。</li>\n<li>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>\n</ul>\n<h3>Read/Write Through Pattern（读写穿透）</h3>\n<p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p>\n<p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。</p>\n<p><strong>写（Write Through）：</strong></p>\n<ul>\n<li>先查 cache，cache 中不存在，直接更新 db。</li>\n<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li>\n</ul>\n<p>简单画了一张图帮助大家理解写的步骤。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/write-through.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>读(Read Through)：</strong></p>\n<ul>\n<li>从 cache 中读取数据，读取到就直接返回 。</li>\n<li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li>\n</ul>\n<p>简单画了一张图帮助大家理解读的步骤。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/read-through.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>\n<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>\n<h3>Write Behind Pattern（异步缓存写入）</h3>\n<p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</p>\n<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></p>\n<p>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</p>\n<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</p>\n<p>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-write.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis常见阻塞原因总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-common-blocking-problems-summary.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-common-blocking-problems-summary.html",
      "summary": "本文整理完善自：https://mp.weixin.qq.com/s/0Nqfq_eQrUb12QH6eBbHXA ，作者：阿 Q 说代码 这篇文章会详细总结一下可能导致 Redis 阻塞的情况，这些情况也是影响 Redis 性能的关键因素，使用 Redis 的时候应该格外注意！ O(n) 命令 Redis 中的大部分命令都是 O(1)时间复杂度，但也...",
      "content_html": "<blockquote>\n<p>本文整理完善自：https://mp.weixin.qq.com/s/0Nqfq_eQrUb12QH6eBbHXA ，作者：阿 Q 说代码</p>\n</blockquote>\n<p>这篇文章会详细总结一下可能导致 Redis 阻塞的情况，这些情况也是影响 Redis 性能的关键因素，使用 Redis 的时候应该格外注意！</p>\n<h2>O(n) 命令</h2>\n<p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>\n<ul>\n<li><code>KEYS *</code>：会返回所有符合规则的 key。</li>\n<li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li>\n<li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li>\n<li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li>\n<li><code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>：计算多个 Set 的交集/并集/差集。</li>\n<li>......</li>\n</ul>\n<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>\n<p>除了这些 O(n)时间复杂度的命令可能会导致阻塞之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>\n<ul>\n<li><code>ZRANGE</code>/<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>\n<li><code>ZREMRANGEBYRANK</code>/<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>\n<li>......</li>\n</ul>\n<h2>SAVE 创建 RDB 快照</h2>\n<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>\n<ul>\n<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li>\n<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>\n</ul>\n<p>默认情况下，Redis 默认配置会使用 <code>bgsave</code> 命令。如果手动使用 <code>save</code> 命令生成 RDB 快照文件的话，就会阻塞主线程。</p>\n<h2>AOF</h2>\n<h3>AOF 日志记录阻塞</h3>\n<p>Redis AOF 持久化机制是在执行完命令之后再记录日志，这和关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复）不同。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-aof-write-log-disc.png\" alt=\"AOF 记录日志过程\" tabindex=\"0\"><figcaption>AOF 记录日志过程</figcaption></figure>\n<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>\n<ul>\n<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>\n<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>\n</ul>\n<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>\n<ul>\n<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>\n<li><strong>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）</strong>。</li>\n</ul>\n<h3>AOF 刷盘阻塞</h3>\n<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>\n<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>\n<ol>\n<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>\n<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>\n<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>\n</ol>\n<p>当后台线程（ <code>aof_fsync</code> 线程）调用 <code>fsync</code> 函数同步 AOF 文件时，需要等待，直到写入完成。当磁盘压力太大的时候，会导致 <code>fsync</code> 操作发生阻塞，主线程调用 <code>write</code> 函数时也会被阻塞。<code>fsync</code> 完成后，主线程执行 <code>write</code> 才能成功返回。</p>\n<p>关于 AOF 工作流程的详细介绍可以查看：<a href=\"/Note-Book/database/redis/redis-persistence.html\" target=\"_blank\">Redis 持久化机制详解</a>，有助于理解 AOF 刷盘阻塞。</p>\n<h3>AOF 重写阻塞</h3>\n<ol>\n<li>fork 出一条子线程来将文件重写，在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。</li>\n<li>当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</li>\n<li>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</li>\n</ol>\n<p>阻塞就是出现在第 2 步的过程中，将缓冲区中新数据写到新文件的过程中会产生<strong>阻塞</strong>。</p>\n<p>相关阅读：<a href=\"https://cloud.tencent.com/developer/article/1633077\" target=\"_blank\" rel=\"noopener noreferrer\">Redis AOF 重写阻塞问题分析</a>。</p>\n<h2>大 Key</h2>\n<p>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>\n<p>大 key 造成的阻塞问题如下：</p>\n<ul>\n<li>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>\n<li>引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>\n<li>阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>\n</ul>\n<h3>查找大 key</h3>\n<p>当我们在使用 Redis 自带的 <code>--bigkeys</code> 参数查找大 key 时，最好选择在从节点上执行该命令，因为主节点上执行时，会<strong>阻塞</strong>主节点。</p>\n<ul>\n<li>\n<p>我们还可以使用 SCAN 命令来查找大 key；</p>\n</li>\n<li>\n<p>通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具：</p>\n</li>\n<li>\n<ul>\n<li>redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>\n<li>rdb_bigkeys：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>\n</ul>\n</li>\n</ul>\n<h3>删除大 key</h3>\n<p>删除操作的本质是要释放键值对占用的内存空间。</p>\n<p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会<strong>阻塞</strong>当前释放内存的应用程序。</p>\n<p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p>\n<p>删除大 key 时建议采用分批次删除和异步删除的方式进行。</p>\n<h2>清空数据库</h2>\n<p>清空数据库和上面 bigkey 删除也是同样道理，<code>flushdb</code>、<code>flushall</code> 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。</p>\n<h2>集群扩容</h2>\n<p>Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。</p>\n<p>在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作。</p>\n<p>执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。</p>\n<h2>Swap（内存交换）</h2>\n<p><strong>什么是 Swap？</strong> Swap 直译过来是交换的意思，Linux 中的 Swap 常被称为内存交换或者交换分区。类似于 Windows 中的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况。因此，Swap 分区的作用就是牺牲硬盘，增加内存，解决 VPS 内存不够用或者爆满的问题。</p>\n<p>Swap 对于 Redis 来说是非常致命的，Redis 保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把 Redis 使用的部分内存换出硬盘，由于内存与硬盘读写的速度并几个数量级，会导致发生交换后的 Redis 性能急剧下降。</p>\n<p>识别 Redis 发生 Swap 的检查方法如下：</p>\n<p>1、查询 Redis 进程号</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code>reids-cli <span class=\"token parameter variable\">-p</span> <span class=\"token number\">6383</span> info server <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> process_id\nprocess_id: <span class=\"token number\">4476</span>\n</code></pre></div><p>2、根据进程号查询内存交换信息</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token function\">cat</span> /proc/4476/smaps <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> Swap\nSwap: 0kB\nSwap: 0kB\nSwap: 4kB\nSwap: 0kB\nSwap: 0kB\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>.\n</code></pre></div><p>如果交换量都是 0KB 或者个别的是 4KB，则正常。</p>\n<p>预防内存交换的方法：</p>\n<ul>\n<li>保证机器充足的可用内存</li>\n<li>确保所有 Redis 实例设置最大可用内存(maxmemory)，防止极端情况 Redis 内存不可控的增长</li>\n<li>降低系统使用 swap 优先级，如<code>echo 10 &gt; /proc/sys/vm/swappiness</code></li>\n</ul>\n<h2>CPU 竞争</h2>\n<p>Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。</p>\n<p>可以通过<code>reids-cli --stat</code>获取当前 Redis 使用情况。通过<code>top</code>命令获取进程对 CPU 的利用率等信息 通过<code>info commandstats</code>统计信息分析出命令不合理开销时间，查看是否是因为高算法复杂度或者过度的内存优化问题。</p>\n<h2>网络问题</h2>\n<p>连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</p>\n<h2>参考</h2>\n<ul>\n<li>Redis 阻塞的 6 大类场景分析与总结：https://mp.weixin.qq.com/s/eaZCEtTjTuEmXfUubVHjew</li>\n<li>Redis 开发与运维笔记-Redis 的噩梦-阻塞：https://mp.weixin.qq.com/s/TDbpz9oLH6ifVv6ewqgSgA</li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/redis-aof-write-log-disc.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis 5 种基本数据结构详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-data-structures-01.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-data-structures-01.html",
      "summary": "Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。 这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）...",
      "content_html": "<p>Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>\n<p>这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p>\n<p>Redis 基本数据结构的底层数据结构实现如下：</p>\n<p>| String | List                         | Hash                | Set             | Zset              |\n| :</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720181630203.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis 3 种特殊数据结构详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-data-structures-02.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-data-structures-02.html",
      "summary": "除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构：Bitmap、HyperLogLog、GEO。 Bitmap 介绍 Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以...",
      "content_html": "<p>除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构：Bitmap、HyperLogLog、GEO。</p>\n<h2>Bitmap</h2>\n<h3>介绍</h3>\n<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>\n<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>常用命令</h3>\n<p>| 命令                                  | 介绍                                                             |\n|</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis内存碎片详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-memory-fragmentation.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-memory-fragmentation.html",
      "summary": "什么是内存碎片? 你可以将内存碎片简单地理解为那些不可用的空闲内存。 举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。 内存碎片内存碎片 Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存...",
      "content_html": "<h2>什么是内存碎片?</h2>\n<p>你可以将内存碎片简单地理解为那些不可用的空闲内存。</p>\n<p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/memory-fragmentation.png\" alt=\"内存碎片\" tabindex=\"0\"><figcaption>内存碎片</figcaption></figure>\n<p>Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。</p>\n<h2>为什么会有 Redis 内存碎片?</h2>\n<p>Redis 内存碎片产生比较常见的 2 个原因：</p>\n<p><strong>1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</strong></p>\n<p>以下是这段 Redis 官方的原话：</p>\n<blockquote>\n<p>To store user keys, Redis allocates at most as much memory as the <code>maxmemory</code> setting enables (however there are small extra allocations possible).</p>\n</blockquote>\n<p>Redis 使用 <code>zmalloc</code> 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 <code>size</code> 大小的内存之外，还会多分配 <code>PREFIX_SIZE</code> 大小的内存。</p>\n<p><code>zmalloc</code> 方法源码如下（源码地址：https://github.com/antirez/redis-tools/blob/master/zmalloc.c）：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">zmalloc</span><span class=\"token punctuation\">(</span>size_t size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// 分配指定大小的内存</span>\n   <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>size<span class=\"token operator\">+</span><span class=\"token constant\">PREFIX_SIZE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ptr<span class=\"token punctuation\">)</span> <span class=\"token function\">zmalloc_oom_handler</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n#ifdef <span class=\"token class-name\">HAVE_MALLOC_SIZE</span>\n   <span class=\"token function\">update_zmalloc_stat_alloc</span><span class=\"token punctuation\">(</span><span class=\"token function\">zmalloc_size</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> ptr<span class=\"token punctuation\">;</span>\n#<span class=\"token keyword\">else</span>\n   <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>size_t<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ptr<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n   <span class=\"token function\">update_zmalloc_stat_alloc</span><span class=\"token punctuation\">(</span>size<span class=\"token operator\">+</span><span class=\"token constant\">PREFIX_SIZE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ptr<span class=\"token operator\">+</span><span class=\"token constant\">PREFIX_SIZE</span><span class=\"token punctuation\">;</span>\n#endif\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 <a href=\"https://github.com/jemalloc/jemalloc\" target=\"_blank\" rel=\"noopener noreferrer\">jemalloc</a>，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节......）来分配内存的。jemalloc 划分的内存单元如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/6803d3929e3e46c1b1c9d0bb9ee8e717.png\" alt=\"jemalloc 内存单元示意图\" tabindex=\"0\"><figcaption>jemalloc 内存单元示意图</figcaption></figure>\n<p>当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题。</p>\n<p><strong>2、频繁修改 Redis 中的数据也会产生内存碎片。</strong></p>\n<p>当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</p>\n<p>这个在 Redis 官方文档中也有对应的原话:</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/redis-docs-memory-optimization.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>文档地址：https://redis.io/topics/memory-optimization 。</p>\n<h2>如何查看 Redis 内存碎片的信息？</h2>\n<p>使用 <code>info memory</code> 命令即可查看 Redis 内存相关的信息。下图中每个参数具体的含义，Redis 官方文档有详细的介绍：https://redis.io/commands/INFO 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/redis-info-memory.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Redis 内存碎片率的计算公式：<code>mem_fragmentation_ratio</code> （内存碎片率）= <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)/ <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>\n<p>也就是说，<code>mem_fragmentation_ratio</code> （内存碎片率）的值越大代表内存碎片率越严重。</p>\n<p>一定不要误认为<code>used_memory_rss</code> 减去 <code>used_memory</code>值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p>\n<p>很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。</p>\n<p>通常情况下，我们认为 <code>mem_fragmentation_ratio &gt; 1.5</code> 的话才需要清理内存碎片。 <code>mem_fragmentation_ratio &gt; 1.5</code> 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。</p>\n<p>如果想要快速查看内存碎片率的话，你还可以通过下面这个命令：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token operator\">&gt;</span> redis-cli <span class=\"token parameter variable\">-p</span> <span class=\"token number\">6379</span> info <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> mem_fragmentation_ratio\n</code></pre></div><p>另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 <a href=\"https://mp.weixin.qq.com/s/drlDvp7bfq5jt2M5pTqJCw\" target=\"_blank\" rel=\"noopener noreferrer\">故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区</a> 。</p>\n<h2>如何清理 Redis 内存碎片？</h2>\n<p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p>\n<p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code>config <span class=\"token builtin class-name\">set</span> activedefrag <span class=\"token function\">yes</span>\n</code></pre></div><p>具体什么时候清理需要通过下面两个参数控制：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token comment\"># 内存碎片占用空间达到 500mb 的时候开始清理</span>\nconfig <span class=\"token builtin class-name\">set</span> active-defrag-ignore-bytes 500mb\n<span class=\"token comment\"># 内存碎片率大于 1.5 的时候开始清理</span>\nconfig <span class=\"token builtin class-name\">set</span> active-defrag-threshold-lower <span class=\"token number\">50</span>\n</code></pre></div><p>通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token comment\"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span>\nconfig <span class=\"token builtin class-name\">set</span> active-defrag-cycle-min <span class=\"token number\">20</span>\n<span class=\"token comment\"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span>\nconfig <span class=\"token builtin class-name\">set</span> active-defrag-cycle-max <span class=\"token number\">50</span>\n</code></pre></div><p>另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</p>\n<h2>参考</h2>\n<ul>\n<li>Redis 官方文档：https://redis.io/topics/memory-optimization</li>\n<li>Redis 核心技术与实战 - 极客时间 - 删除数据后，为什么内存占用率还是很高？：https://time.geekbang.org/column/article/289140</li>\n<li>Redis 源码解析——内存分配：<a href=\"https://shinerio.cc/2020/05/17/redis/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\" target=\"_blank\" rel=\"noopener noreferrer\">https://shinerio.cc/2020/05/17/redis/Redis源码解析——内存管理</a></li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/memory-fragmentation.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis持久化机制详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-persistence.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-persistence.html",
      "summary": "使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。 Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式: 快...",
      "content_html": "<p>使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。</p>\n<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>\n<ul>\n<li>快照（snapshotting，RDB）</li>\n<li>只追加文件（append-only file, AOF）</li>\n<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>\n</ul>\n<p>官方文档地址：https://redis.io/topics/persistence 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-persitence.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>RDB 持久化</h2>\n<h3>什么是 RDB 持久化？</h3>\n<p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>\n<p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>\n<div class=\"language-clojure\" data-ext=\"clojure\" data-title=\"clojure\"><pre class=\"language-clojure\"><code>save <span class=\"token number\">900</span> <span class=\"token number\">1</span>           <span class=\"token operator\">#</span>在<span class=\"token number\">900</span>秒<span class=\"token punctuation\">(</span><span class=\"token number\">15</span>分钟<span class=\"token punctuation\">)</span>之后，如果至少有<span class=\"token number\">1</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。\n\nsave <span class=\"token number\">300</span> <span class=\"token number\">10</span>          <span class=\"token operator\">#</span>在<span class=\"token number\">300</span>秒<span class=\"token punctuation\">(</span><span class=\"token number\">5</span>分钟<span class=\"token punctuation\">)</span>之后，如果至少有<span class=\"token number\">10</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。\n\nsave <span class=\"token number\">60</span> <span class=\"token number\">10000</span>        <span class=\"token operator\">#</span>在<span class=\"token number\">60</span>秒<span class=\"token punctuation\">(</span><span class=\"token number\">1</span>分钟<span class=\"token punctuation\">)</span>之后，如果至少有<span class=\"token number\">10000</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。\n</code></pre></div><h3>RDB 创建快照时会阻塞主线程吗？</h3>\n<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>\n<ul>\n<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li>\n<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>\n</ul>\n<blockquote>\n<p>这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis 主进程，也没毛病。</p>\n</blockquote>\n<h2>AOF 持久化</h2>\n<h3>什么是 AOF 持久化？</h3>\n<p>与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 <code>appendonly</code> 参数开启：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code>appendonly <span class=\"token function\">yes</span>\n</code></pre></div><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p>\n<p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。</p>\n<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 <code>dir</code> 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>\n<h3>AOF 工作基本流程是怎样的？</h3>\n<p>AOF 持久化功能的实现可以简单分为 5 步：</p>\n<ol>\n<li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li>\n<li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li>\n<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li>\n<li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>\n<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>\n</ol>\n<blockquote>\n<p>Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 <strong>系统调用（syscall）</strong>。</p>\n</blockquote>\n<p>这里对上面提到的一些 Linux 系统调用再做一遍解释：</p>\n<ul>\n<li><code>write</code>：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。</li>\n<li><code>fsync</code>：<code>fsync</code>用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</li>\n</ul>\n<p>AOF 工作流程图如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/aof-work-process.png\" alt=\"AOF 工作基本流程\" tabindex=\"0\"><figcaption>AOF 工作基本流程</figcaption></figure>\n<h3>AOF 持久化方式有哪些？</h3>\n<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>\n<ol>\n<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>\n<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>\n<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>\n</ol>\n<p>可以看出：<strong>这 3 种持久化方式的主要区别在于 <code>fsync</code> 同步 AOF 文件的时机（刷盘）</strong>。</p>\n<p>为了兼顾数据和写入性能，可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>\n<p>从 Redis 7.0.0 开始，Redis 使用了 <strong>Multi Part AOF</strong> 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：</p>\n<ul>\n<li>BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。</li>\n<li>INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。</li>\n<li>HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。</li>\n</ul>\n<p>Multi Part AOF 不是重点，了解即可，详细介绍可以看看阿里开发者的<a href=\"https://zhuanlan.zhihu.com/p/467217082\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 7.0 Multi Part AOF 的设计和实现</a> 这篇文章。</p>\n<p><strong>相关 issue</strong>：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/783\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 的 AOF 方式 #783</a>。</p>\n<h3>AOF 为什么是在执行完命令之后记录日志？</h3>\n<p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-aof-write-log-disc.png\" alt=\"AOF 记录日志过程\" tabindex=\"0\"><figcaption>AOF 记录日志过程</figcaption></figure>\n<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>\n<ul>\n<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>\n<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>\n</ul>\n<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>\n<ul>\n<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>\n<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>\n</ul>\n<h3>AOF 重写了解吗？</h3>\n<p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/aof-rewrite.png\" alt=\"AOF 重写\" tabindex=\"0\"><figcaption>AOF 重写</figcaption></figure>\n<blockquote>\n<p>AOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>\n</blockquote>\n<p>由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。</p>\n<p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>\n<p>开启 AOF 重写功能，可以调用 <code>BGREWRITEAOF</code> 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：</p>\n<ul>\n<li><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;</li>\n<li><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</li>\n</ul>\n<p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p>\n<p>Redis 7.0 版本之后，AOF 重写机制得到了优化改进。下面这段内容摘自阿里开发者的<a href=\"https://mp.weixin.qq.com/s/RnoPPL7jiFSKkx3G4p57Pg\" target=\"_blank\" rel=\"noopener noreferrer\">从 Redis7.0 发布看 Redis 的过去与未来</a> 这篇文章。</p>\n<blockquote>\n<p>AOF 重写期间的增量数据如何处理一直是个问题，在过去写期间的增量数据需要在内存中保留，写结束后再把这部分增量数据写入新的 AOF 文件中以保证数据完整性。可以看出来 AOF 写会额外消耗内存和磁盘 IO，这也是 Redis AOF 写的痛点，虽然之前也进行过多次改进但是资源消耗的本质问题一直没有解决。</p>\n<p>阿里云的 Redis 企业版在最初也遇到了这个问题，在内部经过多次迭代开发，实现了 Multi-part AOF 机制来解决，同时也贡献给了社区并随此次 7.0 发布。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。</p>\n</blockquote>\n<p><strong>相关 issue</strong>：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1439\" target=\"_blank\" rel=\"noopener noreferrer\">Redis AOF 重写描述不准确 #1439</a>。</p>\n<h3>AOF 校验机制了解吗？</h3>\n<p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>\n<p>类似地，RDB 文件也有类似的校验机制来保证 RDB 文件的正确性，这里就不重复进行介绍了。</p>\n<h2>Redis 4.0 对于持久化机制做了什么优化？</h2>\n<p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>\n<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>\n<p>官方文档地址：https://redis.io/topics/persistence</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-persitence.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>如何选择 RDB 和 AOF？</h2>\n<p>关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明<a href=\"https://redis.io/docs/manual/persistence/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis persistence</a>，这里结合自己的理解简单总结一下。</p>\n<p><strong>RDB 比 AOF 优秀的地方</strong>：</p>\n<ul>\n<li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>\n<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>\n</ul>\n<p><strong>AOF 比 RDB 优秀的地方</strong>：</p>\n<ul>\n<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>\n<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>\n<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>\n</ul>\n<p><strong>综上</strong>：</p>\n<ul>\n<li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li>\n<li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li>\n<li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li>\n</ul>\n<h2>参考</h2>\n<ul>\n<li>《Redis 设计与实现》</li>\n<li>Redis persistence - Redis 官方文档：https://redis.io/docs/management/persistence/</li>\n<li>The difference between AOF and RDB persistence：https://www.sobyte.net/post/2022-04/redis-rdb-and-aof/</li>\n<li>Redis AOF 持久化详解 - 程序员历小冰：http://remcarpediem.net/article/376c55d8/</li>\n<li>Redis RDB 与 AOF 持久化 · Analyze：https://wingsxdu.com/posts/database/redis/rdb-and-aof/</li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-persitence.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis常见面试题总结(上)",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-questions-01.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-questions-01.html",
      "summary": "Redis 基础 什么是 Redis？ Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。 为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、S...",
      "content_html": "<h2>Redis 基础</h2>\n<h3>什么是 Redis？</h3>\n<p><a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a> 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>\n<p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p>\n<p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</p>\n<p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的<a href=\"https://try.redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">在线 Redis 环境</a>（少部分命令无法使用）来实际体验 Redis。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/try.redis.io.png\" alt=\"try-redis\" tabindex=\"0\"><figcaption>try-redis</figcaption></figure>\n<p>全世界有非常多的网站使用到了 Redis ，<a href=\"https://techstacks.io/\" target=\"_blank\" rel=\"noopener noreferrer\">techstacks.io</a> 专门维护了一个<a href=\"https://techstacks.io/tech/redis\" target=\"_blank\" rel=\"noopener noreferrer\">使用 Redis 的热门站点列表</a> ，感兴趣的话可以看看。</p>\n<h3>Redis 为什么这么快？</h3>\n<p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：</p>\n<ol>\n<li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li>\n<li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li>\n<li>Redis 内置了多种优化过后的数据结构实现，性能非常高。</li>\n</ol>\n<p>下面这张图片总结的挺不错的，分享一下，出自 <a href=\"https://twitter.com/alexxubyte/status/1498703822528544770\" target=\"_blank\" rel=\"noopener noreferrer\">Why is Redis so fast?</a> 。</p>\n<figure><figcaption>why-redis-so-fast</figcaption></figure>\n<h3>分布式缓存常见的技术选型方案有哪些？</h3>\n<p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p>\n<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>\n<p>另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 <a href=\"https://github.com/facebook/rocksdb\" target=\"_blank\" rel=\"noopener noreferrer\">RocksDB</a> 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 <a href=\"https://github.com/Tencent/Tendis\" target=\"_blank\" rel=\"noopener noreferrer\">Tendis</a>。</p>\n<p>关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：<a href=\"https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ\" target=\"_blank\" rel=\"noopener noreferrer\">Redis vs Tendis：冷热混合存储版架构揭秘</a> ，可以简单参考一下。</p>\n<p>从这个项目的 GitHub 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。</p>\n<h3>说一下 Redis 和 Memcached 的区别和共同点</h3>\n<p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p>\n<p><strong>共同点</strong>：</p>\n<ol>\n<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>\n<li>都有过期策略。</li>\n<li>两者的性能都非常高。</li>\n</ol>\n<p><strong>区别</strong>：</p>\n<ol>\n<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>\n<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li>\n<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>\n<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>\n<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>\n<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 针对网络数据的读写引入了多线程）</li>\n<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>\n<li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>\n</ol>\n<p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p>\n<h3>为什么要用 Redis/为什么要用缓存？</h3>\n<p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p>\n<p><strong>1、高性能</strong></p>\n<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>\n<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>\n<p><strong>2、高并发</strong></p>\n<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p>\n<blockquote>\n<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>\n</blockquote>\n<p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>\n<h3>常见的缓存读写策略有哪些？</h3>\n<p>关于常见的缓存读写策略的详细介绍，可以看我写的这篇文章：<a href=\"https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html\" target=\"_blank\" rel=\"noopener noreferrer\">3 种常用的缓存读写策略详解</a> 。</p>\n<h2>Redis 应用</h2>\n<h3>Redis 除了做缓存，还能做什么？</h3>\n<ul>\n<li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href=\"https://javaguide.cn/distributed-system/distributed-lock.html\" target=\"_blank\" rel=\"noopener noreferrer\">分布式锁详解</a> 。</li>\n<li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href=\"https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA\" target=\"_blank\" rel=\"noopener noreferrer\">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》</a>。</li>\n<li><strong>消息队列</strong>：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>\n<li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 sorted set 实现的）。</li>\n<li><strong>分布式 Session</strong> ：利用 string 或者 hash 保存 Session 数据，所有的服务器都可以访问。</li>\n<li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>\n<li>......</li>\n</ul>\n<h3>如何基于 Redis 实现分布式锁？</h3>\n<p>关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href=\"https://javaguide.cn/distributed-system/distributed-lock.html\" target=\"_blank\" rel=\"noopener noreferrer\">分布式锁详解</a> 。</p>\n<h3>Redis 可以做消息队列么？</h3>\n<blockquote>\n<p>实际项目中也没见谁使用 Redis 来做消息队列，对于这部分知识点大家了解就好了。</p>\n</blockquote>\n<p>先说结论：可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</p>\n<p><strong>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。</strong></p>\n<p>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>即可实现简易版消息队列：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token comment\"># 生产者生产消息</span>\n<span class=\"token operator\">&gt;</span> RPUSH myList msg1 msg2\n<span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span>\n<span class=\"token operator\">&gt;</span> RPUSH myList msg3\n<span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">3</span>\n<span class=\"token comment\"># 消费者消费消息</span>\n<span class=\"token operator\">&gt;</span> LPOP myList\n<span class=\"token string\">\"msg1\"</span>\n</code></pre></div><p>不过，通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>这样的方式存在性能问题，我们需要不断轮询去调用 <code>RPOP</code> 或 <code>LPOP</code> 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p>\n<p>因此，Redis 还提供了 <code>BLPOP</code>、<code>BRPOP</code> 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token comment\"># 超时时间为 10s</span>\n<span class=\"token comment\"># 如果有数据立刻返回，否则最多等待10秒</span>\n<span class=\"token operator\">&gt;</span> BRPOP myList <span class=\"token number\">10</span>\nnull\n</code></pre></div><p><strong>List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。</strong></p>\n<p><strong>Redis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-pub-sub.png\" alt=\"Redis 发布订阅 (pub/sub) 功能\" tabindex=\"0\"><figcaption>Redis 发布订阅 (pub/sub) 功能</figcaption></figure>\n<p>pub/sub 中引入了一个概念叫 <strong>channel（频道）</strong>，发布订阅机制的实现就是基于这个 channel 来做的。</p>\n<p>pub/sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：</p>\n<ul>\n<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li>\n<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li>\n</ul>\n<p>我们这里启动 3 个 Redis 客户端来简单演示一下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-pubsub-message-queue.png\" alt=\"pub/sub 实现消息队列演示\" tabindex=\"0\"><figcaption>pub/sub 实现消息队列演示</figcaption></figure>\n<p>pub/sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。</p>\n<p>为此，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。<code>Stream</code> 支持：</p>\n<ul>\n<li>发布 / 订阅模式</li>\n<li>按照消费者组进行消费</li>\n<li>消息持久化（ RDB 和 AOF）</li>\n</ul>\n<p><code>Stream</code> 使用起来相对要麻烦一些，这里就不演示了。而且，<code>Stream</code> 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p>\n<p>综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p>\n<p>相关阅读：<a href=\"https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 消息队列发展历程 - 阿里开发者 - 2022</a>。</p>\n<h2>Redis 数据结构</h2>\n<blockquote>\n<p>关于 Redis 5 种基础数据结构和 3 种特殊数据结构的详细介绍请看下面这两篇文章：</p>\n<ul>\n<li><a href=\"https://javaguide.cn/database/redis/redis-data-structures-01.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 5 种基本数据结构详解</a></li>\n<li><a href=\"https://javaguide.cn/database/redis/redis-data-structures-02.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 3 种特殊数据结构详解</a></li>\n</ul>\n</blockquote>\n<h3>Redis 常用的数据结构有哪些？</h3>\n<ul>\n<li><strong>5 种基础数据结构</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>\n<li><strong>3 种特殊数据结构</strong>：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>\n</ul>\n<h3>String 的应用场景有哪些？</h3>\n<p>String 是 Redis 中最简单同时也是最常用的一个数据结构。String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>\n<p>String 的常见应用场景如下：</p>\n<ul>\n<li>常规数据（比如 session、token、序列化后的对象、图片的路径）的缓存；</li>\n<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>\n<li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li>\n<li>......</li>\n</ul>\n<p>关于 String 的详细介绍请看这篇文章：<a href=\"https://javaguide.cn/database/redis/redis-data-structures-01.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 5 种基本数据结构详解</a>。</p>\n<h3>String 还是 Hash 存储对象数据更好呢？</h3>\n<ul>\n<li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>\n<li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>\n</ul>\n<p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p>\n<h3>String 的底层实现是什么？</h3>\n<p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\\0</code> 结尾的字符数组），而是自己编写了 <a href=\"https://github.com/antirez/sds\" target=\"_blank\" rel=\"noopener noreferrer\">SDS</a>（Simple Dynamic String，简单动态字符串） 来作为底层实现。</p>\n<p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p>\n<p>Redis7.0 的 SDS 的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）：</p>\n<div class=\"language-c\" data-ext=\"c\" data-title=\"c\"><pre class=\"language-c\"><code><span class=\"token comment\">/* Note: sdshdr5 is never used, we just access the flags byte directly.\n * However is here to document the layout of type 5 SDS strings. */</span>\n<span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__packed__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">sdshdr5</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> flags<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 3 lsb of type, and 5 msb of string length */</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__packed__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">sdshdr8</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">uint8_t</span> len<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* used */</span>\n    <span class=\"token class-name\">uint8_t</span> alloc<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* excluding the header and null terminator */</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> flags<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 3 lsb of type, 5 unused bits */</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__packed__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">sdshdr16</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">uint16_t</span> len<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* used */</span>\n    <span class=\"token class-name\">uint16_t</span> alloc<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* excluding the header and null terminator */</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> flags<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 3 lsb of type, 5 unused bits */</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__packed__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">sdshdr32</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">uint32_t</span> len<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* used */</span>\n    <span class=\"token class-name\">uint32_t</span> alloc<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* excluding the header and null terminator */</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> flags<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 3 lsb of type, 5 unused bits */</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__packed__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">sdshdr64</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">uint64_t</span> len<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* used */</span>\n    <span class=\"token class-name\">uint64_t</span> alloc<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* excluding the header and null terminator */</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> flags<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 3 lsb of type, 5 unused bits */</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p>\n<p>| 类型     | 字节 | 位  |\n|</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/try.redis.io.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis常见面试题总结(下)",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-questions-02.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/redis/redis-questions-02.html",
      "summary": "Redis 事务 什么是 Redis 事务？ 你可以将 Redis 中的事务理解为：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。 Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。 除了不满足原子性和持久性之外，事务中的每条命令都会与 R...",
      "content_html": "<h2>Redis 事务</h2>\n<h3>什么是 Redis 事务？</h3>\n<p>你可以将 Redis 中的事务理解为：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>\n<p>Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。</p>\n<p>除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p>\n<p>因此，Redis 事务是不建议在日常开发中使用的。</p>\n<h3>如何使用 Redis 事务？</h3>\n<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(Transaction)功能。</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token operator\">&gt;</span> MULTI\nOK\n<span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"JavaGuide\"</span>\nQUEUED\n<span class=\"token operator\">&gt;</span> GET PROJECT\nQUEUED\n<span class=\"token operator\">&gt;</span> EXEC\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> OK\n<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"JavaGuide\"</span>\n</code></pre></div><p><a href=\"https://redis.io/commands/multi\" target=\"_blank\" rel=\"noopener noreferrer\"><code>MULTI</code></a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href=\"https://redis.io/commands/exec\" target=\"_blank\" rel=\"noopener noreferrer\"><code>EXEC</code></a> 命令后，再执行所有的命令。</p>\n<p>这个过程是这样的：</p>\n<ol>\n<li>开始事务（<code>MULTI</code>）；</li>\n<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li>\n<li>执行事务(<code>EXEC</code>)。</li>\n</ol>\n<p>你也可以通过 <a href=\"https://redis.io/commands/discard\" target=\"_blank\" rel=\"noopener noreferrer\"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token operator\">&gt;</span> MULTI\nOK\n<span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"JavaGuide\"</span>\nQUEUED\n<span class=\"token operator\">&gt;</span> GET PROJECT\nQUEUED\n<span class=\"token operator\">&gt;</span> DISCARD\nOK\n</code></pre></div><p>你可以通过<a href=\"https://redis.io/commands/watch\" target=\"_blank\" rel=\"noopener noreferrer\"><code>WATCH</code></a> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端/Session</strong> 修改的话，整个事务都不会被执行。</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token comment\"># 客户端 1</span>\n<span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"RustGuide\"</span>\nOK\n<span class=\"token operator\">&gt;</span> WATCH PROJECT\nOK\n<span class=\"token operator\">&gt;</span> MULTI\nOK\n<span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"JavaGuide\"</span>\nQUEUED\n\n<span class=\"token comment\"># 客户端 2</span>\n<span class=\"token comment\"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span>\n<span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"GoGuide\"</span>\n\n<span class=\"token comment\"># 客户端 1</span>\n<span class=\"token comment\"># 修改失败，因为 PROJECT 的值被客户端2修改了</span>\n<span class=\"token operator\">&gt;</span> EXEC\n<span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span>\n<span class=\"token operator\">&gt;</span> GET PROJECT\n<span class=\"token string\">\"GoGuide\"</span>\n</code></pre></div><p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1714\" target=\"_blank\" rel=\"noopener noreferrer\">WATCH 命令碰到 MULTI 命令时的不同效果</a>）。</p>\n<p>事务内部修改 WATCH 监视的 Key：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"JavaGuide\"</span>\nOK\n<span class=\"token operator\">&gt;</span> WATCH PROJECT\nOK\n<span class=\"token operator\">&gt;</span> MULTI\nOK\n<span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"JavaGuide1\"</span>\nQUEUED\n<span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"JavaGuide2\"</span>\nQUEUED\n<span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"JavaGuide3\"</span>\nQUEUED\n<span class=\"token operator\">&gt;</span> EXEC\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> OK\n<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> OK\n<span class=\"token number\">3</span><span class=\"token punctuation\">)</span> OK\n<span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>&gt;</span> GET PROJECT\n<span class=\"token string\">\"JavaGuide3\"</span>\n</code></pre></div><p>事务外部修改 WATCH 监视的 Key：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"JavaGuide\"</span>\nOK\n<span class=\"token operator\">&gt;</span> WATCH PROJECT\nOK\n<span class=\"token operator\">&gt;</span> SET PROJECT <span class=\"token string\">\"JavaGuide2\"</span>\nOK\n<span class=\"token operator\">&gt;</span> MULTI\nOK\n<span class=\"token operator\">&gt;</span> GET <span class=\"token environment constant\">USER</span>\nQUEUED\n<span class=\"token operator\">&gt;</span> EXEC\n<span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span>\n</code></pre></div><p>Redis 官网相关介绍 <a href=\"https://redis.io/topics/transactions\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/topics/transactions</a> 如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-transactions.png\" alt=\"Redis 事务\" tabindex=\"0\"><figcaption>Redis 事务</figcaption></figure>\n<h3>Redis 事务支持原子性吗？</h3>\n<p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：<strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>\n<ol>\n<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>\n</ol>\n<p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。</p>\n<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-rollback.png\" alt=\"Redis 为什么不支持回滚\" tabindex=\"0\"><figcaption>Redis 为什么不支持回滚</figcaption></figure>\n<p><strong>相关 issue</strong> :</p>\n<ul>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/issues/452\" target=\"_blank\" rel=\"noopener noreferrer\">issue#452: 关于 Redis 事务不满足原子性的问题</a> 。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/issues/491\" target=\"_blank\" rel=\"noopener noreferrer\">Issue#491:关于 Redis 没有事务回滚？</a></li>\n</ul>\n<h3>Redis 事务支持持久性吗？</h3>\n<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>\n<ul>\n<li>快照（snapshotting，RDB）</li>\n<li>只追加文件（append-only file, AOF）</li>\n<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>\n</ul>\n<p>与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code>appendfsync always    <span class=\"token comment\">#每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度</span>\nappendfsync everysec  <span class=\"token comment\">#每秒钟调用fsync函数同步一次AOF文件</span>\nappendfsync no        <span class=\"token comment\">#让操作系统决定何时进行同步，一般为30秒一次</span>\n</code></pre></div><p>AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p>\n<p>因此，Redis 事务的持久性也是没办法保证的。</p>\n<h3>如何解决 Redis 事务的缺陷？</h3>\n<p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p>\n<p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p>\n<p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p>\n<p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p>\n<p>另外，Redis 7.0 新增了 <a href=\"https://redis.io/docs/manual/programmability/functions-intro/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis functions</a> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p>\n<h2>Redis 性能优化（重要）</h2>\n<p>除了下面介绍的内容之外，再推荐两篇不错的文章：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ\" target=\"_blank\" rel=\"noopener noreferrer\">你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者</a></li>\n<li><a href=\"https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 常见阻塞原因总结 - JavaGuide</a></li>\n</ul>\n<h3>使用批量操作减少网络传输</h3>\n<p>一个 Redis 命令的执行可以简化为以下 4 步：</p>\n<ol>\n<li>发送命令</li>\n<li>命令排队</li>\n<li>命令执行</li>\n<li>返回结果</li>\n</ol>\n<p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p>\n<p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p>\n<p>另外，除了能减少 RTT 之外，发送一次命令的 socket I/O 成本也比较高（涉及上下文切换，存在<code>read()</code>和<code>write()</code>系统调用），批量操作还可以减少 socket I/O 成本。这个在官方对 pipeline 的介绍中有提到：https://redis.io/docs/manual/pipelining/ 。</p>\n<h4>原生批量操作命令</h4>\n<p>Redis 中有一些原生支持批量操作的命令，比如：</p>\n<ul>\n<li><code>MGET</code>(获取一个或多个指定 key 的值)、<code>MSET</code>(设置一个或多个指定 key 的值)、</li>\n<li><code>HMGET</code>(获取指定哈希表中一个或者多个指定字段的值)、<code>HMSET</code>(同时将一个或多个 field-value 对设置到指定哈希表中)、</li>\n<li><code>SADD</code>（向指定集合添加一个或多个元素）</li>\n<li>......</li>\n</ul>\n<p>不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 <code>MGET</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>MGET</code>可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p>\n<p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p>\n<ol>\n<li>找到 key 对应的所有 hash slot；</li>\n<li>分别向对应的 Redis 节点发起 <code>MGET</code> 请求获取数据；</li>\n<li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li>\n</ol>\n<p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p>\n<blockquote>\n<p>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p>\n<p>我在 <a href=\"https://javaguide.cn/database/redis/redis-cluster.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 集群详解（付费）</a> 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。</p>\n</blockquote>\n<h4>pipeline</h4>\n<p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p>\n<p>与<code>MGET</code>、<code>MSET</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p>\n<p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p>\n<ul>\n<li>原生批量操作命令是原子操作，pipeline 是非原子操作。</li>\n<li>pipeline 可以打包不同的命令，原生批量操作命令不可以。</li>\n<li>原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li>\n</ul>\n<p>顺带补充一下 pipeline 和 Redis 事务的对比：</p>\n<ul>\n<li>事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。</li>\n<li>Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。</li>\n</ul>\n<blockquote>\n<p>事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-pipeline-vs-transaction.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p>\n<h4>Lua 脚本</h4>\n<p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 <strong>原子操作</strong> 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p>\n<p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p>\n<p>不过， Lua 脚本依然存在下面这些缺陷：</p>\n<ul>\n<li>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li>\n<li>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</li>\n</ul>\n<h3>大量 key 集中过期问题</h3>\n<p>我在前面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p>\n<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>\n<p><strong>如何解决呢？</strong> 下面是两种常见的方法：</p>\n<ol>\n<li>给 key 设置随机过期时间。</li>\n<li>开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>\n</ol>\n<p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p>\n<h3>Redis bigkey（大 Key）</h3>\n<h4>什么是 bigkey？</h4>\n<p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>\n<h4>bigkey 有什么危害？</h4>\n<p>bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。因此，我们应该尽量避免 Redis 中存在 bigkey。</p>\n<h4>如何发现 bigkey？</h4>\n<p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token comment\"># redis-cli -p 6379 --bigkeys</span>\n\n<span class=\"token comment\"># Scanning the entire keyspace to find biggest keys as well as</span>\n<span class=\"token comment\"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span>\n<span class=\"token comment\"># per 100 SCAN commands (not usually needed).</span>\n\n<span class=\"token punctuation\">[</span>00.00%<span class=\"token punctuation\">]</span> Biggest string found so far <span class=\"token string\">'\"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20\"'</span> with <span class=\"token number\">4437</span> bytes\n<span class=\"token punctuation\">[</span>00.00%<span class=\"token punctuation\">]</span> Biggest list   found so far <span class=\"token string\">'\"my-list\"'</span> with <span class=\"token number\">17</span> items\n\n</code></pre></div>",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/redis-transactions.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "SQL常见面试题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/sql/sql-questions-01.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/sql/sql-questions-01.html",
      "summary": "题目来源于：牛客题霸 - SQL 必知必会 检索数据 SELECT 用于从数据库中查询数据。 从 Customers 表中检索所有的 ID 现有表 Customers 如下： 编写 SQL 语句，从 Customers 表中检索所有的 cust_id。 答案： 检索并列出已订购产品的清单 表 OrderItems 含有非空的列 prod_id 代表商品...",
      "content_html": "<blockquote>\n<p>题目来源于：<a href=\"https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=298\" target=\"_blank\" rel=\"noopener noreferrer\">牛客题霸 - SQL 必知必会</a></p>\n</blockquote>\n<h2>检索数据</h2>\n<p><code>SELECT</code> 用于从数据库中查询数据。</p>\n<h3>从 Customers 表中检索所有的 ID</h3>\n<p>现有表 <code>Customers</code> 如下：</p>\n<p>| cust_id |\n|</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/csdn/d1794312b448516831369f869814ab39.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "SQL语法基础知识总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/database/sql/sql-syntax-summary.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/database/sql/sql-syntax-summary.html",
      "summary": "本文整理完善自下面这两份资料： SQL 语法速成手册 MySQL 超全教程 基本概念 数据库术语 数据库（database） - 保存有组织的数据的容器（通常是一个文件或一组文件）。 数据表（table） - 某种特定类型数据的结构化清单。 模式（schema） - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，...",
      "content_html": "<blockquote>\n<p>本文整理完善自下面这两份资料：</p>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903790571700231\" target=\"_blank\" rel=\"noopener noreferrer\">SQL 语法速成手册</a></li>\n<li><a href=\"https://www.begtut.com/mysql/mysql-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 超全教程</a></li>\n</ul>\n</blockquote>\n<h2>基本概念</h2>\n<h3>数据库术语</h3>\n<ul>\n<li><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li>\n<li><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</li>\n<li><code>模式（schema）</code> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>\n<li><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</li>\n<li><code>行（row）</code> - 表中的一个记录。</li>\n<li><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</li>\n</ul>\n<h3>SQL 语法</h3>\n<p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>\n<h4>SQL 语法结构</h4>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb684d4c75fc430e92aaee226069c7da~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>SQL 语法结构包括：</p>\n<ul>\n<li><strong><code>子句</code></strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li>\n<li><strong><code>表达式</code></strong> - 可以产生任何标量值，或由列和行的数据库表</li>\n<li><strong><code>谓词</code></strong> - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li>\n<li><strong><code>查询</code></strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li>\n<li><strong><code>语句</code></strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li>\n</ul>\n<h4>SQL 语法要点</h4>\n<ul>\n<li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如：<code>SELECT</code> 与 <code>select</code>、<code>Select</code> 是相同的。</li>\n<li><strong>多条 SQL 语句必须以分号（<code>;</code>）分隔</strong>。</li>\n<li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li>\n</ul>\n<p>SQL 语句可以写成一行，也可以分写为多行。</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token comment\">-- 一行 SQL 语句</span>\n\n<span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">SET</span> username<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span> <span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 多行 SQL 语句</span>\n<span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span>\n<span class=\"token keyword\">SET</span> username<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span>\n<span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>SQL 支持三种注释：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token comment\">## 注释1</span>\n<span class=\"token comment\">-- 注释2</span>\n<span class=\"token comment\">/* 注释3 */</span>\n</code></pre></div><h3>SQL 分类</h3>\n<h4>数据定义语言（DDL）</h4>\n<p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p>\n<p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p>\n<p>DDL 的核心指令是 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>。</p>\n<h4>数据操纵语言（DML）</h4>\n<p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p>\n<p>DML 的主要功能是 <strong>访问数据</strong>，因此其语法都是以<strong>读写数据库</strong>为主。</p>\n<p>DML 的核心指令是 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</p>\n<h4>事务控制语言（TCL）</h4>\n<p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p>\n<p>TCL 的核心指令是 <code>COMMIT</code>、<code>ROLLBACK</code>。</p>\n<h4>数据控制语言（DCL）</h4>\n<p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p>\n<p>DCL 的核心指令是 <code>GRANT</code>、<code>REVOKE</code>。</p>\n<p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：<code>CONNECT</code>、<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>EXECUTE</code>、<code>USAGE</code>、<code>REFERENCES</code>。</p>\n<p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p>\n<p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p>\n<h2>增删改查</h2>\n<p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>\n<h3>插入数据</h3>\n<p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p>\n<p><strong>插入完整的行</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token comment\"># 插入一行</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span>\n<span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\"># 插入多行</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span>\n<span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">18</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'user2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>插入行的一部分</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">,</span> email<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'admin'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'admin'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'xxxx@163.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>插入查询出来的数据</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">SELECT</span> name\n<span class=\"token keyword\">FROM</span> account<span class=\"token punctuation\">;</span>\n</code></pre></div><h3>更新数据</h3>\n<p><code>UPDATE</code> 语句用于更新表中的记录。</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span>\n<span class=\"token keyword\">SET</span> username<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">'robot'</span>\n<span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">;</span>\n</code></pre></div><h3>删除数据</h3>\n<ul>\n<li><code>DELETE</code> 语句用于删除表中的记录。</li>\n<li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li>\n</ul>\n<p><strong>删除表中的指定数据</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span>\n<span class=\"token keyword\">WHERE</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'robot'</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>清空表中的数据</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">TRUNCATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span>\n</code></pre></div><h3>查询数据</h3>\n<p><code>SELECT</code> 语句用于从数据库中查询数据。</p>\n<p><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</p>\n<p><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>\n<ul>\n<li><code>ASC</code>：升序（默认）</li>\n<li><code>DESC</code>：降序</li>\n</ul>\n<p><strong>查询单列</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> prod_name\n<span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>查询多列</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span> prod_name<span class=\"token punctuation\">,</span> prod_price\n<span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>查询所有列</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>查询不同的值</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span>\nvend_id <span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>限制查询结果</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token comment\">-- 返回前 5 行</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mytable <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mytable <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 返回第 3 ~ 5 行</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> mytable <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n</code></pre></div><h2>排序</h2>\n<p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p>\n<p><code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> products\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> prod_price <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">,</span> prod_name <span class=\"token keyword\">ASC</span><span class=\"token punctuation\">;</span>\n</code></pre></div><h2>分组</h2>\n<p><strong><code>group by</code></strong>：</p>\n<ul>\n<li><code>group by</code> 子句将记录分组到汇总行中。</li>\n<li><code>group by</code> 为每个组返回一个记录。</li>\n<li><code>group by</code> 通常还涉及聚合<code>count</code>，<code>max</code>，<code>sum</code>，<code>avg</code> 等。</li>\n<li><code>group by</code> 可以按一列或多列进行分组。</li>\n<li><code>group by</code> 按分组字段进行排序后，<code>order by</code> 可以以汇总字段来进行排序。</li>\n</ul>\n<p><strong>分组</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>cust_address<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> addr_num\n<span class=\"token keyword\">FROM</span> Customers <span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> cust_name<span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>分组后排序</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>cust_address<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> addr_num\n<span class=\"token keyword\">FROM</span> Customers <span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> cust_name\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> cust_name <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong><code>having</code></strong>：</p>\n<ul>\n<li><code>having</code> 用于对汇总的 <code>group by</code> 结果进行过滤。</li>\n<li><code>having</code> 一般都是和 <code>group by</code> 连用。</li>\n<li><code>where</code> 和 <code>having</code> 可以在相同的查询中。</li>\n</ul>\n<p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> num\n<span class=\"token keyword\">FROM</span> Customers\n<span class=\"token keyword\">WHERE</span> cust_email <span class=\"token operator\">IS</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> cust_name\n<span class=\"token keyword\">HAVING</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&gt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong><code>having</code> vs <code>where</code></strong>：</p>\n<ul>\n<li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。<code>where</code> 在<code>group by</code> 前。</li>\n<li><code>having</code>：过滤分组，一般都是和 <code>group by</code> 连用，不能单独使用。<code>having</code> 在 <code>group by</code> 之后。</li>\n</ul>\n<h2>子查询</h2>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p>\n<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>\n<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>\n<ul>\n<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。</li>\n<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</li>\n</ul>\n<blockquote>\n<p>注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p>\n</blockquote>\n<p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">from</span>   table1 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> table2 <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">where</span>  column_name operator\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">from</span> table1 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> table2 <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">where</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre></div><ul>\n<li>子查询需要放在括号<code>( )</code>内。</li>\n<li><code>operator</code> 表示用于 where 子句的运算符。</li>\n</ul>\n<p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">from</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> column_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> column_name <span class=\"token punctuation\">]</span>\n      <span class=\"token keyword\">from</span> table1 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> table2 <span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">[</span><span class=\"token keyword\">where</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> temp_table_name\n<span class=\"token keyword\">where</span>  condition\n</code></pre></div><p>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</p>\n<p><strong>子查询的子查询</strong></p>\n<div class=\"language-sql\" data-ext=\"sql\" data-title=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> cust_name<span class=\"token punctuation\">,</span> cust_contact\n<span class=\"token keyword\">FROM</span> customers\n<span class=\"token keyword\">WHERE</span> cust_id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> cust_id\n                  <span class=\"token keyword\">FROM</span> orders\n                  <span class=\"token keyword\">WHERE</span> order_num <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> order_num\n                                      <span class=\"token keyword\">FROM</span> orderitems\n                                      <span class=\"token keyword\">WHERE</span> prod_id <span class=\"token operator\">=</span> <span class=\"token string\">'RGAN01'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c439da1f5d4e4b00bdfa4316b933d764~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>WHERE</h3>\n<ul>\n<li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li>\n<li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li>\n<li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。</li>\n<li>可以在 <code>WHERE</code> 子句中使用的操作符。</li>\n</ul>\n<p>| 运算符  | 描述                                                   |\n|</p>\n",
      "image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb684d4c75fc430e92aaee226069c7da~tplv-k3u1fbpfcp-zoom-1.image",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "CAP & BASE理论详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/protocol/cap-and-base-theorem.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/protocol/cap-and-base-theorem.html",
      "summary": "经历过技术面试的小伙伴想必对 CAP & BASE 这个两个理论已经再熟悉不过了！ 我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。一是因为这两个分布式基础理论是学习分布式知识的必备前置基础，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。 我们非常有必要将这两个理论搞懂，并且能够用自己的理...",
      "content_html": "<p>经历过技术面试的小伙伴想必对 CAP &amp; BASE 这个两个理论已经再熟悉不过了！</p>\n<p>我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。一是因为这两个分布式基础理论是学习分布式知识的必备前置基础，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。</p>\n<p>我们非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。</p>\n<h2>CAP 理论</h2>\n<p><a href=\"https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86\" target=\"_blank\" rel=\"noopener noreferrer\">CAP 理论/定理</a>起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 <strong>布鲁尔定理（Brewer’s theorem）</strong></p>\n<p>2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 发表了布鲁尔猜想的证明，CAP 理论正式成为分布式领域的定理。</p>\n<h3>简介</h3>\n<p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong> 这三个单词首字母组合。</p>\n<figure><img src=\"https://oss.javaguide.cn/2020-11/cap.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 <strong>Consistency</strong>、<strong>Availability</strong>、<strong>Partition Tolerance</strong> 三个单词的明确定义。</p>\n<p>因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。</p>\n<p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p>\n<ul>\n<li><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</li>\n<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>\n<li><strong>分区容错性（Partition Tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>\n</ul>\n<p><strong>什么是网络分区？</strong></p>\n<p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 <strong>网络分区</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/2020-11/partition-tolerance.png\" alt=\"partition-tolerance\" tabindex=\"0\"><figcaption>partition-tolerance</figcaption></figure>\n<h3>不是所谓的“3 选 2”</h3>\n<p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。</p>\n<blockquote>\n<p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p>\n<p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p>\n</blockquote>\n<p>因此，<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>\n<p><strong>为啥不可能选择 CA 架构呢？</strong> 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p>\n<p><strong>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p>\n<p>另外，需要补充说明的一点是：<strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p>\n<h3>CAP 实际应用案例</h3>\n<p>我这里以注册中心来探讨一下 CAP 的实际应用。考虑到很多小伙伴不知道注册中心是干嘛的，这里简单以 Dubbo 为例说一说。</p>\n<p>下图是 Dubbo 的架构图。<strong>注册中心 Registry 在其中扮演了什么角色呢？提供了什么服务呢？</strong></p>\n<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</p>\n<figure><img src=\"https://oss.javaguide.cn/2020-11/dubbo-architecture.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos...。</p>\n<ol>\n<li><strong>ZooKeeper 保证的是 CP。</strong> 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li>\n<li><strong>Eureka 保证的则是 AP。</strong> Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</li>\n<li><strong>Nacos 不仅支持 CP 也支持 AP。</strong></li>\n</ol>\n<p><strong>🐛 修正（参见：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1906\" target=\"_blank\" rel=\"noopener noreferrer\">issue#1906</a>）</strong>：</p>\n<p>ZooKeeper 通过可线性化（Linearizable）写入、全局 FIFO 顺序访问等机制来保障数据一致性。多节点部署的情况下， ZooKeeper 集群处于 Quorum 模式。Quorum 模式下的 ZooKeeper 集群， 是一组 ZooKeeper 服务器节点组成的集合，其中大多数节点必须同意任何变更才能被视为有效。</p>\n<p>由于 Quorum 模式下的读请求不会触发各个 ZooKeeper 节点之间的数据同步，因此在某些情况下还是可能会存在读取到旧数据的情况，导致不同的客户端视图上看到的结果不同，这可能是由于网络延迟、丢包、重传等原因造成的。ZooKeeper 为了解决这个问题，提供了 Watcher 机制和版本号机制来帮助客户端检测数据的变化和版本号的变更，以保证数据的一致性。</p>\n<h3>总结</h3>\n<p>在进行分布式系统设计和开发时，我们不应该仅仅局限在 CAP 问题上，还要关注系统的扩展性、可用性等等</p>\n<p>在系统发生“分区”的情况下，CAP 理论只能满足 CP 或者 AP。要注意的是，这里的前提是系统发生了“分区”</p>\n<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。</p>\n<p>总结：<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>\n<h3>推荐阅读</h3>\n<ol>\n<li><a href=\"https://medium.com/@ravindraprasad/cap-theorem-simplified-28499a67eab4\" target=\"_blank\" rel=\"noopener noreferrer\">CAP 定理简化</a> （英文，有趣的案例）</li>\n<li><a href=\"https://juejin.im/post/6844903936718012430\" target=\"_blank\" rel=\"noopener noreferrer\">神一样的 CAP 理论被应用在何方</a> （中文，列举了很多实际的例子）</li>\n<li><a href=\"https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html\" target=\"_blank\" rel=\"noopener noreferrer\">请停止呼叫数据库 CP 或 AP </a> （英文，带给你不一样的思考）</li>\n</ol>\n<h2>BASE 理论</h2>\n<p><a href=\"https://dl.acm.org/doi/10.1145/1394127.1394128\" target=\"_blank\" rel=\"noopener noreferrer\">BASE 理论</a>起源于 2008 年， 由 eBay 的架构师 Dan Pritchett 在 ACM 上发表。</p>\n<h3>简介</h3>\n<p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong>、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>\n<h3>BASE 理论的核心思想</h3>\n<p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>\n<blockquote>\n<p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>\n</blockquote>\n<p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong></p>\n<p><strong>为什么这样说呢？</strong></p>\n<p>CAP 理论这节我们也说过了：</p>\n<blockquote>\n<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>\n</blockquote>\n<p>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p>\n<h3>BASE 理论三要素</h3>\n<figure><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzI0LzE2MzkxNDgwNmQ5ZTE1YzY?x-oss-process=image/format,png\" alt=\"BASE理论三要素\" tabindex=\"0\"><figcaption>BASE理论三要素</figcaption></figure>\n<h4>基本可用</h4>\n<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>\n<p><strong>什么叫允许损失部分可用性呢？</strong></p>\n<ul>\n<li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>\n<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>\n</ul>\n<h4>软状态</h4>\n<p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>\n<h4>最终一致性</h4>\n<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>\n<blockquote>\n<p>分布式一致性的 3 种级别：</p>\n<ol>\n<li>\n<p><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</p>\n</li>\n<li>\n<p><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</p>\n</li>\n<li>\n<p><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</p>\n</li>\n</ol>\n<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>\n</blockquote>\n<p>那实现最终一致性的具体方式是什么呢? <a href=\"http://gk.link/a/10rZM\" target=\"_blank\" rel=\"noopener noreferrer\">《分布式协议与算法实战》</a> 中是这样介绍：</p>\n<blockquote>\n<ul>\n<li><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。</li>\n<li><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>\n<li><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>\n</ul>\n</blockquote>\n<p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p>\n<h3>总结</h3>\n<p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>\n",
      "image": "https://oss.javaguide.cn/2020-11/cap.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Gossip 协议详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/protocol/gossip-protocl.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/protocol/gossip-protocl.html",
      "summary": "背景 在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。 一种比较简单粗暴的方法就是 集中式发散消息，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。 于是，分散式发散消息 的 Gossip 协议 就诞生了。 Gossi...",
      "content_html": "<h2>背景</h2>\n<p>在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。</p>\n<p>一种比较简单粗暴的方法就是 <strong>集中式发散消息</strong>，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。</p>\n<p>于是，<strong>分散式发散消息</strong> 的 <strong>Gossip 协议</strong> 就诞生了。</p>\n<h2>Gossip 协议介绍</h2>\n<p>Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。</p>\n<figure><figcaption></figcaption></figure>\n<p><strong>Gossip 协议</strong> 也叫 Epidemic 协议（流行病协议）或者 Epidemic propagation 算法（疫情传播算法），别名很多。不过，这些名字的特点都具有 <strong>随机传播特性</strong> （联想一下病毒传播、癌细胞扩散等生活中常见的情景），这也正是 Gossip 协议最主要的特点。</p>\n<p>Gossip 协议最早是在 ACM 上的一篇 1987 年发表的论文 <a href=\"https://dl.acm.org/doi/10.1145/41840.41841\" target=\"_blank\" rel=\"noopener noreferrer\">《Epidemic Algorithms for Replicated Database Maintenance》</a>中被提出的。根据论文标题，我们大概就能知道 Gossip 协议当时提出的主要应用是在分布式数据库系统中各个副本节点同步数据。</p>\n<p>正如 Gossip 协议其名一样，这是一种随机且带有传染性的方式将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。</p>\n<p>在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。</p>\n<p>下面我们来对 Gossip 协议的定义做一个总结：<strong>Gossip 协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</strong></p>\n<h2>Gossip 协议应用</h2>\n<p>NoSQL 数据库 Redis 和 Apache Cassandra、服务网格解决方案 Consul 等知名项目都用到了 Gossip 协议，学习 Gossip 协议有助于我们搞清很多技术的底层原理。</p>\n<p>我们这里以 Redis Cluster 为例说明 Gossip 协议的实际应用。</p>\n<p>我们经常使用的分布式缓存 Redis 的官方集群解决方案（3.0 版本引入） Redis Cluster 就是基于 Gossip 协议来实现集群中各个节点数据的最终一致性。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-fcacc1eefca6e51354a5f1fc9f2919f51ec.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Redis Cluster 是一个典型的分布式系统，分布式系统中的各个节点需要互相通信。既然要相互通信就要遵循一致的通信协议，Redis Cluster 中的各个节点基于 <strong>Gossip 协议</strong> 来进行通信共享信息，每个 Redis 节点都维护了一份集群的状态信息。</p>\n<p>Redis Cluster 的节点之间会相互发送多种 Gossip 消息：</p>\n<ul>\n<li><strong>MEET</strong>：在 Redis Cluster 中的某个 Redis 节点上执行 <code>CLUSTER MEET ip port</code> 命令，可以向指定的 Redis 节点发送一条 MEET 信息，用于将其添加进 Redis Cluster 成为新的 Redis 节点。</li>\n<li><strong>PING/PONG</strong>：Redis Cluster 中的节点都会定时地向其他节点发送 PING 消息，来交换各个节点状态信息，检查各个节点状态，包括在线状态、疑似下线状态 PFAIL 和已下线状态 FAIL。</li>\n<li><strong>FAIL</strong>：Redis Cluster 中的节点 A 发现 B 节点 PFAIL ，并且在下线报告的有效期限内集群中半数以上的节点将 B 节点标记为 PFAIL，节点 A 就会向集群广播一条 FAIL 消息，通知其他节点将故障节点 B 标记为 FAIL 。</li>\n<li>......</li>\n</ul>\n<p>下图就是主从架构的 Redis Cluster 的示意图，图中的虚线代表的就是各个节点之间使用 Gossip 进行通信 ，实线表示主从复制。</p>\n<figure><figcaption></figcaption></figure>\n<p>有了 Redis Cluster 之后，不需要专门部署 Sentinel 集群服务了。Redis Cluster 相当于是内置了 Sentinel 机制，Redis Cluster 内部的各个 Redis 节点通过 Gossip 协议互相探测健康状态，在故障时可以自动切换。</p>\n<p>关于 Redis Cluster 的详细介绍，可以查看这篇文章 <a href=\"https://javaguide.cn/database/redis/redis-cluster.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 集群详解(付费)</a> 。</p>\n<h2>Gossip 协议消息传播模式</h2>\n<p>Gossip 设计了两种可能的消息传播模式：<strong>反熵（Anti-Entropy）</strong> 和 <strong>传谣（Rumor-Mongering）</strong>。</p>\n<h3>反熵(Anti-entropy)</h3>\n<p>根据维基百科：</p>\n<blockquote>\n<p>熵的概念最早起源于<a href=\"https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%AD%A6\" target=\"_blank\" rel=\"noopener noreferrer\">物理学</a>，用于度量一个热力学系统的混乱程度。熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。</p>\n</blockquote>\n<p>在这里，你可以把反熵中的熵了解为节点之间数据的混乱程度/差异性，反熵就是指消除不同节点中数据的差异，提升节点间数据的相似度，从而降低熵值。</p>\n<p>具体是如何反熵的呢？集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。</p>\n<p>在实现反熵的时候，主要有推、拉和推拉三种方式：</p>\n<ul>\n<li>推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵。</li>\n<li>拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵。</li>\n<li>推拉就是同时修复自己副本和对方副本中的熵。</li>\n</ul>\n<p>伪代码如下：</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-df16e98bf71e872a7e1f01ca31cee93d77b.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在我们实际应用场景中，一般不会采用随机的节点进行反熵，而是需要可以的设计一个闭环。这样的话，我们能够在一个确定的时间范围内实现各个节点数据的最终一致性，而不是基于随机的概率。像 InfluxDB 就是这样来实现反熵的。</p>\n<figure><figcaption></figcaption></figure>\n<ol>\n<li>节点 A 推送数据给节点 B，节点 B 获取到节点 A 中的最新数据。</li>\n<li>节点 B 推送数据给 C，节点 C 获取到节点 A，B 中的最新数据。</li>\n<li>节点 C 推送数据给 A，节点 A 获取到节点 B，C 中的最新数据。</li>\n<li>节点 A 再推送数据给 B 形成闭环，这样节点 B 就获取到节点 C 中的最新数据。</li>\n</ol>\n<p>虽然反熵很简单实用，但是，节点过多或者节点动态变化的话，反熵就不太适用了。这个时候，我们想要实现最终一致性就要靠 <strong>谣言传播(Rumor mongering)</strong> 。</p>\n<h3>谣言传播(Rumor mongering)</h3>\n<p>谣言传播指的是分布式系统中的一个节点一旦有了新数据之后，就会变为活跃节点，活跃节点会周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。</p>\n<p>如下图所示（下图来自于<a href=\"https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/\" target=\"_blank\" rel=\"noopener noreferrer\">INTRODUCTION TO GOSSIP</a> 这篇文章）：</p>\n<p>![Gossip 传播示意图](./images/gossip/gossip-rumor- mongering.gif)</p>\n<p>伪代码如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/20210605170707933.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>谣言传播比较适合节点数量比较多的情况，不过，这种模式下要尽量避免传播的信息包不能太大，避免网络消耗太大。</p>\n<h3>总结</h3>\n<ul>\n<li>反熵（Anti-Entropy）会传播节点的所有数据，而谣言传播（Rumor-Mongering）只会传播节点新增的数据。</li>\n<li>我们一般会给反熵设计一个闭环。</li>\n<li>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</li>\n</ul>\n<h2>Gossip 协议优势和缺陷</h2>\n<p><strong>优势：</strong></p>\n<p>1、相比于其他分布式协议/算法来说，Gossip 协议理解起来非常简单。</p>\n<p>2、能够容忍网络上节点的随意地增加或者减少，宕机或者重启，因为 Gossip 协议下这些节点都是平等的，去中心化的。新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致。</p>\n<p>3、速度相对较快。节点数量比较多的情况下，扩散速度比一个主节点向其他节点传播信息要更快（多播）。</p>\n<p><strong>缺陷</strong> :</p>\n<p>1、消息需要通过多个传播的轮次才能传播到整个网络中，因此，必然会出现各节点状态不一致的情况。毕竟，Gossip 协议强调的是最终一致，至于达到各个节点的状态一致需要多长时间，谁也无从得知。</p>\n<p>2、由于拜占庭将军问题，不允许存在恶意节点。</p>\n<p>3、可能会出现消息冗余的问题。由于消息传播的随机性，同一个节点可能会重复收到相同的消息。</p>\n<h2>总结</h2>\n<ul>\n<li>Gossip 协议是一种允许在分布式系统中共享状态的通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</li>\n<li>Gossip 协议被 Redis、Apache Cassandra、Consul 等项目应用。</li>\n<li>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</li>\n</ul>\n<h2>参考</h2>\n<ul>\n<li>一万字详解 Redis Cluster Gossip 协议：https://segmentfault.com/a/1190000038373546</li>\n<li>《分布式协议与算法实战》</li>\n<li>《Redis 设计与实现》</li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Paxos 算法详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/protocol/paxos-algorithm.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/protocol/paxos-algorithm.html",
      "summary": "背景 Paxos 算法是 Leslie Lamport（莱斯利·兰伯特）在 1990 年提出了一种分布式系统 共识 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。 为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos ...",
      "content_html": "<h2>背景</h2>\n<p>Paxos 算法是 Leslie Lamport（<a href=\"https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E4%BC%AF%E7%89%B9\" target=\"_blank\" rel=\"noopener noreferrer\">莱斯利·兰伯特</a>）在 <strong>1990</strong> 年提出了一种分布式系统 <strong>共识</strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。</p>\n<p>为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。</p>\n<p>不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。</p>\n<p>于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。</p>\n<p>直到 1998 年，系统研究中心 (Systems Research Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos 算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 <strong>1998</strong> 年重新发表论文 <a href=\"http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">《The Part-Time Parliament》</a>。</p>\n<p>论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 <strong>2001</strong> 年的时候，兰伯特专门又写了一篇 <a href=\"http://lamport.azurewebsites.net/pubs/paxos-simple.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">《Paxos Made Simple》</a> 的论文来简化对 Paxos 的介绍，主要讲述两阶段共识协议部分，顺便还不忘嘲讽一下这群学者。</p>\n<p>《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的 33 页精简了不少。最关键的是这篇论文的摘要就一句话：</p>\n<figure><figcaption></figcaption></figure>\n<blockquote>\n<p>The Paxos algorithm, when presented in plain English, is very simple.</p>\n</blockquote>\n<p>翻译过来的意思大概就是：当我用无修饰的英文来描述时，Paxos 算法真心简单！</p>\n<p>有没有感觉到来自兰伯特大佬满满地嘲讽的味道？</p>\n<h2>介绍</h2>\n<p>Paxos 算法是第一个被证明完备的分布式系统共识算法。共识算法的作用是让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法。提案的含义在分布式系统中十分宽泛，像哪一个节点是 Leader 节点、多个事件发生的顺序等等都可以是一个提案。</p>\n<p>兰伯特当时提出的 Paxos 算法主要包含 2 个部分:</p>\n<ul>\n<li><strong>Basic Paxos 算法</strong>：描述的是多节点之间如何就某个值(提案 Value)达成共识。</li>\n<li><strong>Multi-Paxos 思想</strong>：描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。Multi-Paxos 说白了就是执行多次 Basic Paxos ，核心还是 Basic Paxos 。</li>\n</ul>\n<p>由于 Paxos 算法在国际上被公认的非常难以理解和实现，因此不断有人尝试简化这一算法。到了 2013 年才诞生了一个比 Paxos 算法更易理解和实现的共识算法—<a href=\"https://javaguide.cn/distributed-system/theorem&amp;algorithm&amp;protocol/raft-algorithm.html\" target=\"_blank\" rel=\"noopener noreferrer\">Raft 算法</a> 。更具体点来说，Raft 是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现。</p>\n<p>针对没有恶意节点的情况，除了 Raft 算法之外，当前最常用的一些共识算法比如 <strong>ZAB 协议</strong>、 <strong>Fast Paxos</strong> 算法都是基于 Paxos 算法改进的。</p>\n<p>针对存在恶意节点的情况，一般使用的是 <strong>工作量证明（POW，Proof-of-Work）</strong>、 <strong>权益证明（PoS，Proof-of-Stake ）</strong> 等共识算法。这类共识算法最典型的应用就是区块链，就比如说前段时间以太坊官方宣布其共识机制正在从工作量证明(PoW)转变为权益证明(PoS)。</p>\n<p>区块链系统使用的共识算法需要解决的核心问题是 <strong>拜占庭将军问题</strong> ，这和我们日常接触到的 ZooKeeper、Etcd、Consul 等分布式中间件不太一样。</p>\n<p>下面我们来对 Paxos 算法的定义做一个总结：</p>\n<ul>\n<li>Paxos 算法是兰伯特在 <strong>1990</strong> 年提出了一种分布式系统共识算法。</li>\n<li>兰伯特当时提出的 Paxos 算法主要包含 2 个部分: Basic Paxos 算法和 Multi-Paxos 思想。</li>\n<li>Raft 算法、ZAB 协议、 Fast Paxos 算法都是基于 Paxos 算法改进而来。</li>\n</ul>\n<h2>Basic Paxos 算法</h2>\n<p>Basic Paxos 中存在 3 个重要的角色：</p>\n<ol>\n<li><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号 (Proposal ID) 和提议的值 (Value)。</li>\n<li><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史；</li>\n<li><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。</li>\n</ol>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-890fa3212e8bf72886a595a34654918486c.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为了减少实现该算法所需的节点数，一个节点可以身兼多个角色。并且，一个提案被选定需要被半数以上的 Acceptor 接受。这样的话，Basic Paxos 算法还具备容错性，在少于一半的节点出现故障时，集群仍能正常工作。</p>\n<h2>Multi Paxos 思想</h2>\n<p>Basic Paxos 算法的仅能就单个值达成共识，为了能够对一系列的值达成共识，我们需要用到 Basic Paxos 思想。</p>\n<p>⚠️<strong>注意</strong>：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。也就是说，Basic Paxos 是 Multi-Paxos 思想的核心，Multi-Paxos 就是多执行几次 Basic Paxos。</p>\n<p>由于兰伯特提到的 Multi-Paxos 思想缺少代码实现的必要细节(比如怎么选举领导者)，所以在理解和实现上比较困难。</p>\n<p>不过，也不需要担心，我们并不需要自己实现基于 Multi-Paxos 思想的共识算法，业界已经有了比较出名的实现。像 Raft 算法就是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现，实际项目中可以优先考虑 Raft 算法。</p>\n<h2>参考</h2>\n<ul>\n<li>https://zh.wikipedia.org/wiki/Paxos</li>\n<li>分布式系统中的一致性与共识算法：http://www.xuyasong.com/?p=1970</li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Raft 算法详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/protocol/raft-algorithm.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/protocol/raft-algorithm.html",
      "summary": "本文由 SnailClimb 和 Xieqijun 共同完成。 1 背景 当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。 因此，系统必须在正常操作期间处理服务器的上下线。它们必须对变故做出反应并在几秒钟内自动适应；对客户来说的话，明显...",
      "content_html": "<blockquote>\n<p>本文由 <a href=\"https://github.com/Snailclimb\" target=\"_blank\" rel=\"noopener noreferrer\">SnailClimb</a> 和 <a href=\"https://github.com/jun0315\" target=\"_blank\" rel=\"noopener noreferrer\">Xieqijun</a> 共同完成。</p>\n</blockquote>\n<h2>1 背景</h2>\n<p>当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。</p>\n<p>因此，系统必须在正常操作期间处理服务器的上下线。它们必须对变故做出反应并在几秒钟内自动适应；对客户来说的话，明显的中断通常是不可接受的。</p>\n<p>幸运的是，分布式共识可以帮助应对这些挑战。</p>\n<h3>1.1 拜占庭将军</h3>\n<p>在介绍共识算法之前，先介绍一个简化版拜占庭将军的例子来帮助理解共识算法。</p>\n<blockquote>\n<p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？</p>\n</blockquote>\n<p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。</p>\n<p>举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C，如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，是否需要进攻就由大将军 A 决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。</p>\n<h3>1.2 共识算法</h3>\n<p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p>\n<p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/paxos-rsm-architecture.png\" alt=\"rsm-architecture.png\" tabindex=\"0\"><figcaption>rsm-architecture.png</figcaption></figure>\n<p><code>图-1 复制状态机架构</code></p>\n<p>一般通过使用复制日志来实现复制状态机。每个<code>Server</code>存储着一份包括命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。</p>\n<p>因此共识算法的工作就是保持复制日志的一致性。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端，因此，这些服务器形成了一个单一的、高度可靠的状态机。</p>\n<p>适用于实际系统的共识算法通常具有以下特性：</p>\n<ul>\n<li>\n<p>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。</p>\n</li>\n<li>\n<p>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。</p>\n</li>\n<li>\n<p>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。</p>\n</li>\n<li>\n<p>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。</p>\n</li>\n</ul>\n<h2>2 基础</h2>\n<h3>2.1 节点类型</h3>\n<p>一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：</p>\n<ul>\n<li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li>\n<li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li>\n<li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li>\n</ul>\n<p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/paxos-server-state.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>图-2：服务器的状态</code></p>\n<h3>2.2 任期</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/paxos-term.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>图-3：任期</code></p>\n<p>如图 3 所示，raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term 号。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。</p>\n<p>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。</p>\n<h3>2.3 日志</h3>\n<ul>\n<li><code>entry</code>：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<code>&lt;term,index,cmd&gt;</code>其中 cmd 是可以应用到状态机的操作。</li>\n<li><code>log</code>：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。</li>\n</ul>\n<h2>3 领导人选举</h2>\n<p>raft 使用心跳机制来触发 Leader 的选举。</p>\n<p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p>\n<p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p>\n<p>为了开始新的选举，Follower 会自增自己的 term 号并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p>\n<ul>\n<li>赢得选举</li>\n<li>其他节点赢得选举</li>\n<li>一轮选举结束，无人胜出</li>\n</ul>\n<p>赢得选举的条件是：一个 Candidate 在一个任期内收到了来自集群内的多数选票<code>（N/2+1）</code>，就可以成为 Leader。</p>\n<p>在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：</p>\n<ul>\n<li>该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。</li>\n<li>该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。</li>\n</ul>\n<p>由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p>\n<p>raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的选举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。</p>\n<h2>4 日志复制</h2>\n<p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Mechine</code>）执行的命令。</p>\n<p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p>\n<p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p>\n<p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以成为这个 entry 是 committed 的，并且向客户端返回执行结果。</p>\n<p>raft 保证以下两个性质：</p>\n<ul>\n<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li>\n<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li>\n</ul>\n<p>通过“仅有 Leader 可以生成 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。</p>\n<p>一般情况下，Leader 和 Follower 的日志保持一致，然后，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。Leader 通过强制 Follower 复制自己的日志来处理日志的不一致。这就意味着，在 Follower 上的冲突日志会被领导者的日志覆盖。</p>\n<p>为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。</p>\n<p><code>Leader</code> 给每一个<code>Follower</code> 维护了一个 <code>nextIndex</code>，它表示 <code>Leader</code> 将要发送给该追随者的下一条日志条目的索引。当一个 <code>Leader</code> 开始掌权时，它会将 <code>nextIndex</code> 初始化为它的最新的日志条目索引数+1。如果一个 <code>Follower</code> 的日志和 <code>Leader</code> 的不一致，<code>AppendEntries</code> 一致性检查会在下一次 <code>AppendEntries RPC</code> 时返回失败。在失败之后，<code>Leader</code> 会将 <code>nextIndex</code> 递减然后重试 <code>AppendEntries RPC</code>。最终 <code>nextIndex</code> 会达到一个 <code>Leader</code> 和 <code>Follower</code> 日志一致的地方。这时，<code>AppendEntries</code> 会返回成功，<code>Follower</code> 中冲突的日志条目都被移除了，并且添加所缺少的上了 <code>Leader</code> 的日志条目。一旦 <code>AppendEntries</code> 返回成功，<code>Follower</code> 和 <code>Leader</code> 的日志就一致了，这样的状态会保持到该任期结束。</p>\n<h2>5 安全性</h2>\n<h3>5.1 选举限制</h3>\n<p>Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。</p>\n<p>每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。</p>\n<p>判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。</p>\n<h3>5.2 节点崩溃</h3>\n<p>如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。</p>\n<p>如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。</p>\n<h3>5.3 时间与可用性</h3>\n<p>raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：</p>\n<p><code>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</code></p>\n<ul>\n<li><code>broadcastTime</code>：向其他节点并发发送消息的平均响应时间；</li>\n<li><code>electionTimeout</code>：选举超时时间；</li>\n<li><code>MTBF(mean time between failures)</code>：单台机器的平均健康时间；</li>\n</ul>\n<p><code>broadcastTime</code>应该比<code>electionTimeout</code>小一个数量级，为的是使<code>Leader</code>能够持续发送心跳信息（heartbeat）来阻止<code>Follower</code>开始选举；</p>\n<p><code>electionTimeout</code>也要比<code>MTBF</code>小几个数量级，为的是使得系统稳定运行。当<code>Leader</code>崩溃时，大约会在整个<code>electionTimeout</code>的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。</p>\n<p>由于<code>broadcastTime</code>和<code>MTBF</code>是由系统决定的属性，因此需要决定<code>electionTimeout</code>的时间。</p>\n<p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p>\n<h2>6 参考</h2>\n<ul>\n<li>https://tanxinyu.work/raft/</li>\n<li>https://github.com/OneSizeFitsQuorum/raft-thesis-zh_cn/blob/master/raft-thesis-zh_cn.md</li>\n<li>https://github.com/ongardie/dissertation/blob/master/stanford.pdf</li>\n<li>https://knowledge-sharing.gitbooks.io/raft/content/chapter5.html</li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/paxos-rsm-architecture.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Dubbo常见问题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/rpc/dubbo.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/rpc/dubbo.html",
      "summary": "提示 Dubbo3 已经发布，这篇文章是基于 Dubbo2 写的。Dubbo3 基于 Dubbo2 演进而来，在保持原有核心功能特性的同时， Dubbo3 在易用性、超大规模微服务实践、云原生基础设施适配、安全设计等几大方向上进行了全面升级。 本文中的很多链接已经失效，主要原因是因为 Dubbo 官方文档进行了修改导致 URL 失效。 这篇文章是我根据...",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<ul>\n<li>Dubbo3 已经发布，这篇文章是基于 Dubbo2 写的。Dubbo3 基于 Dubbo2 演进而来，在保持原有核心功能特性的同时， Dubbo3 在易用性、超大规模微服务实践、云原生基础设施适配、安全设计等几大方向上进行了全面升级。</li>\n<li>本文中的很多链接已经失效，主要原因是因为 Dubbo 官方文档进行了修改导致 URL 失效。</li>\n</ul>\n</div>\n<p>这篇文章是我根据官方文档以及自己平时的使用情况，对 Dubbo 所做的一个总结。欢迎补充！</p>\n<h2>Dubbo 基础</h2>\n<h3>什么是 Dubbo?</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/rpc/dubbo.org-overview.png\" alt=\"Dubbo 官网\" tabindex=\"0\"><figcaption>Dubbo 官网</figcaption></figure>\n<p><a href=\"https://github.com/apache/dubbo\" target=\"_blank\" rel=\"noopener noreferrer\">Apache Dubbo</a> |ˈdʌbəʊ| 是一款高性能、轻量级的开源 WEB 和 RPC 框架。</p>\n<p>根据 <a href=\"https://dubbo.apache.org/zh/\" target=\"_blank\" rel=\"noopener noreferrer\">Dubbo 官方文档</a>的介绍，Dubbo 提供了六大核心能力</p>\n<ol>\n<li>面向接口代理的高性能 RPC 调用。</li>\n<li>智能容错和负载均衡。</li>\n<li>服务自动注册和发现。</li>\n<li>高度可扩展能力。</li>\n<li>运行期流量调度。</li>\n<li>可视化的服务治理与运维。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/源码/dubbo/dubbo提供的六大核心能力.png\" alt=\"Dubbo提供的六大核心能力\" tabindex=\"0\"><figcaption>Dubbo提供的六大核心能力</figcaption></figure>\n<p>简单来说就是：<strong>Dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。</strong></p>\n<p>Dubbo 目前已经有接近 34.4 k 的 Star 。</p>\n<p>在 <strong>2020 年度 OSC 中国开源项目</strong> 评选活动中，Dubbo 位列开发框架和基础组件类项目的第 7 名。相比几年前来说，热度和排名有所下降。</p>\n<figure><img src=\"https://oss.javaguide.cn/源码/dubbo/image-20210107153159545.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Dubbo 是由阿里开源，后来加入了 Apache 。正是由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>\n<h3>为什么要用 Dubbo?</h3>\n<p>随着互联网的发展，网站的规模越来越大，用户数量越来越多。单一应用架构、垂直应用架构无法满足我们的需求，这个时候分布式服务架构就诞生了。</p>\n<p>分布式服务架构下，系统被拆分成不同的服务比如短信服务、安全服务，每个服务独立提供系统的某个核心服务。</p>\n<p>我们可以使用 Java RMI（Java Remote Method Invocation）、Hessian 这种支持远程调用的框架来简单地暴露和引用远程服务。但是！当服务越来越多之后，服务调用关系越来越复杂。当应用访问压力越来越大后，负载均衡以及服务监控的需求也迫在眉睫。我们可以用 F5 这类硬件来做负载均衡，但这样增加了成本，并且存在单点故障的风险。</p>\n<p>不过，Dubbo 的出现让上述问题得到了解决。<strong>Dubbo 帮助我们解决了什么问题呢？</strong></p>\n<ol>\n<li><strong>负载均衡</strong>：同一个服务部署在不同的机器时该调用哪一台机器上的服务。</li>\n<li><strong>服务调用链路生成</strong>：随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。</li>\n<li><strong>服务访问压力以及时长统计、资源调度和治理</strong>：基于访问压力实时管理集群容量，提高集群利用率。</li>\n<li>......</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/rpc/dubbo-features-overview.jpg\" alt=\"Dubbo 能力概览\" tabindex=\"0\"><figcaption>Dubbo 能力概览</figcaption></figure>\n<p>另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。</p>\n<p><strong>我们刚刚提到了分布式这个概念，下面再给大家介绍一下什么是分布式？为什么要分布式？</strong></p>\n<h2>分布式基础</h2>\n<h3>什么是分布式?</h3>\n<p>分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。</p>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/分布式事务示意图.png\" alt=\"分布式事务示意图\" tabindex=\"0\"><figcaption>分布式事务示意图</figcaption></figure>\n<h3>为什么要分布式?</h3>\n<p>从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。</p>\n<p>另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。你想一想嘛？把整个系统拆分成不同的服务/系统，然后每个服务/系统 单独部署在一台服务器上，是不是很大程度上提高了系统性能呢？</p>\n<h2>Dubbo 架构</h2>\n<h3>Dubbo 架构中的核心角色有哪些？</h3>\n<p><a href=\"https://dubbo.apache.org/zh/docs/v2.7/dev/design/\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档中的框架设计章节</a> 已经介绍的非常详细了，我这里把一些比较重要的点再提一下。</p>\n<figure><img src=\"https://oss.javaguide.cn/源码/dubbo/dubbo-relation.jpg\" alt=\"dubbo-relation\" tabindex=\"0\"><figcaption>dubbo-relation</figcaption></figure>\n<p>上述节点简单介绍以及他们之间的关系：</p>\n<ul>\n<li><strong>Container：</strong> 服务运行容器，负责加载、运行服务提供者。必须。</li>\n<li><strong>Provider：</strong> 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。</li>\n<li><strong>Consumer：</strong> 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。</li>\n<li><strong>Registry：</strong> 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。</li>\n<li><strong>Monitor：</strong> 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。</li>\n</ul>\n<h3>Dubbo 中的 Invoker 概念了解么？</h3>\n<p><code>Invoker</code> 是 Dubbo 领域模型中非常重要的一个概念，你如果阅读过 Dubbo 源码的话，你会无数次看到这玩意。就比如下面我要说的负载均衡这块的源码中就有大量 <code>Invoker</code> 的身影。</p>\n<p>简单来说，<code>Invoker</code> 就是 Dubbo 对远程调用的抽象。</p>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/dubbo_rpc_invoke.jpg\" alt=\"dubbo_rpc_invoke.jpg\" tabindex=\"0\"><figcaption>dubbo_rpc_invoke.jpg</figcaption></figure>\n<p>按照 Dubbo 官方的话来说，<code>Invoker</code> 分为</p>\n<ul>\n<li>服务提供 <code>Invoker</code></li>\n<li>服务消费 <code>Invoker</code></li>\n</ul>\n<p>假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节吧！我们屏蔽掉的这些细节就依赖对应的 <code>Invoker</code> 实现， <code>Invoker</code> 实现了真正的远程服务调用。</p>\n<h3>Dubbo 的工作原理了解么？</h3>\n<p>下图是 Dubbo 的整体设计，从下至上分为十层，各层均为单向依赖。</p>\n<blockquote>\n<p>左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/source-code/dubbo/dubbo-framework.jpg\" alt=\"dubbo-framework\" tabindex=\"0\"><figcaption>dubbo-framework</figcaption></figure>\n<ul>\n<li><strong>config 配置层</strong>：Dubbo 相关的配置。支持代码配置，同时也支持基于 Spring 来做配置，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心</li>\n<li><strong>proxy 服务代理层</strong>：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 <code>ServiceProxy</code> 为中心。</li>\n<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现。</li>\n<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心。</li>\n<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心。</li>\n<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 <code>Invocation</code>, <code>Result</code> 为中心。</li>\n<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心。</li>\n<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心。</li>\n<li><strong>serialize 数据序列化层</strong>：对需要在网络传输的数据进行序列化。</li>\n</ul>\n<h3>Dubbo 的 SPI 机制了解么？ 如何扩展 Dubbo 中的默认实现？</h3>\n<p>SPI（Service Provider Interface） 机制被大量用在开源项目中，它可以帮助我们动态寻找服务/功能（比如负载均衡策略）的实现。</p>\n<p>SPI 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和 IoC 的解耦思想是类似的。</p>\n<p>Java 本身就提供了 SPI 机制的实现。不过，Dubbo 没有直接用，而是对 Java 原生的 SPI 机制进行了增强，以便更好满足自己的需求。</p>\n<p><strong>那我们如何扩展 Dubbo 中的默认实现呢？</strong></p>\n<p>比如说我们想要实现自己的负载均衡策略，我们创建对应的实现类 <code>XxxLoadBalance</code> 实现 <code>LoadBalance</code> 接口或者 <code>AbstractLoadBalance</code> 类。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>xxx</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>dubbo<span class=\"token punctuation\">.</span>rpc<span class=\"token punctuation\">.</span>cluster<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">LoadBalance</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>dubbo<span class=\"token punctuation\">.</span>rpc<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Invoker</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>dubbo<span class=\"token punctuation\">.</span>rpc<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Invocation</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>dubbo<span class=\"token punctuation\">.</span>rpc<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RpcException</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">XxxLoadBalance</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">LoadBalance</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token class-name\">Invoker</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Invoker</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> invokers<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Invocation</span> invocation<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RpcException</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>我们将这个实现类的路径写入到<code>resources</code> 目录下的 <code>META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance</code>文件中即可。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code>src\n <span class=\"token operator\">|</span><span class=\"token operator\">-</span>main\n    <span class=\"token operator\">|</span><span class=\"token operator\">-</span>java\n        <span class=\"token operator\">|</span><span class=\"token operator\">-</span>com\n            <span class=\"token operator\">|</span><span class=\"token operator\">-</span>xxx\n                <span class=\"token operator\">|</span><span class=\"token operator\">-</span><span class=\"token class-name\">XxxLoadBalance</span><span class=\"token punctuation\">.</span>java <span class=\"token punctuation\">(</span>实现<span class=\"token class-name\">LoadBalance</span>接口<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">|</span><span class=\"token operator\">-</span>resources\n        <span class=\"token operator\">|</span><span class=\"token operator\">-</span><span class=\"token constant\">META</span><span class=\"token operator\">-</span><span class=\"token constant\">INF</span>\n            <span class=\"token operator\">|</span><span class=\"token operator\">-</span>dubbo\n                <span class=\"token operator\">|</span><span class=\"token operator\">-</span><span class=\"token class-name\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>dubbo<span class=\"token punctuation\">.</span>rpc<span class=\"token punctuation\">.</span>cluster<span class=\"token punctuation\">.</span></span>LoadBalance</span> <span class=\"token punctuation\">(</span>纯文本文件，内容为：xxx<span class=\"token operator\">=</span><span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>xxx<span class=\"token punctuation\">.</span></span>XxxLoadBalance</span><span class=\"token punctuation\">)</span>\n</code></pre></div><p><code>org.apache.dubbo.rpc.cluster.LoadBalance</code></p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>xxx=com.xxx.XxxLoadBalance\n</code></pre></div><p>其他还有很多可供扩展的选择，你可以在<a href=\"https://cn.dubbo.apache.org/zh-cn/overview/home/\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a>中找到。</p>\n<h3>Dubbo 的微内核架构了解吗？</h3>\n<p>Dubbo 采用 微内核（Microkernel） + 插件（Plugin） 模式，简单来说就是微内核架构。微内核只负责组装插件。</p>\n<p><strong>何为微内核架构呢？</strong> 《软件架构模式》 这本书是这样介绍的：</p>\n<blockquote>\n<p>微内核架构模式（有时被称为插件架构模式）是实现基于产品应用程序的一种自然模式。基于产品的应用程序是已经打包好并且拥有不同版本，可作为第三方插件下载的。然后，很多公司也在开发、发布自己内部商业应用像有版本号、说明及可加载插件式的应用软件（这也是这种模式的特征）。微内核系统可让用户添加额外的应用如插件，到核心应用，继而提供了可扩展性和功能分离的用法。</p>\n</blockquote>\n<p>微内核架构包含两类组件：<strong>核心系统（core system）</strong> 和 <strong>插件模块（plug-in modules）</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/source-code/dubbo/微内核架构示意图.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>核心系统提供系统所需核心能力，插件模块可以扩展系统的功能。因此， 基于微内核架构的系统，非常易于扩展功能。</p>\n<p>我们常见的一些 IDE，都可以看作是基于微内核架构设计的。绝大多数 IDE 比如 IDEA、VSCode 都提供了插件来丰富自己的功能。</p>\n<p>正是因为 Dubbo 基于微内核架构，才使得我们可以随心所欲替换 Dubbo 的功能点。比如你觉得 Dubbo 的序列化模块实现的不满足自己要求，没关系啊！你自己实现一个序列化模块就好了啊！</p>\n<p>通常情况下，微核心都会采用 Factory、IoC、OSGi 等方式管理插件生命周期。Dubbo 不想依赖 Spring 等 IoC 容器，也不想自己造一个小的 IoC 容器（过度设计），因此采用了一种最简单的 Factory 方式管理插件：<strong>JDK 标准的 SPI 扩展机制</strong> （<code>java.util.ServiceLoader</code>）。</p>\n<h3>关于 Dubbo 架构的一些自测小问题</h3>\n<h4>注册中心的作用了解么？</h4>\n<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互。</p>\n<h4>服务提供者宕机后，注册中心会做什么？</h4>\n<p>注册中心会立即推送事件通知消费者。</p>\n<h4>监控中心的作用呢？</h4>\n<p>监控中心负责统计各服务调用次数，调用时间等。</p>\n<h4>注册中心和监控中心都宕机的话，服务都会挂掉吗？</h4>\n<p>不会。两者都宕机也不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。</p>\n<h2>Dubbo 的负载均衡策略</h2>\n<h3>什么是负载均衡？</h3>\n<p>先来看一下稍微官方点的解释。下面这段话摘自维基百科对负载均衡的定义：</p>\n<blockquote>\n<p>负载均衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件。</p>\n</blockquote>\n<p><strong>上面讲的大家可能不太好理解，再用通俗的话给大家说一下。</strong></p>\n<p>我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p>\n<h3>Dubbo 提供的负载均衡策略有哪些？</h3>\n<p>在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 <code>random</code> 随机调用。我们还可以自行扩展负载均衡策略（参考 Dubbo SPI 机制）。</p>\n<p>在 Dubbo 中，所有负载均衡实现类均继承自 <code>AbstractLoadBalance</code>，该类实现了 <code>LoadBalance</code> 接口，并封装了一些公共的逻辑。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractLoadBalance</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">LoadBalance</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">calculateWarmupWeight</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> uptime<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> warmup<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> weight<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token class-name\">Invoker</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Invoker</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> invokers<span class=\"token punctuation\">,</span> <span class=\"token class-name\">URL</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Invocation</span> invocation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token class-name\">Invoker</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">doSelect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Invoker</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> invokers<span class=\"token punctuation\">,</span> <span class=\"token class-name\">URL</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Invocation</span> invocation<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">int</span> <span class=\"token function\">getWeight</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Invoker</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">&gt;</span></span> invoker<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Invocation</span> invocation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><code>AbstractLoadBalance</code> 的实现类有下面这些：</p>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/image-20210326105257812.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>官方文档对负载均衡这部分的介绍非常详细，推荐小伙伴们看看，地址：<a href=\"https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance\" target=\"_blank\" rel=\"noopener noreferrer\">https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance</a> 。</p>\n<h4>RandomLoadBalance</h4>\n<p>根据权重随机选择（对加权随机算法的实现）。这是 Dubbo 默认采用的一种负载均衡策略。</p>\n<p><code> RandomLoadBalance</code> 具体的实现原理非常简单，假如有两个提供相同服务的服务器 S1,S2，S1 的权重为 7，S2 的权重为 3。</p>\n<p>我们把这些权重值分布在坐标区间会得到：S1-&gt;[0, 7) ，S2-&gt;[7, 10)。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。</p>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/ RandomLoadBalance.png\" alt=\"RandomLoadBalance\" tabindex=\"0\"><figcaption>RandomLoadBalance</figcaption></figure>\n<p><code>RandomLoadBalance</code> 的源码非常简单，简单花几分钟时间看一下。</p>\n<blockquote>\n<p>以下源码来自 Dubbo master 分支上的最新的版本 2.7.9。</p>\n</blockquote>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RandomLoadBalance</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractLoadBalance</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token constant\">NAME</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"random\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token class-name\">Invoker</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">doSelect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Invoker</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> invokers<span class=\"token punctuation\">,</span> <span class=\"token class-name\">URL</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Invocation</span> invocation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> invokers<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">boolean</span> sameWeight <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> weights <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> totalWeight <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 下面这个for循环的主要作用就是计算所有该服务的提供者的权重之和 totalWeight（），</span>\n        <span class=\"token comment\">// 除此之外，还会检测每个服务提供者的权重是否相同</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> weight <span class=\"token operator\">=</span> <span class=\"token function\">getWeight</span><span class=\"token punctuation\">(</span>invokers<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> invocation<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            totalWeight <span class=\"token operator\">+=</span> weight<span class=\"token punctuation\">;</span>\n            weights<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> totalWeight<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sameWeight <span class=\"token operator\">&amp;&amp;</span> totalWeight <span class=\"token operator\">!=</span> weight <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                sameWeight <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>totalWeight <span class=\"token operator\">&gt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>sameWeight<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 随机生成一个 [0, totalWeight) 区间内的数字</span>\n            <span class=\"token keyword\">int</span> offset <span class=\"token operator\">=</span> <span class=\"token class-name\">ThreadLocalRandom</span><span class=\"token punctuation\">.</span><span class=\"token function\">current</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span>totalWeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 判断会落在哪个服务提供者的区间</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>offset <span class=\"token operator\">&lt;</span> weights<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">return</span> invokers<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> invokers<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ThreadLocalRandom</span><span class=\"token punctuation\">.</span><span class=\"token function\">current</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n\n</code></pre></div><h4>LeastActiveLoadBalance</h4>\n<p><code>LeastActiveLoadBalance</code> 直译过来就是<strong>最小活跃数负载均衡</strong>。</p>\n<p>这个名字起得有点不直观，不仔细看官方对活跃数的定义，你压根不知道这玩意是干嘛的。</p>\n<p>我这么说吧！初始状态下所有服务提供者的活跃数均为 0（每个服务提供者的中特定方法都对应一个活跃数，我在后面的源码中会提到），每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。</p>\n<p>因此，<strong>Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。</strong></p>\n<p><strong>如果有多个服务提供者的活跃数相等怎么办？</strong></p>\n<p>很简单，那就再走一遍 <code>RandomLoadBalance</code> 。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LeastActiveLoadBalance</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractLoadBalance</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token constant\">NAME</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"leastactive\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token class-name\">Invoker</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">doSelect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Invoker</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> invokers<span class=\"token punctuation\">,</span> <span class=\"token class-name\">URL</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Invocation</span> invocation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> invokers<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> leastActive <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> leastCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> leastIndexes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> weights <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> totalWeight <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> firstWeight <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">boolean</span> sameWeight <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 这个 for 循环的主要作用是遍历 invokers 列表，找出活跃数最小的 Invoker</span>\n        <span class=\"token comment\">// 如果有多个 Invoker 具有相同的最小活跃数，还会记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">Invoker</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> invoker <span class=\"token operator\">=</span> invokers<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 获取 invoker 对应的活跃(active)数</span>\n            <span class=\"token keyword\">int</span> active <span class=\"token operator\">=</span> <span class=\"token class-name\">RpcStatus</span><span class=\"token punctuation\">.</span><span class=\"token function\">getStatus</span><span class=\"token punctuation\">(</span>invoker<span class=\"token punctuation\">.</span><span class=\"token function\">getUrl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> invocation<span class=\"token punctuation\">.</span><span class=\"token function\">getMethodName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getActive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> afterWarmup <span class=\"token operator\">=</span> <span class=\"token function\">getWeight</span><span class=\"token punctuation\">(</span>invoker<span class=\"token punctuation\">,</span> invocation<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            weights<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> afterWarmup<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leastActive <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">||</span> active <span class=\"token operator\">&lt;</span> leastActive<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                leastActive <span class=\"token operator\">=</span> active<span class=\"token punctuation\">;</span>\n                leastCount <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                leastIndexes<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n                totalWeight <span class=\"token operator\">=</span> afterWarmup<span class=\"token punctuation\">;</span>\n                firstWeight <span class=\"token operator\">=</span> afterWarmup<span class=\"token punctuation\">;</span>\n                sameWeight <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>active <span class=\"token operator\">==</span> leastActive<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                leastIndexes<span class=\"token punctuation\">[</span>leastCount<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n                totalWeight <span class=\"token operator\">+=</span> afterWarmup<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sameWeight <span class=\"token operator\">&amp;&amp;</span> afterWarmup <span class=\"token operator\">!=</span> firstWeight<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    sameWeight <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n       <span class=\"token comment\">// 如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leastCount <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> invokers<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>leastIndexes<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 如果有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同</span>\n        <span class=\"token comment\">// 这里的处理方式就和  RandomLoadBalance 一致了</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>sameWeight <span class=\"token operator\">&amp;&amp;</span> totalWeight <span class=\"token operator\">&gt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> offsetWeight <span class=\"token operator\">=</span> <span class=\"token class-name\">ThreadLocalRandom</span><span class=\"token punctuation\">.</span><span class=\"token function\">current</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span>totalWeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> leastCount<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> leastIndex <span class=\"token operator\">=</span> leastIndexes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                offsetWeight <span class=\"token operator\">-=</span> weights<span class=\"token punctuation\">[</span>leastIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>offsetWeight <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">return</span> invokers<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>leastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> invokers<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>leastIndexes<span class=\"token punctuation\">[</span><span class=\"token class-name\">ThreadLocalRandom</span><span class=\"token punctuation\">.</span><span class=\"token function\">current</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span>leastCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre></div><p>活跃数是通过 <code>RpcStatus</code> 中的一个 <code>ConcurrentMap</code> 保存的，根据 URL 以及服务提供者被调用的方法的名称，我们便可以获取到对应的活跃数。也就是说服务提供者中的每一个方法的活跃数都是互相独立的。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RpcStatus</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ConcurrentMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ConcurrentMap</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">RpcStatus</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token constant\">METHOD_STATISTICS</span> <span class=\"token operator\">=</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ConcurrentMap</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">RpcStatus</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">RpcStatus</span> <span class=\"token function\">getStatus</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">URL</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> methodName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">String</span> uri <span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">toIdentityString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ConcurrentMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">RpcStatus</span><span class=\"token punctuation\">&gt;</span></span> map <span class=\"token operator\">=</span> <span class=\"token constant\">METHOD_STATISTICS</span><span class=\"token punctuation\">.</span><span class=\"token function\">computeIfAbsent</span><span class=\"token punctuation\">(</span>uri<span class=\"token punctuation\">,</span> k <span class=\"token operator\">-&gt;</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">computeIfAbsent</span><span class=\"token punctuation\">(</span>methodName<span class=\"token punctuation\">,</span> k <span class=\"token operator\">-&gt;</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RpcStatus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getActive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> active<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre></div><h4>ConsistentHashLoadBalance</h4>\n<p><code>ConsistentHashLoadBalance</code> 小伙伴们应该也不会陌生，在分库分表、各种集群中就经常使用这个负载均衡策略。</p>\n<p><code>ConsistentHashLoadBalance</code> 即<strong>一致性 Hash 负载均衡策略</strong>。 <code>ConsistentHashLoadBalance</code> 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。</p>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/consistent-hash-data-incline.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。</p>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/consistent-hash-invoker.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>官方有详细的源码分析：<a href=\"https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance\" target=\"_blank\" rel=\"noopener noreferrer\">https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance</a> 。这里还有一个相关的 <a href=\"https://github.com/apache/dubbo/pull/5440\" target=\"_blank\" rel=\"noopener noreferrer\">PR#5440</a> 来修复老版本中 ConsistentHashLoadBalance 存在的一些 Bug。感兴趣的小伙伴，可以多花点时间研究一下。我这里不多分析了，这个作业留给你们！</p>\n<h4>RoundRobinLoadBalance</h4>\n<p>加权轮询负载均衡。</p>\n<p>轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1 的权重为 7，S2 的权重为 3。</p>\n<p>如果我们有 10 次请求，那么 7 次会被 S1 处理，3 次被 S2 处理。</p>\n<p>但是，如果是 <code>RandomLoadBalance</code> 的话，很可能存在 10 次请求有 9 次都被 S1 处理的情况（概率性问题）。</p>\n<p>Dubbo 中的 <code>RoundRobinLoadBalance</code> 的代码实现被修改重建了好几次，Dubbo-2.6.5 版本的 <code>RoundRobinLoadBalance</code> 为平滑加权轮询算法。</p>\n<h2>Dubbo 序列化协议</h2>\n<h3>Dubbo 支持哪些序列化方式呢？</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70-20230309234143460.png\" alt=\"Dubbo 支持的序列化协议\" tabindex=\"0\"><figcaption>Dubbo 支持的序列化协议</figcaption></figure>\n<p>Dubbo 支持多种序列化方式：JDK 自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf 等等。</p>\n<p>Dubbo 默认使用的序列化方式是 hessian2。</p>\n<h3>谈谈你对这些序列化协议了解？</h3>\n<p>一般我们不会直接使用 JDK 自带的序列化方式。主要原因有两个：</p>\n<ol>\n<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>\n<li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>\n</ol>\n<p>JSON 序列化由于性能问题，我们一般也不会考虑使用。</p>\n<p>像 Protostuff，ProtoBuf、hessian2 这些都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p>\n<p>Kryo 和 FST 这两种序列化方式是 Dubbo 后来才引入的，性能非常好。不过，这两者都是专门针对 Java 语言的。Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。</p>\n<p>Dubbo 官方文档中还有一个关于这些<a href=\"https://dubbo.apache.org/zh/docs/v2.7/user/serialization/#m-zhdocsv27userserialization\" target=\"_blank\" rel=\"noopener noreferrer\">序列化协议的性能对比图</a>可供参考。</p>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-00c3ce1e5d222e477ed84310239daa2f6b0.png\" alt=\"序列化协议的性能对比\" tabindex=\"0\"><figcaption>序列化协议的性能对比</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/rpc/dubbo.org-overview.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "有了 HTTP 协议，为什么还要有 RPC ？",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/rpc/http_rpc.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/rpc/http_rpc.html",
      "summary": "本文来自小白 debug投稿，原文：https://juejin.cn/post/7121882245605883934 。 我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？ 于是就到网上去搜。 不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在用一个...",
      "content_html": "<blockquote>\n<p>本文来自<a href=\"https://juejin.cn/user/4001878057422087\" target=\"_blank\" rel=\"noopener noreferrer\">小白 debug</a>投稿，原文：https://juejin.cn/post/7121882245605883934 。</p>\n</blockquote>\n<p>我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？</p>\n<p>于是就到网上去搜。</p>\n<p>不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在<strong>用一个我们不认识的概念去解释另外一个我们不认识的概念</strong>，懂的人不需要看，不懂的人看了还是不懂。</p>\n<p>这种看了，又好像没看的感觉，云里雾里的很难受，<strong>我懂</strong>。</p>\n<p>为了避免大家有强烈的<strong>审丑疲劳</strong>，今天我们来尝试重新换个方式讲一讲。</p>\n<h2>从 TCP 聊起</h2>\n<p>作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。</p>\n<p>这时候，我们可选项一般也就<strong>TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。</strong> 除非是马总这种神级程序员（早期 QQ 大量使用 UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选 TCP 就对了。</p>\n<p>类似下面这样。</p>\n<div class=\"language-ini\" data-ext=\"ini\" data-title=\"ini\"><pre class=\"language-ini\"><code><span class=\"token key attr-name\">fd</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">socket(AF_INET,SOCK_STREAM,0);</span>\n</code></pre></div><p>其中<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP 协议</strong>。</p>\n<p>在定义了 socket 之后，我们就可以愉快的对这个 socket 进行操作，比如用<code>bind()</code>绑定 IP 端口，用<code>connect()</code>发起建连。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"握手建立连接流程\" tabindex=\"0\"><figcaption>握手建立连接流程</figcaption></figure>\n<p>在连接建立之后，我们就可以使用<code>send()</code>发送数据，<code>recv()</code>接收数据。</p>\n<p>光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？</p>\n<p>不行，这么用会有问题。</p>\n<h2>使用纯裸 TCP 会有什么问题</h2>\n<p>八股文常背，TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/acb4508111cb47d8a3df6734d04818bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"TCP是什么\" tabindex=\"0\"><figcaption>TCP是什么</figcaption></figure>\n<p>这三个特点真的概括的 <strong>非常精辟</strong> ，这个八股文我们没白背。</p>\n<p>每个特点展开都能聊一篇文章，而今天我们需要关注的是 <strong>基于字节流</strong> 这一点。</p>\n<p>字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 <strong>01 串</strong> 。纯裸 TCP 收发的这些 01 串之间是 <strong>没有任何边界</strong> 的，你根本不知道到哪个地方才算一条完整消息。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/b82d4fcdd0c4491e979856c93c1750d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"01二进制字节流\" tabindex=\"0\"><figcaption>01二进制字节流</figcaption></figure>\n<p>正因为这个没有任何边界的特点，所以当我们选择使用 TCP 发送 <strong>\"夏洛\"和\"特烦恼\"</strong> 的时候，接收端收到的就是 <strong>\"夏洛特烦恼\"</strong> ，这时候接收端没发区分你是想要表达 <strong>\"夏洛\"+\"特烦恼\"</strong> 还是 <strong>\"夏洛特\"+\"烦恼\"</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/4e120d0f1152419585565f693e744a3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"消息对比\" tabindex=\"0\"><figcaption>消息对比</figcaption></figure>\n<p>这就是所谓的 <strong>粘包问题</strong>，之前也写过一篇专门的<a href=\"https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA\" target=\"_blank\" rel=\"noopener noreferrer\">文章</a>聊过这个问题。</p>\n<p>说这个的目的是为了告诉大家，纯裸 TCP 是不能直接拿来用的，你需要在这个基础上加入一些 <strong>自定义的规则</strong> ，用于区分 <strong>消息边界</strong> 。</p>\n<p>于是我们会把每条要发送的数据都包装一下，比如加入 <strong>消息头</strong> ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的 <strong>消息体</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/cb29659d4907446e9f70551c44c6369f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"消息边界长度标志\" tabindex=\"0\"><figcaption>消息边界长度标志</figcaption></figure>\n<p>而这里头提到的 <strong>消息头</strong> ，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的 <strong>协议。</strong></p>\n<p>每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能 <strong>有区别，但原理都类似</strong>。</p>\n<p><strong>于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p>\n<h2>HTTP 和 RPC</h2>\n<h3>RPC 其实是一种调用方式</h3>\n<p>我们回过头来看网络的分层图。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/04b603b5bd2443209233deea87816161~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"四层网络协议\" tabindex=\"0\"><figcaption>四层网络协议</figcaption></figure>\n<p><strong>TCP 是传输层的协议</strong> ，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的 <strong>应用层协议</strong> 而已。</p>\n<p><strong>HTTP</strong>（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol）协议又叫做 <strong>超文本传输协议</strong> 。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/8f07a5d1c72a4c4fa811c6c3b5aadd3d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"HTTP调用\" tabindex=\"0\"><figcaption>HTTP调用</figcaption></figure>\n<p>而 <strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all）又叫做 <strong>远程过程调用</strong>，它本身并不是一个具体的协议，而是一种 <strong>调用方式</strong> 。</p>\n<p>举个例子，我们平时调用一个 <strong>本地方法</strong> 就像下面这样。</p>\n<div class=\"language-ini\" data-ext=\"ini\" data-title=\"ini\"><pre class=\"language-ini\"><code> <span class=\"token key attr-name\">res</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">localFunc(req)</span>\n</code></pre></div><p>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法<code>remoteFunc</code>，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？</p>\n<div class=\"language-ini\" data-ext=\"ini\" data-title=\"ini\"><pre class=\"language-ini\"><code><span class=\"token key attr-name\">res</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">remoteFunc(req)</span>\n</code></pre></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/761da6c30af244e19b1c44075d8b4254~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"RPC可以像调用本地方法那样调用远端方法\" tabindex=\"0\"><figcaption>RPC可以像调用本地方法那样调用远端方法</figcaption></figure>\n<p>基于这个思路，大佬们造出了非常多款式的 RPC 协议，比如比较有名的<code>gRPC</code>，<code>thrift</code>。</p>\n<p>值得注意的是，虽然大部分 RPC 协议底层使用 TCP，但实际上 <strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p>\n<p>到这里，我们回到文章标题的问题。</p>\n<h3>那既然有 RPC 了，为什么还要有 HTTP 呢？</h3>\n<p>其实，TCP 是 <strong>70 年</strong> 代出来的协议，而 HTTP 是 <strong>90 年代</strong> 才开始流行的。而直接使用裸 TCP 会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有 <strong>80 年代</strong> 出来的<code>RPC</code>。</p>\n<p>所以我们该问的不是 <strong>既然有 HTTP 协议为什么要有 RPC</strong> ，而是 <strong>为什么有 RPC 还要有 HTTP 协议?</strong></p>\n<p>现在电脑上装的各种联网软件，比如 xx 管家，xx 卫士，它们都作为客户端（Client） 需要跟服务端（Server） 建立连接收发消息，此时都会用到应用层协议，在这种 Client/Server (C/S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。</p>\n<p>但有个软件不同，浏览器（Browser） ，不管是 Chrome 还是 IE，它们不仅要能访问自家公司的<strong>服务器（Server）</strong> ，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 <strong>Browser/Server (B/S)</strong> 的协议。</p>\n<p>也就是说在多年以前，<strong>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。</strong> 很多软件同时支持多端，比如某度云盘，既要支持<strong>网页版</strong>，还要支持<strong>手机端和 PC 端</strong>，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p>\n<p>那这么说的话，<strong>都用 HTTP 得了，还用什么 RPC？</strong></p>\n<p>仿佛又回到了文章开头的样子，那这就要从它们之间的区别开始说起。</p>\n<h3>HTTP 和 RPC 有什么区别</h3>\n<p>我们来看看 RPC 和 HTTP 区别比较明显的几个点。</p>\n<h4>服务发现</h4>\n<p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 <strong>IP 地址和端口</strong> 。这个找到服务对应的 IP 端口的过程，其实就是 <strong>服务发现</strong>。</p>\n<p>在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong> 去解析得到它背后的 IP 地址，默认 <strong>80 端口</strong>。</p>\n<p>而 <strong>RPC</strong> 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 <strong>Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 <strong>CoreDNS</strong>。</p>\n<p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p>\n<h4>底层连接形式</h4>\n<p>以主流的 <strong>HTTP1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p>\n<p>而 <strong>RPC</strong> 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 <strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/72fcad064c9e4103a11f1a2d579f79b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"connection_pool\" tabindex=\"0\"><figcaption>connection_pool</figcaption></figure>\n<p>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。</p>\n<p>可以看出这一块两者也没太大区别，所以也不是关键。</p>\n<h4>传输的内容</h4>\n<p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p>\n<p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p>\n<p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p>\n<p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/d501dfc6f764430188ce61fda0f3e5d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"序列化和反序列化\" tabindex=\"0\"><figcaption>序列化和反序列化</figcaption></figure>\n<p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p>\n<p>我们可以随便截个图直观看下。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/04e8a79ddb7247759df23f1132c01655~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"HTTP报文\" tabindex=\"0\"><figcaption>HTTP报文</figcaption></figure>\n<p>可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 <code>Content-Type</code>，就不需要每次都真的把 <code>Content-Type</code> 这个字段都传过来，类似的情况其实在 Body 的 JSON 结构里也特别明显。</p>\n<p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/284c26bb7f2848889d1d9b95cf49decb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"HTTP原理\" tabindex=\"0\"><figcaption>HTTP原理</figcaption></figure>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/edb050d383c644e895e505253f1c4d90~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"RPC原理\" tabindex=\"0\"><figcaption>RPC原理</figcaption></figure>\n<p>当然上面说的 HTTP，其实 <strong>特指的是现在主流使用的 HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以 <strong>性能可能比很多 RPC 协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p>\n<p>那么问题又来了。</p>\n<h3>为什么既然有了 HTTP2，还要有 RPC 协议？</h3>\n<p>这个是由于 HTTP2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p>\n<h2>总结</h2>\n<ul>\n<li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 <strong>消息边界</strong> 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li>\n<li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li>\n<li>从发展历史来说，<strong>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。</strong> 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li>\n<li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li>\n<li><strong>HTTP2.0</strong> 在 <strong>HTTP1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "RPC基础知识总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/rpc/rpc-intro.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/distributed-system/rpc/rpc-intro.html",
      "summary": "这篇文章会简单介绍一下 RPC 相关的基础概念。 RPC 是什么? RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。 为什么要 RPC ？ 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也...",
      "content_html": "<p>这篇文章会简单介绍一下 RPC 相关的基础概念。</p>\n<h2>RPC 是什么?</h2>\n<p><strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p>\n<p><strong>为什么要 RPC ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。</p>\n<p><strong>RPC 能帮助我们做什么呢？</strong> 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。</p>\n<p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p>\n<p>一言蔽之：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p>\n<h2>RPC 的原理是什么?</h2>\n<p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC 的 核心功能看作是下面 👇 5 个部分实现的：</p>\n<ol>\n<li><strong>客户端（服务消费端）</strong>：调用远程方法的一端。</li>\n<li><strong>客户端 Stub（桩）</strong>：这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li>\n<li><strong>网络传输</strong>：网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。</li>\n<li><strong>服务端 Stub（桩）</strong>：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端的类。</li>\n<li><strong>服务端（服务提供端）</strong>：提供远程方法的一端。</li>\n</ol>\n<p>具体原理图如下，后面我会串起来将整个 RPC 的过程给大家说一下。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg\" alt=\"RPC原理图\" tabindex=\"0\"><figcaption>RPC原理图</figcaption></figure>\n<ol>\n<li>服务消费端（client）以本地调用的方式调用远程服务；</li>\n<li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li>\n<li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li>\n<li>服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: <code>RpcRequest</code>；</li>\n<li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li>\n<li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li>\n<li>客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:<code>RpcResponse</code> ，这样也就得到了最终结果。over!</li>\n</ol>\n<p>相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。</p>\n<p>虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。</p>\n<p><strong>最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。</strong></p>\n<h2>有哪些常见的 RPC 框架？</h2>\n<p>我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 Dubbo、Motan、gRPC 这些。 如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如 Feign。</p>\n<h3>Dubbo</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/image-20220716111053081.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Apache Dubbo 是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案，\n涵盖 Java、Golang 等多种语言 SDK 实现。</p>\n<p>Dubbo 提供了从服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，支持 Triple 协议（基于 HTTP/2 之上定义的下一代 RPC 通信协议）、应用级服务发现、Dubbo Mesh （Dubbo3 赋予了很多云原生友好的新特性）等特性。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/image-20220716111545343.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Dubbo 是由阿里开源，后来加入了 Apache 。正是由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>\n<p>Dubbo 算的是比较优秀的国产开源项目了，它的源码也是非常值得学习和阅读的！</p>\n<ul>\n<li>GitHub：<a href=\"https://github.com/apache/incubator-dubbo\" title=\"https://github.com/apache/incubator-dubbo\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/apache/incubator-dubbo</a></li>\n<li>官网：https://dubbo.apache.org/zh/</li>\n</ul>\n<h3>Motan</h3>\n<p>Motan 是新浪微博开源的一款 RPC 框架，据说在新浪微博正支撑着千亿次调用。不过笔者倒是很少看到有公司使用，而且网上的资料也比较少。</p>\n<p>很多人喜欢拿 Motan 和 Dubbo 作比较，毕竟都是国内大公司开源的。笔者在查阅了很多资料，以及简单查看了其源码之后发现：<strong>Motan 更像是一个精简版的 Dubbo，可能是借鉴了 Dubbo 的思想，Motan 的设计更加精简，功能更加纯粹。</strong></p>\n<p>不过，我不推荐你在实际项目中使用 Motan。如果你要是公司实际使用的话，还是推荐 Dubbo ，其社区活跃度以及生态都要好很多。</p>\n<ul>\n<li>从 Motan 看 RPC 框架设计：<a href=\"http://kriszhang.com/motan-rpc-impl/\" title=\"http://kriszhang.com/motan-rpc-impl/\" target=\"_blank\" rel=\"noopener noreferrer\">http://kriszhang.com/motan-rpc-impl/</a></li>\n<li>Motan 中文文档：<a href=\"https://github.com/weibocom/motan/wiki/zh_overview\" title=\"https://github.com/weibocom/motan/wiki/zh_overview\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/weibocom/motan/wiki/zh_overview</a></li>\n</ul>\n<h3>gRPC</h3>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/2843b10d-0c2f-4b7e-9c3e-ea4466792a8b.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP/2 协议标准而设计（支持双向流、消息头压缩等功能，更加节省带宽），基于 ProtoBuf 序列化协议开发，并且支持众多开发语言。</p>\n<p><strong>何谓 ProtoBuf？</strong> <a href=\"https://github.com/protocolbuffers/protobuf\" target=\"_blank\" rel=\"noopener noreferrer\">ProtoBuf（ Protocol Buffer）</a> 是一种更加灵活、高效的数据格式，可用于通讯协议、数据存储等领域，基本支持所有主流编程语言且与平台无关。不过，通过 ProtoBuf 定义接口和数据类型还挺繁琐的，这是一个小问题。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/image-20220716104304033.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>不得不说，gRPC 的通信层的设计还是非常优秀的，<a href=\"https://dubbogo.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Dubbo-go 3.0</a> 的通信层改进主要借鉴了 gRPC。</p>\n<p>不过，gRPC 的设计导致其几乎没有服务治理能力。如果你想要解决这个问题的话，就需要依赖其他组件比如腾讯的 PolarisMesh（北极星）了。</p>\n<ul>\n<li>GitHub：<a href=\"https://github.com/grpc/grpc\" title=\"https://github.com/grpc/grpc\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/grpc/grpc</a></li>\n<li>官网：<a href=\"https://grpc.io/\" title=\"https://grpc.io/\" target=\"_blank\" rel=\"noopener noreferrer\">https://grpc.io/</a></li>\n</ul>\n<h3>Thrift</h3>\n<p>Apache Thrift 是 Facebook 开源的跨语言的 RPC 通信框架，目前已经捐献给 Apache 基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于 thrift 研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p>\n<p><code>Thrift</code>支持多种不同的<strong>编程语言</strong>，包括<code>C++</code>、<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>等（相比于 gRPC 支持的语言更多 ）。</p>\n<ul>\n<li>官网：<a href=\"https://thrift.apache.org/\" title=\"https://thrift.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://thrift.apache.org/</a></li>\n<li>Thrift 简单介绍：<a href=\"https://www.jianshu.com/p/8f25d057a5a9\" title=\"https://www.jianshu.com/p/8f25d057a5a9\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/8f25d057a5a9</a></li>\n</ul>\n<h3>总结</h3>\n<p>gRPC 和 Thrift 虽然支持跨语言的 RPC 调用，但是它们只提供了最基本的 RPC 框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。</p>\n<p>Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。而且，Dubbo 在国内有很多成功的案例比如当当网、滴滴等等，是一款经得起生产考验的成熟稳定的 RPC 框架。最重要的是你还能找到非常多的 Dubbo 参考资料，学习成本相对也较低。</p>\n<p>下图展示了 Dubbo 的生态系统。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/eee98ff2-8e06-4628-a42b-d30ffcd2831e.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Dubbo 也是 Spring Cloud Alibaba 里面的一个组件。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/0d195dae-72bc-4956-8451-3eaf6dd11cbd.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但是，Dubbo 和 Motan 主要是给 Java 语言使用。虽然，Dubbo 和 Motan 目前也能兼容部分语言，但是不太推荐。如果需要跨多种语言调用的话，可以考虑使用 gRPC。</p>\n<p>综上，如果是 Java 后端技术栈，并且你在纠结选择哪一种 RPC 框架的话，我推荐你考虑一下 Dubbo。</p>\n<h2>如何设计并实现一个 RPC 框架？</h2>\n<p><strong>《手写 RPC 框架》</strong> 是我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>的一个内部小册，我写了 12 篇文章来讲解如何从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。</p>\n<p>麻雀虽小五脏俱全，项目代码注释详细，结构清晰，并且集成了 Check Style 规范代码结构，非常适合阅读和学习。</p>\n<p><strong>内容概览</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/image-20220308100605485.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>既然有了 HTTP 协议，为什么还要有 RPC ？</h2>\n<p>关于这个问题的详细答案，请看这篇文章：<a href=\"/Note-Book/distributed-system/rpc/http&amp;rpc.html\" target=\"_blank\">有了 HTTP 协议，为什么还要有 RPC ？</a> 。</p>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Disruptor常见问题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/message-queue/disruptor-questions.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/message-queue/disruptor-questions.html",
      "summary": "Disruptor 是一个相对冷门一些的知识点，不过，如果你的项目经历中用到了 Disruptor 的话，那面试中就很可能会被问到。 一位球友之前投稿的面经（社招）中就涉及一些 Disruptor 的问题，文章传送门：圆梦！顺利拿到字节、淘宝、拼多多等大厂 offer！ 。 这篇文章可以看作是对 Disruptor 做的一个简单总结，每个问题都不会扯太...",
      "content_html": "<p>Disruptor 是一个相对冷门一些的知识点，不过，如果你的项目经历中用到了 Disruptor 的话，那面试中就很可能会被问到。</p>\n<p>一位球友之前投稿的面经（社招）中就涉及一些 Disruptor 的问题，文章传送门：<a href=\"https://mp.weixin.qq.com/s/C5QMjwEb6pzXACqZsyqC4A\" target=\"_blank\" rel=\"noopener noreferrer\">圆梦！顺利拿到字节、淘宝、拼多多等大厂 offer！</a> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-interview-questions.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这篇文章可以看作是对 Disruptor 做的一个简单总结，每个问题都不会扯太深入，主要针对面试或者速览 Disruptor。</p>\n<h2>Disruptor 是什么？</h2>\n<p>Disruptor 是一个开源的高性能内存队列，诞生初衷是为了解决内存队列的性能和内存安全问题，由英国外汇交易公司 LMAX 开发。</p>\n<p>根据 Disruptor 官方介绍，基于 Disruptor 开发的系统 LMAX（新的零售金融交易平台），单线程就能支撑每秒 600 万订单。Martin Fowler 在 2011 年写的一篇文章 <a href=\"https://martinfowler.com/articles/lmax.html\" target=\"_blank\" rel=\"noopener noreferrer\">The LMAX Architecture</a> 中专门介绍过这个 LMAX 系统的架构，感兴趣的可以看看这篇文章。。</p>\n<p>LMAX 公司 2010 年在 QCon 演讲后，Disruptor 获得了业界关注，并获得了 2011 年的 Oracle 官方的 Duke's Choice Awards(Duke 选择大奖)。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/640.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<blockquote>\n<p>“Duke 选择大奖”旨在表彰过去一年里全球个人或公司开发的、最具影响力的 Java 技术应用，由甲骨文公司主办。含金量非常高！</p>\n</blockquote>\n<p>我专门找到了 Oracle 官方当年颁布获得 Duke's Choice Awards 项目的那篇文章（文章地址：https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award） 。从文中可以看出，同年获得此大奖荣誉的还有大名鼎鼎的 Netty、JRebel 等项目。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/image-20211015152323898.png\" alt=\"2011 年的 Oracle 官方的 Duke's Choice Awards\" tabindex=\"0\"><figcaption>2011 年的 Oracle 官方的 Duke's Choice Awards</figcaption></figure>\n<p>Disruptor 提供的功能优点类似于 Kafka、RocketMQ 这类分布式队列，不过，其作为范围是 JVM(内存)。</p>\n<ul>\n<li>Github 地址：<a href=\"https://github.com/LMAX-Exchange/disruptor\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/LMAX-Exchange/disruptor</a></li>\n<li>官方教程： <a href=\"https://lmax-exchange.github.io/disruptor/user-guide/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://lmax-exchange.github.io/disruptor/user-guide/index.html</a></li>\n</ul>\n<p>关于如何在 Spring Boot 项目中使用 Disruptor，可以看这篇文章：<a href=\"https://mp.weixin.qq.com/s/0iG5brK3bYF0BgSjX4jRiA\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot + Disruptor 实战入门</a> 。</p>\n<h2>为什么要用 Disruptor？</h2>\n<p>Disruptor 主要解决了 JDK 内置线程安全队列的性能和内存安全问题。</p>\n<p><strong>JDK 中常见的线程安全的队列如下</strong>：</p>\n<p>| 队列名字                | 锁                      | 是否有界 |\n|</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-interview-questions.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "Kafka常见问题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/message-queue/kafka-questions-01.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/message-queue/kafka-questions-01.html",
      "summary": "Kafka 是什么？主要应用场景有哪些？ Kafka 是一个分布式流式处理平台。这到底是什么意思呢？ 流平台具有三个关键功能： 消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。 容错的持久方式存储记录消息流：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。 流式处理平台： 在消息发布的时候进...",
      "content_html": "<h3>Kafka 是什么？主要应用场景有哪些？</h3>\n<p>Kafka 是一个分布式流式处理平台。这到底是什么意思呢？</p>\n<p>流平台具有三个关键功能：</p>\n<ol>\n<li><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>\n<li><strong>容错的持久方式存储记录消息流</strong>：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li>\n<li><strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>\n</ol>\n<p>Kafka 主要有两大应用场景：</p>\n<ol>\n<li><strong>消息队列</strong>：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li>\n<li><strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流。</li>\n</ol>\n<h3>和其他消息队列相比,Kafka 的优势在哪里？</h3>\n<p>我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它跟 RocketMQ、RabbitMQ 对比。我觉得 Kafka 相比其他消息队列主要的优势如下：</p>\n<ol>\n<li><strong>极致的性能</strong>：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</li>\n<li><strong>生态系统兼容性无可匹敌</strong>：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li>\n</ol>\n<p>实际上在早期的时候 Kafka 并不是一个合格的消息队列，早期的 Kafka 在消息队列领域就像是一个衣衫褴褛的孩子一样，功能不完备并且有一些小问题比如丢失消息、不保证消息可靠性等等。当然，这也和 LinkedIn 最早开发 Kafka 用于处理海量的日志有很大关系，哈哈哈，人家本来最开始就不是为了作为消息队列滴，谁知道后面误打误撞在消息队列领域占据了一席之地。</p>\n<p>随着后续的发展，这些短板都被 Kafka 逐步修复完善。所以，<strong>Kafka 作为消息队列不可靠这个说法已经过时！</strong></p>\n<h3>队列模型了解吗？Kafka 的消息模型知道吗？</h3>\n<blockquote>\n<p>题外话：早期的 JMS 和 AMQP 属于消息服务领域权威组织所做的相关的标准，我在 <a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a>的 <a href=\"https://github.com/Snailclimb/JavaGuide#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E4%B8%AD%E9%97%B4%E4%BB%B6\" target=\"_blank\" rel=\"noopener noreferrer\">《消息队列其实很简单》</a>这篇文章中介绍过。但是，这些标准的进化跟不上消息队列的演进速度，这些标准实际上已经属于废弃状态。所以，可能存在的情况是：不同的消息队列都有自己的一套消息模型。</p>\n</blockquote>\n<h4>队列模型：早期的消息模型</h4>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/队列模型23.png\" alt=\"队列模型\" tabindex=\"0\"><figcaption>队列模型</figcaption></figure>\n<p><strong>使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</strong> 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>\n<p><strong>队列模型存在的问题：</strong></p>\n<p>假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。</p>\n<p>这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p>\n<h4>发布-订阅模型:Kafka 消息模型</h4>\n<p>发布-订阅模型主要是为了解决队列模型存在的问题。</p>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/发布订阅模型.png\" alt=\"发布订阅模型\" tabindex=\"0\"><figcaption>发布订阅模型</figcaption></figure>\n<p>发布订阅模型（Pub-Sub） 使用<strong>主题（Topic）</strong> 作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>\n<p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p>\n<p><strong>Kafka 采用的就是发布 - 订阅模型。</strong></p>\n<blockquote>\n<p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p>\n</blockquote>\n<h3>什么是 Producer、Consumer、Broker、Topic、Partition？</h3>\n<p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>，如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue20210507200944439.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p>\n<ol>\n<li><strong>Producer（生产者）</strong> : 产生消息的一方。</li>\n<li><strong>Consumer（消费者）</strong> : 消费消息的一方。</li>\n<li><strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li>\n</ol>\n<p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p>\n<ul>\n<li><strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li>\n<li><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。</li>\n</ul>\n<blockquote>\n<p>划重点：<strong>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。这样是不是更好理解一点？</strong></p>\n</blockquote>\n<h3>Kafka 的多副本机制了解吗？带来了什么好处？</h3>\n<p>还有一点我觉得比较重要的是 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>\n<blockquote>\n<p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p>\n</blockquote>\n<p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong></p>\n<ol>\n<li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li>\n<li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li>\n</ol>\n<h3>Zookeeper 在 Kafka 中的作用知道吗？</h3>\n<blockquote>\n<p><strong>要想搞懂 zookeeper 在 Kafka 中的作用 一定要自己搭建一个 Kafka 环境然后自己进 zookeeper 去看一下有哪些文件夹和 Kafka 有关，每个节点又保存了什么信息。</strong> 一定不要光看不实践，这样学来的也终会忘记！这部分内容参考和借鉴了这篇文章：https://www.jianshu.com/p/a036405f989c 。</p>\n</blockquote>\n<p>下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。</p>\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zookeeper-kafka.jpg\" style=\"zoom:50%;\">\n<p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p>\n<p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p>\n<ol>\n<li><strong>Broker 注册</strong>：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li>\n<li><strong>Topic 注册</strong>：在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li>\n<li><strong>负载均衡</strong>：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li>\n<li>......</li>\n</ol>\n<h3>Kafka 如何保证消息的消费顺序？</h3>\n<p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p>\n<ol>\n<li>更改用户会员等级。</li>\n<li>根据会员等级计算订单价格。</li>\n</ol>\n<p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>\n<p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartionsLayout.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p>\n<blockquote>\n<p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p>\n</blockquote>\n<p>所以，我们就有一种很简单的保证消息消费顺序的方法：<strong>1 个 Topic 只对应一个 Partition</strong>。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p>\n<p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</p>\n<p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>\n<ol>\n<li>1 个 Topic 只对应一个 Partition。</li>\n<li>（推荐）发送消息的时候指定 key/Partition。</li>\n</ol>\n<p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的，</p>\n<h3>Kafka 如何保证消息不丢失</h3>\n<h4>生产者丢失消息的情况</h4>\n<p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>\n<p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p>\n<blockquote>\n<p><strong>详细代码见我的这篇文章：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486269&amp;idx=2&amp;sn=ec00417ad641dd8c3d145d74cafa09ce&amp;chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&amp;token=1633957262&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka 系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?</a></strong></p>\n</blockquote>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">SendResult</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">&gt;</span></span> sendResult <span class=\"token operator\">=</span> kafkaTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>topic<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getRecordMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者成功发送消息到\"</span> <span class=\"token operator\">+</span> sendResult<span class=\"token punctuation\">.</span><span class=\"token function\">getProducerRecord</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">topic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"-&gt; \"</span> <span class=\"token operator\">+</span> sendRe\n              sult<span class=\"token punctuation\">.</span><span class=\"token function\">getProducerRecord</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code>        <span class=\"token class-name\">ListenableFuture</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SendResult</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> future <span class=\"token operator\">=</span> kafkaTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>topic<span class=\"token punctuation\">,</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        future<span class=\"token punctuation\">.</span><span class=\"token function\">addCallback</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">-&gt;</span> logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者成功发送消息到topic:{} partition:{}的消息\"</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">getRecordMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">topic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">getRecordMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                ex <span class=\"token operator\">-&gt;</span> logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"生产者发送消失败，原因：{}\"</span><span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p>\n<p><strong>另外这里推荐为 Producer 的<code>retries </code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了</strong></p>\n<h4>消费者丢失消息的情况</h4>\n<p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/kafka-offset.jpg\" alt=\"kafka offset\" tabindex=\"0\"><figcaption>kafka offset</figcaption></figure>\n<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>\n<p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>\n<h4>Kafka 弄丢了消息</h4>\n<p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>\n<p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p>\n<p><strong>设置 acks = all</strong></p>\n<p>解决办法就是我们设置 <strong>acks = all</strong>。acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p>\n<p>acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 <strong>acks = all</strong> 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应. 这种模式是最高级别的，也是最安全的，可以确保不止一个 Broker 接收到了消息. 该模式的延迟会很高.</p>\n<p><strong>设置 replication.factor &gt;= 3</strong></p>\n<p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;= 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>\n<p><strong>设置 min.insync.replicas &gt; 1</strong></p>\n<p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>\n<p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor = min.insync.replicas + 1</strong>。</p>\n<p><strong>设置 unclean.leader.election.enable = false</strong></p>\n<blockquote>\n<p><strong>Kafka 0.11.0.0 版本开始 unclean.leader.election.enable 参数的默认值由原来的 true 改为 false</strong></p>\n</blockquote>\n<p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable = false</strong> 的话，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p>\n<h3>Kafka 如何保证消息不重复消费</h3>\n<p><strong>kafka 出现消息重复消费的原因：</strong></p>\n<ul>\n<li>服务端侧已经消费的数据没有成功提交 offset（根本原因）。</li>\n<li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li>\n</ul>\n<p><strong>解决方案：</strong></p>\n<ul>\n<li>消费消息服务做幂等校验，比如 Redis 的 set、MySQL 的主键等天然的幂等功能。这种方法最有效。</li>\n<li>将 <strong><code>enable.auto.commit</code></strong> 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：<strong>什么时候提交 offset 合适？</strong>\n<ul>\n<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>\n<li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>\n</ul>\n</li>\n</ul>\n<h3>Reference</h3>\n<ul>\n<li>Kafka 官方文档：https://kafka.apache.org/documentation/</li>\n<li>极客时间—《Kafka 核心技术与实战》第 11 节：无消息丢失配置怎么实现？</li>\n</ul>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/队列模型23.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "消息队列基础知识总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/message-queue/message-queue.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/message-queue/message-queue.html",
      "summary": "提示 这篇文章中的消息队列主要指的是分布式消息队列。 “RabbitMQ？”“Kafka？”“RocketMQ？”...在日常学习与开发过程中，我们常常听到消息队列这个关键词。我也在我的多篇文章中提到了这个概念。可能你是熟练使用消息队列的老手，又或者你是不懂消息队列的新手，不论你了不了解消息队列，本文都将带你搞懂消息队列的一些基本理论。 如果你是老手，...",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>这篇文章中的消息队列主要指的是分布式消息队列。</p>\n</div>\n<p>“RabbitMQ？”“Kafka？”“RocketMQ？”...在日常学习与开发过程中，我们常常听到消息队列这个关键词。我也在我的多篇文章中提到了这个概念。可能你是熟练使用消息队列的老手，又或者你是不懂消息队列的新手，不论你了不了解消息队列，本文都将带你搞懂消息队列的一些基本理论。</p>\n<p>如果你是老手，你可能从本文学到你之前不曾注意的一些关于消息队列的重要概念，如果你是新手，相信本文将是你打开消息队列大门的一板砖。</p>\n<h2>什么是消息队列？</h2>\n<p>我们可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p>\n<figure><img src=\"https://oss.javaguide.cn/消息队列/message-queue-small.png\" alt=\"Message queue\" tabindex=\"0\"><figcaption>Message queue</figcaption></figure>\n<p>参与消息传递的双方称为 <strong>生产者</strong> 和 <strong>消费者</strong> ，生产者负责发送消息，消费者负责处理消息。</p>\n<figure><figcaption>发布/订阅（Pub/Sub）模型</figcaption></figure>\n<p>我们知道操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，更多指的是各个服务以及系统内部各个组件/模块之前的通信，属于一种 <strong>中间件</strong> 。</p>\n<p>维基百科是这样介绍中间件的：</p>\n<blockquote>\n<p>中间件（英语：Middleware），又译中间件、中介层，是一类提供系统软件和应用软件之间连接、便于软件各部件之间的沟通的软件，应用软件可以借助中间件在不同的技术架构之间共享信息与资源。中间件位于客户机服务器的操作系统之上，管理着计算资源和网络通信。</p>\n</blockquote>\n<p>简单来说：<strong>中间件就是一类为应用软件服务的软件，应用软件是为用户服务的，用户不会接触或者使用到中间件。</strong></p>\n<p>除了消息队列之外，常见的中间件还有 RPC 框架、分布式组件、HTTP 服务器、任务调度框架、配置中心、数据库层的分库分表工具和数据迁移工具等等。</p>\n<p>关于中间件比较详细的介绍可以参考阿里巴巴淘系技术的一篇回答：https://www.zhihu.com/question/19730582/answer/1663627873 。</p>\n<p>随着分布式和微服务系统的发展，消息队列在系统设计中有了更大的发挥空间，使用消息队列可以降低系统耦合性、实现任务异步、有效地进行流量削峰，是分布式和微服务系统中重要的组件之一。</p>\n<h2>消息队列有什么用？</h2>\n<p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p>\n<ol>\n<li><strong>通过异步处理提高系统性能（减少响应所需时间）</strong></li>\n<li><strong>削峰/限流</strong></li>\n<li><strong>降低系统耦合性。</strong></li>\n</ol>\n<p>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。</p>\n<h3>通过异步处理提高系统性能（减少响应所需时间）</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/Asynchronous-message-queue.png\" alt=\"通过异步处理提高系统性能\" tabindex=\"0\"><figcaption>通过异步处理提高系统性能</figcaption></figure>\n<p>将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费。</p>\n<p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>\n<h3>削峰/限流</h3>\n<p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</strong></p>\n<p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/削峰-消息队列.png\" alt=\"削峰\" tabindex=\"0\"><figcaption>削峰</figcaption></figure>\n<h3>降低系统耦合性</h3>\n<p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/消息队列-解耦.png\" alt=\"解耦\" tabindex=\"0\"><figcaption>解耦</figcaption></figure>\n<p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p>\n<p><strong>消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>\n<p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>\n<p>另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p>\n<p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了另外 5 种消息模型。</p>\n<h3>实现分布式事务</h3>\n<p>我们知道分布式事务的解决方案之一就是 MQ 事务。</p>\n<p>RocketMQ、 Kafka、Pulsar、QMQ 都提供了事务相关的功能。事务允许事件流应用将消费，处理，生产消息整个过程定义为一个原子操作。</p>\n<p>详细介绍可以查看 <a href=\"https://javaguide.cn/distributed-system/distributed-transaction.html\" target=\"_blank\" rel=\"noopener noreferrer\">分布式事务详解(付费)</a> 这篇文章。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/07b338324a7d8894b8aef4b659b76d92.png\" alt=\"分布式事务详解 - MQ事务\" tabindex=\"0\"><figcaption>分布式事务详解 - MQ事务</figcaption></figure>\n<h2>使用消息队列会带来哪些问题？</h2>\n<ul>\n<li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li>\n<li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>\n<li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li>\n</ul>\n<h2>JMS 和 AMQP</h2>\n<h3>JMS 是什么？</h3>\n<p>JMS（JAVA Message Service,java 消息服务）是 Java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。<strong>JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>\n<p>JMS 定义了五种不同的消息正文格式以及调用的消息类型，允许你发送并接收以一些不同形式的数据：</p>\n<ul>\n<li><code>StreamMessage：Java</code> 原始值的数据流</li>\n<li><code>MapMessage</code>：一套名称-值对</li>\n<li><code>TextMessage</code>：一个字符串对象</li>\n<li><code>ObjectMessage</code>：一个序列化的 Java 对象</li>\n<li><code>BytesMessage</code>：一个字节的数据流</li>\n</ul>\n<p><strong>ActiveMQ（已被淘汰） 就是基于 JMS 规范实现的。</strong></p>\n<h3>JMS 两种消息模型</h3>\n<h4>点到点（P2P）模型</h4>\n<figure><figcaption>队列模型</figcaption></figure>\n<p>使用<strong>队列（Queue）<strong>作为消息通信载体；满足</strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>\n<h4>发布/订阅（Pub/Sub）模型</h4>\n<figure><figcaption>发布/订阅（Pub/Sub）模型</figcaption></figure>\n<p>发布订阅模型（Pub/Sub） 使用<strong>主题（Topic）<strong>作为消息通信载体，类似于</strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>\n<h3>AMQP 是什么？</h3>\n<p>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p>\n<p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p>\n<h3>JMS vs AMQP</h3>\n<p>|   对比方向   | JMS                                     | AMQP                                                                                                                                                                                               |\n| :</p>\n",
      "image": "https://oss.javaguide.cn/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/message-queue-small.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "RabbitMQ常见问题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/message-queue/rabbitmq-questions.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/message-queue/rabbitmq-questions.html",
      "summary": "本篇文章由 JavaGuide 收集自网络，原出处不明。 RabbitMQ 是什么？ RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、...",
      "content_html": "<blockquote>\n<p>本篇文章由 JavaGuide 收集自网络，原出处不明。</p>\n</blockquote>\n<h2>RabbitMQ 是什么？</h2>\n<p>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>\n<p>RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</p>\n<p>PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。</p>\n<h2>RabbitMQ 特点?</h2>\n<ul>\n<li><strong>可靠性</strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</li>\n<li><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</li>\n<li><strong>扩展性</strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</li>\n<li><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</li>\n<li><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</li>\n<li><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</li>\n<li><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</li>\n<li><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</li>\n</ul>\n<h2>RabbitMQ 核心概念？</h2>\n<p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ 就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p>\n<p>RabbitMQ 的整体模型架构如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/96388546.jpg\" alt=\"图1-RabbitMQ 的整体模型架构\" tabindex=\"0\"><figcaption>图1-RabbitMQ 的整体模型架构</figcaption></figure>\n<p>下面我会一一介绍上图中的一些概念。</p>\n<h3>Producer(生产者) 和 Consumer(消费者)</h3>\n<ul>\n<li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li>\n<li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li>\n</ul>\n<p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p>\n<h3>Exchange(交换器)</h3>\n<p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。</p>\n<p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将 RabbitMQ 中的交换器看作一个简单的实体。</p>\n<p><strong>RabbitMQ 的 Exchange(交换器) 有 4 种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)</strong>，<strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong>，不同类型的 Exchange 转发消息的策略有所区别。这个会在介绍 <strong>Exchange Types(交换器类型)</strong> 的时候介绍到。</p>\n<p>Exchange(交换器) 示意图如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/24007899.jpg\" alt=\"Exchange(交换器) 示意图\" tabindex=\"0\"><figcaption>Exchange(交换器) 示意图</figcaption></figure>\n<p>生产者将消息发给交换器的时候，一般会指定一个 <strong>RoutingKey(路由键)</strong>，用来指定这个消息的路由规则，而这个 <strong>RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</p>\n<p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p>\n<p>Binding(绑定) 示意图：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/70553134.jpg\" alt=\"Binding(绑定) 示意图\" tabindex=\"0\"><figcaption>Binding(绑定) 示意图</figcaption></figure>\n<p>生产者将消息发送给交换器时，需要一个 RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如 fanout 类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p>\n<h3>Queue(消息队列)</h3>\n<p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>\n<p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。Kafka 将消息存储在 <strong>topic（主题）</strong> 这个逻辑层面，而相对应的队列逻辑只是 topic 实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p>\n<p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。</p>\n<p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p>\n<h3>Broker（消息中间件的服务节点）</h3>\n<p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者 RabbitMQ 服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p>\n<p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从 Broker 中消费数据的整个流程。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/67952922.jpg\" alt=\"消息队列的运转过程\" tabindex=\"0\"><figcaption>消息队列的运转过程</figcaption></figure>\n<p>这样图 1 中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 <strong>Exchange Types(交换器类型)</strong> 。</p>\n<h3>Exchange Types(交换器类型)</h3>\n<p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP 规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p>\n<p><strong>1、fanout</strong></p>\n<p>fanout 类型的 Exchange 路由规则非常简单，它会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</p>\n<p><strong>2、direct</strong></p>\n<p>direct 类型的 Exchange 路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/37008021.jpg\" alt=\"direct 类型交换器\" tabindex=\"0\"><figcaption>direct 类型交换器</figcaption></figure>\n<p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为\"Info”或者\"debug”，消息只会路由到 Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p>\n<p>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p>\n<p><strong>3、topic</strong></p>\n<p>前面讲到 direct 类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic 类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p>\n<ul>\n<li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li>\n<li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li>\n<li>BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/73843.jpg\" alt=\"topic 类型交换器\" tabindex=\"0\"><figcaption>topic 类型交换器</figcaption></figure>\n<p>以上图为例：</p>\n<ul>\n<li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queue1 和 Queue2;</li>\n<li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li>\n<li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li>\n<li>路由键为 “java.rabbitmq.demo” 的消息只会路由到 Queue1 中；</li>\n<li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li>\n</ul>\n<p><strong>4、headers(不推荐)</strong></p>\n<p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ 会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p>\n<h2>AMQP 是什么?</h2>\n<p>RabbitMQ 就是 AMQP 协议的 <code>Erlang</code> 的实现(当然 RabbitMQ 还支持 <code>STOMP2</code>、 <code>MQTT3</code> 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。</p>\n<p>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</p>\n<p><strong>AMQP 协议的三层</strong>：</p>\n<ul>\n<li><strong>Module Layer</strong>:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</li>\n<li><strong>Session Layer</strong>:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</li>\n<li><strong>TransportLayer</strong>:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</li>\n</ul>\n<p><strong>AMQP 模型的三大组件</strong>：</p>\n<ul>\n<li><strong>交换器 (Exchange)</strong>：消息代理服务器中用于把消息路由到队列的组件。</li>\n<li><strong>队列 (Queue)</strong>：用来存储消息的数据结构，位于硬盘或内存中。</li>\n<li><strong>绑定 (Binding)</strong>：一套规则，告知交换器消息应该将消息投递给哪个队列。</li>\n</ul>\n<h2><strong>说说生产者 Producer 和消费者 Consumer?</strong></h2>\n<p><strong>生产者</strong> :</p>\n<ul>\n<li>消息生产者，就是投递消息的一方。</li>\n<li>消息一般包含两个部分：消息体（<code>payload</code>)和标签(<code>Label</code>)。</li>\n</ul>\n<p><strong>消费者</strong>：</p>\n<ul>\n<li>消费消息，也就是接收消息的一方。</li>\n<li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。</li>\n</ul>\n<h2>说说 Broker 服务节点、Queue 队列、Exchange 交换器？</h2>\n<ul>\n<li><strong>Broker</strong>：可以看做 RabbitMQ 的服务节点。一般请下一个 Broker 可以看做一个 RabbitMQ 服务器。</li>\n<li><strong>Queue</strong> :RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</li>\n<li><strong>Exchange</strong> : 生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li>\n</ul>\n<h2>什么是死信队列？如何导致的？</h2>\n<p>DLX，全称为 <code>Dead-Letter-Exchange</code>，死信交换器，死信邮箱。当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</p>\n<p><strong>导致的死信的几种原因</strong>：</p>\n<ul>\n<li>消息被拒（<code>Basic.Reject /Basic.Nack</code>) 且 <code>requeue = false</code>。</li>\n<li>消息 TTL 过期。</li>\n<li>队列满了，无法再添加。</li>\n</ul>\n<h2>什么是延迟队列？RabbitMQ 怎么实现延迟队列？</h2>\n<p>延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p>\n<p>RabbitMQ 本身是没有延迟队列的，要实现延迟消息，一般有两种方式：</p>\n<ol>\n<li>通过 RabbitMQ 本身队列的特性来实现，需要使用 RabbitMQ 的死信交换机（Exchange）和消息的存活时间 TTL（Time To Live）。</li>\n<li>在 RabbitMQ 3.5.7 及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖 Erlang/OPT 18.0 及以上。</li>\n</ol>\n<p>也就是说，AMQP 协议以及 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过 TTL 和 DLX 模拟出延迟队列的功能。</p>\n<h2>什么是优先级队列？</h2>\n<p>RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。</p>\n<p>可以通过<code>x-max-priority</code>参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</p>\n<h2>RabbitMQ 有哪些工作模式？</h2>\n<ul>\n<li>简单模式</li>\n<li>work 工作模式</li>\n<li>pub/sub 发布订阅模式</li>\n<li>Routing 路由模式</li>\n<li>Topic 主题模式</li>\n</ul>\n<h2>RabbitMQ 消息怎么传输？</h2>\n<p>由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 RabbitMQ 使用信道的方式来传输数据。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。</p>\n<h2><strong>如何保证消息的可靠性？</strong></h2>\n<p>消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</p>\n<ul>\n<li>生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</li>\n<li>RabbitMQ 自身：持久化、集群、普通模式、镜像模式。</li>\n<li>RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。</li>\n</ul>\n<h2>如何保证 RabbitMQ 消息的顺序性？</h2>\n<ul>\n<li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；</li>\n<li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</li>\n</ul>\n<h2>如何保证 RabbitMQ 高可用的？</h2>\n<p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p>\n<p><strong>单机模式</strong></p>\n<p>Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式。</p>\n<p><strong>普通集群模式</strong></p>\n<p>意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。</p>\n<p>你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>\n<p><strong>镜像集群模式</strong></p>\n<p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>\n<p>这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p>\n<h2>如何解决消息队列的延时以及过期失效问题？</h2>\n<p>RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/rabbitmq/96388546.jpg",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "RocketMQ常见问题总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/message-queue/rocketmq-questions.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-performance/message-queue/rocketmq-questions.html",
      "summary": "本文由 FrancisQ 投稿！ 消息队列扫盲 消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？ 所以问题并不是消息队列是什么，而是 消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？ 消息队列为什么会出现？ 消息队列算是作为后端程序员的一个必备技能吧，因为分布式应用...",
      "content_html": "<blockquote>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485969&amp;idx=1&amp;sn=6bd53abde30d42a778d5a35ec104428c&amp;chksm=cea245daf9d5cccce631f93115f0c2c4a7634e55f5bef9009fd03f5a0ffa55b745b5ef4f0530&amp;token=294077121&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">本文由 FrancisQ 投稿！</a></p>\n</blockquote>\n<h2>消息队列扫盲</h2>\n<p>消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？</p>\n<p>所以问题并不是消息队列是什么，而是 <strong>消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？</strong></p>\n<h3>消息队列为什么会出现？</h3>\n<p>消息队列算是作为后端程序员的一个必备技能吧，因为<strong>分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。</p>\n<h3>消息队列能用来干什么？</h3>\n<h4>异步</h4>\n<p>你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？</p>\n<p>很好 👍，你又提出了一个概念，<strong>同步通信</strong>。就比如现在业界使用比较多的 <code>Dubbo</code> 就是一个适用于各个系统之间同步通信的 <code>RPC</code> 框架。</p>\n<p>我来举个 🌰 吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef37fee7e09230.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。</p>\n<p>当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短信系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 <strong>头重脚轻</strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef380429cf373e.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这样整个系统的调用链又变长了，整个时间就变成了 550ms。</p>\n<p>当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。</p>\n<p>我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦 😋😋😋” 咦~~~ 为了多吃点，真恶心。</p>\n<p>然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。</p>\n<p>最终我们从大妈手中接过饭菜然后去寻找座位了...</p>\n<p>回想一下，我们在给大妈发送需要的信息之后我们是 <strong>同步等待大妈给我配好饭菜</strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/006APoFYly1fvd9cwjlfrj30as0b03ym.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 <strong>(传达一个消息)</strong> ，然后我们就可以在饭桌上安心的玩手机了 <strong>(干自己其他事情)</strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以干其他事情了，这是一个 <strong>异步</strong> 的概念。</p>\n<p>所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38124f55eaea.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms = 160ms。</p>\n<blockquote>\n<p>但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。</p>\n</blockquote>\n<h4>解耦</h4>\n<p>回到最初同步调用的过程，我们写个伪代码简单概括一下。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef381a505d3e1f.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef381c4e1b1ac7.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef381f273a66bd.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这样改来改去是不是很麻烦，那么 <strong>此时我们就用一个消息队列在中间进行解耦</strong> 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 <code>result</code> ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 <strong>“广播消息”</strong> 来实现。</p>\n<p>我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 <strong>订阅</strong> 特定的主题。比如我们这里的主题就可以叫做 <code>订票</code> ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 <strong>生产消息到指定主题中</strong> ，而 <strong>消费者只需要关注从指定主题中拉取消息</strong> 就行了。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef382674b66892.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<blockquote>\n<p>如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p>\n</blockquote>\n<h4>削峰</h4>\n<p>我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef382a9756bb1c.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 <strong>直接崩溃</strong> 了？</p>\n<p>短信业务又不是我们的主业务，我们能不能 <strong>折中处理</strong> 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 <strong>尽自己所能地去消息队列中取消息和消费消息</strong> ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。</p>\n<p>留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？</p>\n<h4>消息队列能带来什么好处？</h4>\n<p>其实上面我已经说了。<strong>异步、解耦、削峰。</strong> 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。</p>\n<h4>消息队列会带来副作用吗？</h4>\n<p>没有哪一门技术是“银弹”，消息队列也有它的副作用。</p>\n<p>比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 <strong>降低了系统的可用性</strong> ？</p>\n<p>那这样是不是要保证 HA(高可用)？是不是要搞集群？那么我 <strong>整个系统的复杂度是不是上升了</strong> ？</p>\n<p>抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。</p>\n<p>或者我消费端处理失败了，请求重发，这样也会产生重复的消息。</p>\n<p>对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？</p>\n<p>那么，又 <strong>如何解决重复消费消息的问题</strong> 呢？</p>\n<p>如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个 id 为 1 的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？</p>\n<p>那么，又 <strong>如何解决消息的顺序消费问题</strong> 呢？</p>\n<p>就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 <code>Spring</code> 的话我们在上面伪代码中加入 <code>@Transactional</code> 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。</p>\n<p>那么，又如何 <strong>解决分布式事务问题</strong> 呢？</p>\n<p>我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？</p>\n<p>那么，又如何 <strong>解决消息堆积的问题</strong> 呢？</p>\n<p>可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊 😵？</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef382d709abc9d.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>别急，办法总是有的。</p>\n<h2>RocketMQ 是什么？</h2>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef383014430799.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 <code>RocketMQ</code> ，还让不让人活了？！🤬</p>\n<p>别急别急，话说你现在清楚 <code>MQ</code> 的构造吗，我还没讲呢，我们先搞明白 <code>MQ</code> 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。</p>\n<p><code>RocketMQ</code> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code>Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在 2016 年底贡献给 <code>Apache</code>，成为了 <code>Apache</code> 的一个顶级项目。 在阿里内部，<code>RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code>RocketMQ</code> 流转。</p>\n<p>废话不多说，想要了解 <code>RocketMQ</code> 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 <code>RocketMQ</code> 很快、很牛、而且经历过双十一的实践就行了！</p>\n<h2>队列模型和主题模型是什么？</h2>\n<p>在谈 <code>RocketMQ</code> 的技术架构之前，我们先来了解一下两个名词概念——<strong>队列模型</strong> 和 <strong>主题模型</strong> 。</p>\n<p>首先我问一个问题，消息队列为什么要叫消息队列？</p>\n<p>你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？</p>\n<p>的确，早期的消息中间件是通过 <strong>队列</strong> 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。</p>\n<p>但是，如今例如 <code>RocketMQ</code>、<code>Kafka</code> 这些优秀的消息中间件不仅仅是通过一个 <strong>队列</strong> 来实现消息存储的。</p>\n<h3>队列模型</h3>\n<p>就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3834ae653469.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在一开始我跟你提到了一个 <strong>“广播”</strong> 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。</p>\n<p>当然你可以让 <code>Producer</code> 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 <strong>解耦</strong> 这一原则。</p>\n<h3>主题模型</h3>\n<p>那么有没有好的方法去解决这一个问题呢？有，那就是 <strong>主题模型</strong> 或者可以称为 <strong>发布订阅模型</strong> 。</p>\n<blockquote>\n<p>感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。</p>\n</blockquote>\n<p>在主题模型中，消息的生产者称为 <strong>发布者(Publisher)</strong> ，消息的消费者称为 <strong>订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong>主题(Topic)</strong> 。</p>\n<p>其中，发布者将消息发送到指定主题中，订阅者需要 <strong>提前订阅主题</strong> 才能接受特定主题的消息。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3837887d9a54sds.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>RocketMQ 中的消息模型</h3>\n<p><code>RocketMQ</code> 中的消息模型就是按照 <strong>主题模型</strong> 所实现的。你可能会好奇这个 <strong>主题</strong> 到底是怎么实现的呢？你上面也没有讲到呀！</p>\n<p>其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code>Kafka</code> 中的 <strong>分区</strong> ，<code>RocketMQ</code> 中的 <strong>队列</strong> ，<code>RabbitMQ</code> 中的 <code>Exchange</code> 。我们可以理解为 <strong>主题模型/发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p>\n<p>所以，<code>RocketMQ</code> 中的 <strong>主题模型</strong> 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef383d3e8c9788.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>我们可以看到在整个图中有 <code>Producer Group</code>、<code>Topic</code>、<code>Consumer Group</code> 三个角色，我来分别介绍一下他们。</p>\n<ul>\n<li><code>Producer Group</code> 生产者组：代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 <code>Producer Group</code> 生产者组，它们一般生产相同的消息。</li>\n<li><code>Consumer Group</code> 消费者组：代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 <code>Consumer Group</code> 消费者组，它们一般消费相同的消息。</li>\n<li><code>Topic</code> 主题：代表一类消息，比如订单消息，物流消息等等。</li>\n</ul>\n<p>你可以看到图中生产者组中的生产者会向主题发送消息，而 <strong>主题中存在多个队列</strong>，生产者每次生产消息之后是指定主题中的某个队列发送消息的。</p>\n<p>每个主题中都有多个队列(分布在不同的 <code>Broker</code>中，如果是集群的话，<code>Broker</code>又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 <code>topic</code> 的多个队列，<strong>一个队列只会被一个消费者消费</strong>。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 <code>Consumer1</code> 和 <code>Consumer2</code> 分别对应着两个队列，而 <code>Consumer3</code> 是没有队列对应的，所以一般来讲要控制 <strong>消费者组中的消费者个数和主题中队列个数相同</strong> 。</p>\n<p>当然也可以消费者个数小于队列个数，只不过不太建议。如下图。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3850c808d707.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</p>\n<p>因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong>消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3857fefaa079.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>可能你还有一个问题，<strong>为什么一个主题中需要维护多个队列</strong> ？</p>\n<p>答案是 <strong>提高并发能力</strong> 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong>发布订阅模式</strong> 。如下图。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38600cdb6d4b.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code>Consumer</code> 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。</p>\n<p>所以总结来说，<code>RocketMQ</code> 通过<strong>使用在一个 <code>Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong>主题模式/发布订阅模式</strong> 。</p>\n<h2>RocketMQ 的架构图</h2>\n<p>讲完了消息模型，我们理解起 <code>RocketMQ</code> 的技术架构起来就容易多了。</p>\n<p><code>RocketMQ</code> 技术架构中有四大角色 <code>NameServer</code>、<code>Broker</code>、<code>Producer</code>、<code>Consumer</code> 。我来向大家分别解释一下这四个角色是干啥的。</p>\n<ul>\n<li>\n<p><code>Broker</code>：主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code>Broker</code> ，消费者从 <code>Broker</code> 拉取消息并消费。</p>\n<p>这里，我还得普及一下关于 <code>Broker</code>、<code>Topic</code> 和 队列的关系。上面我讲解了 <code>Topic</code> 和队列的关系——一个 <code>Topic</code> 中存在多个队列，那么这个 <code>Topic</code> 和队列存放在哪呢？</p>\n<p><strong>一个 <code>Topic</code> 分布在多个 <code>Broker</code>上，一个 <code>Broker</code> 可以配置多个 <code>Topic</code> ，它们是多对多的关系</strong>。</p>\n<p>如果某个 <code>Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong>尽量多分布在不同 <code>Broker</code> 上，以减轻某个 <code>Broker</code> 的压力</strong> 。</p>\n<p><code>Topic</code> 消息量都比较均匀的情况下，如果某个 <code>broker</code> 上的队列越多，则该 <code>broker</code> 压力越大。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38687488a5a4.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<blockquote>\n<p>所以说我们需要配置多个 Broker。</p>\n</blockquote>\n</li>\n<li>\n<p><code>NameServer</code>：不知道你们有没有接触过 <code>ZooKeeper</code> 和 <code>Spring Cloud</code> 中的 <code>Eureka</code> ，它其实也是一个 <strong>注册中心</strong> ，主要提供两个功能：<strong>Broker 管理</strong> 和 <strong>路由信息管理</strong> 。说白了就是 <code>Broker</code> 会将自己的信息注册到 <code>NameServer</code> 中，此时 <code>NameServer</code> 就存放了很多 <code>Broker</code> 的信息(Broker 的路由表)，消费者和生产者就从 <code>NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code>Broker</code> 进行通信(生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息)。</p>\n</li>\n<li>\n<p><code>Producer</code>：消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p>\n</li>\n<li>\n<p><code>Consumer</code>：消息消费的角色，支持分布式集群方式部署。支持以 push 推，pull 拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p>\n</li>\n</ul>\n<p>听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef386c6d1e8bdb.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>嗯？你可能会发现一个问题，这老家伙 <code>NameServer</code> 干啥用的，这不多余吗？直接 <code>Producer</code>、<code>Consumer</code> 和 <code>Broker</code> 直接进行生产消息，消费消息不就好了么？</p>\n<p>但是，我们上文提到过 <code>Broker</code> 是需要保证高可用的，如果整个系统仅仅靠着一个 <code>Broker</code> 来维持的话，那么这个 <code>Broker</code> 的压力会不会很大？所以我们需要使用多个 <code>Broker</code> 来保证 <strong>负载均衡</strong> 。</p>\n<p>如果说，我们的消费者和生产者直接和多个 <code>Broker</code> 相连，那么当 <code>Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code>NameServer</code> 注册中心就是用来解决这个问题的。</p>\n<blockquote>\n<p>如果还不是很理解的话，可以去看我介绍 <code>Spring Cloud</code> 的那篇文章，其中介绍了 <code>Eureka</code> 注册中心。</p>\n</blockquote>\n<p>当然，<code>RocketMQ</code> 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef386fa3be1e53.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来 🤨。</p>\n<p>第一、我们的 <code>Broker</code> <strong>做了集群并且还进行了主从部署</strong> ，由于消息分布在各个 <code>Broker</code> 上，一旦某个 <code>Broker</code> 宕机，则该<code>Broker</code> 上的消息读写都会受到影响。所以 <code>Rocketmq</code> 提供了 <code>master/slave</code> 的结构，<code> salve</code> 定时从 <code>master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code>master</code> 宕机，<strong>则 <code>slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</p>\n<p>第二、为了保证 <code>HA</code> ，我们的 <code>NameServer</code> 也做了集群部署，但是请注意它是 <strong>去中心化</strong> 的。也就意味着它没有主节点，你可以很明显地看出 <code>NameServer</code> 的所有节点是没有进行 <code>Info Replicate</code> 的，在 <code>RocketMQ</code> 中是通过 <strong>单个 Broker 和所有 NameServer 保持长连接</strong> ，并且在每隔 30 秒 <code>Broker</code> 会向所有 <code>Nameserver</code> 发送心跳，心跳包含了自身的 <code>Topic</code> 配置信息，这个步骤就对应这上面的 <code>Routing Info</code> 。</p>\n<p>第三、在生产者需要向 <code>Broker</code> 发送消息的时候，<strong>需要先从 <code>NameServer</code> 获取关于 <code>Broker</code> 的路由信息</strong>，然后通过 <strong>轮询</strong> 的方法去向每个队列中生产数据以达到 <strong>负载均衡</strong> 的效果。</p>\n<p>第四、消费者通过 <code>NameServer</code> 获取所有 <code>Broker</code> 的路由信息后，向 <code>Broker</code> 发送 <code>Pull</code> 请求来获取消息数据。<code>Consumer</code> 可以以两种模式启动—— <strong>广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p>\n<h2>如何解决顺序消费和重复消费？</h2>\n<p>其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 <code>RocketMQ</code> ，而是应该每个消息中间件都需要去解决的。</p>\n<p>在上面我介绍 <code>RocketMQ</code> 的技术架构的时候我已经向你展示了 <strong>它是如何保证高可用的</strong> ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 <code>RocketMQ</code> 集群。</p>\n<blockquote>\n<p>其实 <code>Kafka</code> 的架构基本和 <code>RocketMQ</code> 类似，只是它注册中心使用了 <code>Zookeeper</code>、它的 <strong>分区</strong> 就相当于 <code>RocketMQ</code> 中的 <strong>队列</strong> 。还有一些小细节不同会在后面提到。</p>\n</blockquote>\n<h3>顺序消费</h3>\n<p>在上面的技术架构介绍中，我们已经知道了 <strong><code>RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p>\n<p>这又扯到两个概念——<strong>普通顺序</strong> 和 <strong>严格顺序</strong> 。</p>\n<p>所谓普通顺序是指 消费者通过 <strong>同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code>Broker</code> <strong>重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p>\n<p>所谓严格顺序是指 消费者收到的 <strong>所有消息</strong> 均是有顺序的。严格顺序消息 <strong>即使在异常情况下也会保证消息的顺序性</strong> 。</p>\n<p>但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code>Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 <code>binlog</code> 同步。</p>\n<p>一般而言，我们的 <code>MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p>\n<p>那么，我们现在使用了 <strong>普通顺序模式</strong> ，我们从上面学习知道了在 <code>Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 <strong>三个消息会被发送到不同队列</strong> ，因为在不同的队列此时就无法使用 <code>RocketMQ</code> 带来的队列有序特性来保证消息有序性了。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3874585e096e.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>那么，怎么解决呢？</p>\n<p>其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong>Hash 取模法</strong> 来保证同一个订单在同一个队列中就行了。</p>\n<h3>重复消费</h3>\n<p>emmm，就两个字—— <strong>幂等</strong> 。在编程中一个<em>幂等</em> 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如 Broker 意外重启等等)，这条回应没有发送成功。</p>\n<p>那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>\n<p>所以我们需要给我们的消费者实现 <strong>幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p>\n<p>那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong>写入 <code>Redis</code></strong> 来保证，因为 <code>Redis</code> 的 <code>key</code> 和 <code>value</code> 就是天然支持幂等的。当然还有使用 <strong>数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p>\n<p>不过最主要的还是需要 <strong>根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>\n<p>而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，<strong>在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将 HTTP 服务设计成幂等的，<strong>解决前端或者 APP 重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code>RPC</code> 框架自动重试导致的 <strong>重复调用问题</strong> 。</p>\n<h2>RocketMQ 如何实现分布式事务？</h2>\n<p>如何解释分布式事务呢？事务大家都知道吧？<strong>要么都执行要么都不执行</strong> 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现 A 系统下了订单，但是 B 系统增加积分失败或者 A 系统没有下订单，B 系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。</p>\n<p>那么，如何去解决这个问题呢？</p>\n<p>如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong>都不是完美的解决方案</strong>。</p>\n<p>在 <code>RocketMQ</code> 中使用的是 <strong>事务消息加上事务反查机制</strong> 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38798d7a987f.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在第一步发送的 half 消息 ，它的意思是 <strong>在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p>\n<blockquote>\n<p>那么，如何做到写入消息但是对用户不可见呢？RocketMQ 事务消息的做法是：如果消息是 half 消息，将备份原消息的主题与消息消费队列，然后 <strong>改变主题</strong> 为 RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费 half 类型的消息，<strong>然后 RocketMQ 会开启一个定时任务，从 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC 中拉取消息进行消费</strong>，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>\n</blockquote>\n<p>你可以试想一下，如果没有从第 5 步开始的 <strong>事务反查机制</strong> ，如果出现网路波动第 4 步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 <code>RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code>Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p>\n<p>你还需要注意的是，在 <code>MQ Server</code> 指向系统 B 的操作已经和系统 A 不相关了，也就是说在消息队列中的分布式事务是——<strong>本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong>最终一致性</strong>，因为整个过程是异步的，<strong>每个系统只要保证它自己那一部分的事务就行了</strong>。</p>\n<h2>如何解决消息堆积问题？</h2>\n<p>在上面我们提到了消息队列一个很重要的功能——<strong>削峰</strong> 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>\n<p>其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p>\n<p>我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong>限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong>是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p>\n<blockquote>\n<p>当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong>同时你还需要增加每个主题的队列数量</strong> 。</p>\n<p>别忘了在 <code>RocketMQ</code> 中，<strong>一个队列只会被一个消费者消费</strong> ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。</p>\n</blockquote>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef387d939ab66d.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2>什么事回溯消费？</h2>\n<p>回溯消费是指 <code>Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，在<code>RocketMQ</code> 中， <code>Broker</code> 在向<code>Consumer</code> 投递成功消息后，<strong>消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code>Consumer</code> 系统故障，恢复后需要重新消费 1 小时前的数据，那么 <code>Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code>RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p>\n<p>这是官方文档的解释，我直接照搬过来就当科普了 😁😁😁。</p>\n<h2>RocketMQ 的刷盘机制</h2>\n<p>上面我讲了那么多的 <code>RocketMQ</code> 的架构和设计原理，你有没有好奇</p>\n<p>在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？</strong></p>\n<p><strong>队列中的消息又是如何进行存储持久化的呢？</strong></p>\n<p>我在上文中提到的 <strong>同步刷盘</strong> 和 <strong>异步刷盘</strong> 又是什么呢？它们会给持久化带来什么样的影响呢？</p>\n<p>下面我将给你们一一解释。</p>\n<h3>同步刷盘和异步刷盘</h3>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef387fba311cda.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code>ACK</code> ，同步刷盘对 <code>MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong>性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>\n<p>而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong>降低了读写延迟</strong> ，提高了 <code>MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>\n<p>一般地，<strong>异步刷盘只有在 <code>Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code>Broker</code> 的参数 <code>FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>\n<h3>同步复制和异步复制</h3>\n<p>上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code>Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>\n<ul>\n<li>同步复制：也叫 “同步双写”，也就是说，<strong>只有消息同步双写到主从节点上时才返回写入成功</strong> 。</li>\n<li>异步复制：<strong>消息写入主节点之后就直接返回写入成功</strong> 。</li>\n</ul>\n<p>然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>\n<p>那么，<strong>异步复制会不会也像异步刷盘那样影响消息的可靠性呢？</strong></p>\n<p>答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 <strong>可用性</strong> 。为什么呢？其主要原因<strong>是 <code>RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。</p>\n<p>比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong>消费者可以自动切换到从节点进行消费</strong>(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>\n<p>在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong>一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code>Topic</code> 是分布在不同 <code>Broker</code> 中的。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38687488a5a4.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong>严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code>Topic</code> 下的队列来保证顺序性的。如果此时我们主节点 A 负责的是订单 A 的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点 A 的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>\n<p>而在 <code>RocketMQ</code> 中采用了 <code>Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong>至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>\n<blockquote>\n<p>也不是说 <code>Dledger</code> 是个完美的方案，至少在 <code>Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制半数以上节点的效率和直接异步复制还是有一定的差距的。</p>\n</blockquote>\n<h3>存储机制</h3>\n<p>还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。</p>\n<p>但是，在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？</strong> 还未解决，其实这里涉及到了 <code>RocketMQ</code> 是如何设计它的存储结构了。我首先想大家介绍 <code>RocketMQ</code> 消息存储架构中的三大角色——<code>CommitLog</code>、<code>ConsumeQueue</code> 和 <code>IndexFile</code> 。</p>\n<ul>\n<li><code>CommitLog</code>：<strong>消息主体以及元数据的存储主体</strong>，存储 <code>Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认 1G ，文件名长度为 20 位，左边补零，剩余为起始偏移量，比如 00000000000000000000 代表了第一个文件，起始偏移量为 0，文件大小为 1G=1073741824；当第一个文件写满了，第二个文件为 00000000001073741824，起始偏移量为 1073741824，以此类推。消息主要是<strong>顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li>\n<li><code>ConsumeQueue</code>：消息消费队列，<strong>引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code>RocketMQ</code> 是基于主题 <code>Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code>commitlog</code> 文件中根据 <code>Topic</code> 检索消息是非常低效的。<code>Consumer</code> 即可根据 <code>ConsumeQueue</code> 来查找待消费的消息。其中，<code>ConsumeQueue</code>（逻辑消费队列）<strong>作为消费消息的索引</strong>，保存了指定 <code>Topic</code> 下的队列消息在 <code>CommitLog</code> 中的<strong>起始物理偏移量 <code>offset</code> <strong>，消息大小 <code>size</code> 和消息 <code>Tag</code> 的 <code>HashCode</code> 值。</strong><code>consumequeue</code> 文件可以看成是基于 <code>topic</code> 的 <code>commitlog</code> 索引文件</strong>，故 <code>consumequeue</code> 文件夹的组织方式如下：topic/queue/file 三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 <code>consumequeue</code> 文件采取定长设计，每一个条目共 20 个字节，分别为 8 字节的 <code>commitlog</code> 物理偏移量、4 字节的消息长度、8 字节 tag <code>hashcode</code>，单个文件由 30W 个条目组成，可以像数组一样随机访问每一个条目，每个 <code>ConsumeQueue</code>文件大小约 5.72M；</li>\n<li><code>IndexFile</code>：<code>IndexFile</code>（索引文件）提供了一种可以通过 key 或时间区间来查询消息的方法。这里只做科普不做详细介绍。</li>\n</ul>\n<p>总结来说，整个消息存储的结构，最主要的就是 <code>CommitLoq</code> 和 <code>ConsumeQueue</code> 。而 <code>ConsumeQueue</code> 你可以大概理解为 <code>Topic</code> 中的队列。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3884c02acc72.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>RocketMQ</code> 采用的是 <strong>混合型的存储结构</strong> ，即为 <code>Broker</code> 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 <code>Kafka</code> 中会为每个 <code>Topic</code> 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，<code>RockeMQ</code> 是不分书的种类直接成批的塞上去的，而 <code>Kafka</code> 是将书本放入指定的分类区域的。</p>\n<p>而 <code>RocketMQ</code> 为什么要这么做呢？原因是 <strong>提高数据的写入效率</strong> ，不分 <code>Topic</code> 意味着我们有更大的几率获取 <strong>成批</strong> 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。</p>\n<p>所以，在 <code>RocketMQ</code> 中又使用了 <code>ConsumeQueue</code> 作为每个队列的索引文件来 <strong>提升读取消息的效率</strong>。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度 20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p>\n<p>讲到这里，你可能对 <code>RockeMQ</code> 的存储架构还有些模糊，没事，我们结合着图来理解一下。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef388763c25c62.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>emmm，是不是有一点复杂 🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。</p>\n<blockquote>\n<p>如果上面没看懂的读者一定要认真看下面的流程分析！</p>\n</blockquote>\n<p>首先，在最上面的那一块就是我刚刚讲的你现在可以直接 <strong>把 <code>ConsumerQueue</code> 理解为 <code>Queue</code></strong>。</p>\n<p>在图中最左边说明了红色方块代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code>Topic</code>、<code>QueueId</code> 和具体消息内容，而在 <code>Broker</code> 中管你是哪门子消息，他直接 <strong>全部顺序存储到了 CommitLog</strong>。而根据生产者指定的 <code>Topic</code> 和 <code>QueueId</code> 将这条消息本身在 <code>CommitLog</code> 的偏移(offset)，消息本身大小，和 tag 的 hash 值存入对应的 <code>ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code>ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code>ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p>\n<p>上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。</p>\n<p>因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考 🤔🤔 一下吧。</p>\n<figure><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/e314ee45gy1g05zgr67bbj20gp0b3aba.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为什么 <code>CommitLog</code> 文件要设计成固定大小的长度呢？提醒：<strong>内存映射机制</strong>。</p>\n<h2>总结</h2>\n<p>总算把这篇博客写完了。我讲的你们还记得吗 😅？</p>\n<p>这篇文章中我主要想大家介绍了</p>\n<ol>\n<li>消息队列出现的原因</li>\n<li>消息队列的作用(异步，解耦，削峰)</li>\n<li>消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)</li>\n<li>消息队列的两种消息模型——队列和主题模式</li>\n<li>分析了 <code>RocketMQ</code> 的技术架构(<code>NameServer</code>、<code>Broker</code>、<code>Producer</code>、<code>Comsumer</code>)</li>\n<li>结合 <code>RocketMQ</code> 回答了消息队列副作用的解决方案</li>\n<li>介绍了 <code>RocketMQ</code> 的存储机制和刷盘策略。</li>\n</ol>\n<p>等等。。。</p>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef37fee7e09230.jpg",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "糟糕程序员的 20 个坏习惯",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers.html",
      "summary": "推荐语：Kaito 大佬的一篇文章，很实用的建议！ 原文地址： https://mp.weixin.qq.com/s/6hUU6SZsxGPWAIIByq93Rw 我想你肯定遇到过这样一类程序员：他们无论是写代码，还是写文档，又或是和别人沟通，都显得特别专业。每次遇到这类人，我都在想，他们到底是怎么做到的？ 随着工作时间的增长，渐渐地我也总结出一些经验...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：Kaito 大佬的一篇文章，很实用的建议！</p>\n<br>\n<p><strong>原文地址：</strong> <a href=\"https://mp.weixin.qq.com/s/6hUU6SZsxGPWAIIByq93Rw\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/6hUU6SZsxGPWAIIByq93Rw</a></p>\n</blockquote>\n<p>我想你肯定遇到过这样一类程序员：<strong>他们无论是写代码，还是写文档，又或是和别人沟通，都显得特别专业</strong>。每次遇到这类人，我都在想，他们到底是怎么做到的？</p>\n<p>随着工作时间的增长，渐渐地我也总结出一些经验，他们身上都保持着一些看似很微小的优秀习惯，但正是因为这些习惯，体现出了一个优秀程序员的基本素养。</p>\n<p>但今天我们来换个角度，来看看一个糟糕程序员有哪些坏习惯？只要我们都能避开这些问题，就可以逐渐向一个优秀程序员靠近。</p>\n<h2>1、技术名词拼写不规范</h2>\n<p>无论是个人简历，还是技术文档，我经常看到拼写不规范的技术名词，例如 JAVA、javascript、python、MySql、Hbase、restful。</p>\n<p>正确的拼写应该是 Java、JavaScript、Python、MySQL、HBase、RESTful，不要小看这个问题，很多面试官很有可能因为这一点刷掉你的简历。</p>\n<h2>2、写文档，中英文混排不规范</h2>\n<p>中文描述使用英文标点符号，英文和数字使用了全角字符，中文与英文、数字之间没有空格等等。</p>\n<p>其中很多人会忽视中文和英文、数字之间加一个「空格」，这样排版阅读起来会更舒服。之前我的文章排版，都是遵循了这些细节。</p>\n<h2>3、重要逻辑不写注释，或写得很拖沓</h2>\n<p>复杂且重要的逻辑代码，很多程序员不写注释，除了自己能看懂代码逻辑，其他人根本看不懂。或者是注释虽然写了，但写得很拖沓，没有逻辑可言。</p>\n<p>重要的逻辑不止要写注释，还要写得简洁、清晰。如果是一眼就能读懂的简单代码，可以不加注释。</p>\n<h2>4、写复杂冗长的函数</h2>\n<p>一个函数几百行，一个文件上千行代码，复杂函数不做拆分，导致代码变得越来越难维护，最后谁也不敢动。</p>\n<p>基本的设计模式还是要遵守的，例如单一职责，一个函数只做一件事，开闭原则，对扩展开放，对修改关闭。</p>\n<p>如果函数逻辑确实复杂，也至少要保证主干逻辑足够清晰。</p>\n<h2>5、不看官方文档，只看垃圾博客</h2>\n<p>很多人遇到问题不先去看官方文档，而是热衷于去看垃圾博客，这些博客的内容都是互相抄袭，错误百出。</p>\n<p>其实很多软件官方文档写得已经非常好了，常见问题都能找到答案，认真读一读官方文档，比看垃圾博客强一百倍，要养成看官方文档的好习惯。</p>\n<h2>6、宣扬内功无用论</h2>\n<p>有些人天天追求日新月异的开源项目和框架，却不肯花时间去啃一啃底层原理，常见问题虽然可以解决，但遇到稍微深一点的问题就束手无策。</p>\n<p>很多高大上的架构设计，思路其实都源于底层。想一想，像计算机体系结构、操作系统、网络协议这些东西，经过多少年演进才变为现在的样子，演进过程中遇到的复杂问题比比皆是，理解了解决这些问题的思路，再看上层技术会变得很简单。</p>\n<h2>7、乐于炫技</h2>\n<p>有些人天天把「高大上」的技术名词挂在嘴边，生怕别人不知道自己学了什么高深技术，嘴上乐于炫技，但别人一问他细节就会哑口无言。</p>\n<h2>8、不接受质疑</h2>\n<p>自己设计的方案，别人提出疑问时只会回怼，而不是理性分析利弊，抱着学习的心态交流。</p>\n<p>这些人学了点东西就觉得自己很有本事，殊不知只是自己见识太少。</p>\n<h2>9、接口协议不规范</h2>\n<p>和别人定 API 协议全靠口头沟通，不给规范的文档说明，甚至到了测试联调时会发现，竟然和协商的还不一样，或者改协议了却不通知对接方，合作体验极差。</p>\n<h2>10、遇到问题自己死磕</h2>\n<p>很初级程序员容易犯的问题，遇到问题只会自己死磕，拖到 deadline 也没有产出，领导来问才知道有问题解决不了。</p>\n<p>有问题及时反馈才是对自己负责，对团队负责。</p>\n<h2>11、一说就会，一写就废</h2>\n<p>平时技术方案吹得天花乱坠，一让他写代码就废，典型的眼高手低选手。</p>\n<h2>12、表达没有逻辑，不站在对方角度看问题</h2>\n<p>讨论问题不交代背景，上来就说自己的方案，别人听得云里雾里，让你从头描述你又讲不明白。</p>\n<p>学会沟通和表达，是合作的基础。</p>\n<h2>13、不主动思考，伸手党</h2>\n<p>遇到问题不去 google，不做思考就向别人提问，喜欢做伸手党。</p>\n<p>每个人的时间都很宝贵，大家都更喜欢你带着自己的思考来提问，一来可以规避很多低级问题，二来可以提高交流质量。</p>\n<h2>14、经常犯重复的错误</h2>\n<p>出问题后说下次会注意，但下次问题依旧，对自己不负责任，说到底是态度问题。</p>\n<h2>15、加功能不考虑扩展性</h2>\n<p>加新功能只关注某一小块业务，不考虑系统整体的扩展性，堆代码行为严重。</p>\n<p>要学会分析需求和未来可能发生的变化，设计更通用的解决方案，降低后期开发成本。</p>\n<h2>16、接口不自测，出问题不打日志</h2>\n<p>自己开发的接口不自测就和别人联调，出了问题又说没打日志，协作效率极低。</p>\n<h2>17、提交代码不规范</h2>\n<p>很多人提交代码不写描述，或者写的是无意义的描述，尤其是修改很少代码时，这种情况会导致回溯问题成本变高。</p>\n<p>制定代码提交规范，能让你在每一次提交代码时，不会做太随意的代码修改。</p>\n<h2>18、手动修改生产环境数据库</h2>\n<p>直连生产环境数据库修改数据，更有 UPDATE / DELETE SQL 忘写 WHERE 条件的情况，产生数据事故。</p>\n<p>修改生产环境数据库一定要谨慎再谨慎，建议操作前先找同事 review 代码再操作。</p>\n<h2>19、没理清需求就直接写代码</h2>\n<p>很多程序员接到需求后，不怎么思考就开始写代码，需求和自己理解的有偏差，造成无意义返工。</p>\n<p>多花些时间梳理需求，能规避很多不合理的问题。</p>\n<h2>20、重要设计不写文档</h2>\n<p>重要的设计没有文档输出，和别人交接系统时只做口头描述，丢失关键信息。</p>\n<p>有时候理解一个设计方案，一个好的文档要比看几百行代码更高效。</p>\n<h2>总结</h2>\n<p>以上这些不良习惯，你命中几个呢？或者你身边有没有碰到这样的人？</p>\n<p>我认为提早规避这些问题，是成为一个优秀程序员必须要做的。这些习惯总结起来大致分为这 4 个方面：</p>\n<ul>\n<li>良好的编程修养</li>\n<li>谦虚的学习心态</li>\n<li>良好的沟通和表达</li>\n<li>注重团队协作</li>\n</ul>\n<p>优秀程序员的专业技能，我们可能很难在短时间内学会，但这些基本的职业素养，是可以在短期内做到的。</p>\n<p>希望你我可以有则改之，无则加勉。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "Kaito"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "给想成长为高级别开发同学的七条建议",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer.html",
      "summary": "推荐语：普通程序员要想成长为高级程序员甚至是专家等更高级别，应该注意在哪些方面注意加强？开发内功修炼号主飞哥在这篇文章中就给出了七条实用的建议。 内容概览： 刻意加强需求评审能力 主动思考效率 加强内功能力 思考性能 重视线上 关注全局 归纳总结能力 原文地址：https://mp.weixin.qq.com/s/8lMGzBzXine-NAsqEaIE4g",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：普通程序员要想成长为高级程序员甚至是专家等更高级别，应该注意在哪些方面注意加强？开发内功修炼号主飞哥在这篇文章中就给出了七条实用的建议。</p>\n<br>\n<p><strong>内容概览</strong>：</p>\n<ol>\n<li>刻意加强需求评审能力</li>\n<li>主动思考效率</li>\n<li>加强内功能力</li>\n<li>思考性能</li>\n<li>重视线上</li>\n<li>关注全局</li>\n<li>归纳总结能力</li>\n</ol>\n<p><strong>原文地址</strong>：<a href=\"https://mp.weixin.qq.com/s/8lMGzBzXine-NAsqEaIE4g\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/8lMGzBzXine-NAsqEaIE4g</a></p>\n</blockquote>\n<h3>建议 1：刻意加强需求评审能力</h3>\n<p>先从需求评审开始说。在互联网公司，需求评审是开发工作的主要入口。</p>\n<p>对于普通程序员来说，一般就是根据产品经理提的需求细节，开始设想这个功能要怎么实现，开发成本大概需要多长时间。把自己当成了需求到代码之间的翻译官。很少去思考需求的合理性，对于自己做的事情有多大价值，不管也不问。</p>\n<p>而对于高级别的程序员来说，并不会一开始就陷入细节，而是会更多地会从产品本身出发，询问产品经理为啥要做这个细节，目的是啥。换个说法，就是会先考虑这个需求是不是合理。</p>\n<p>如果需求高级不合理就进行 PK ，要么对需求进行调整，要么就砍掉。不过要注意的是 PK 和调整需求不仅仅砍需求，还有另外一个方向，那就是对需求进行加强。</p>\n<p>产品同学由于缺乏技术背景，很可能想的并不够充分，这个时候如果你有更好的想法，也完全可以提出来，加到需求里，让这个需求变得更有价值。</p>\n<p>总之，高级程序员并不会一五一十地按产品经理的需求文档来进行后面的开发，而是<strong>一切从有利于业务的角度出发思考，对产品经理的需求进行删、改、增。</strong></p>\n<p>这样的工作表面看似和开发无关，但是只有这样才能保证后续所有开发同学都是有价值的，而不是做一堆无用功。无用功做的多了会极大的挫伤开发的成就感。</p>\n<p>所以，<strong>普通程序员要想成长为更高级别的开发，一定要加强需求评审能力的培养</strong>。</p>\n<h3>建议 2：主动思考效率</h3>\n<p>普通的程序员，按部就班的去写代码，有活儿来我就干，没活儿的时候我就呆着。很少去深度思考现有的这些代码为什么要这么写，这么写的好处是啥，有哪些地方存在瓶颈，我是否可以把它优化一些。</p>\n<p>而高级一点程序员，并不会局限于把手头的活儿开发就算完事。他们会主动去琢磨，现在这种开发模式是不是不够的好。那么我是否能做一个什么东西能把这个效率给提升起来。</p>\n<p>举一个小例子，我 6 年前接手一个项目的时候，我发现运营一个月会找我四次，就是找我给她发送一个推送。她说以前的开发都是这么帮他弄的。虽然这个需求处理起来很简单，改两行发布一下就完事。但是烦啊，你想象一下你正专心写代码呢，她又双叒来找你了，思路全被她中断了。而且频繁地操作线上本来就会引入不确定的风险，万一那天手一抽抽搞错了，线上就完蛋了。</p>\n<p>我的做法就是，我专门抽了一周的时间，给她做了一套运营后台。这样以后所有的运营推送她就直接在后台上操作就完事了。我倒出精力去做其它更有价值的事情去了。</p>\n<p>所以，<strong>第二个建议就是要主动思考一下现有工作中哪些地方效率有改进的空间，想到了就主动去改进它！</strong></p>\n<h3>建议 3：加强内功能力</h3>\n<p>哪些算是内功呢，我想内功修炼的读者们肯定也都很熟悉的了，指的就是大家学校里都学过的操作系统、网络等这些基础。</p>\n<p>普通的程序员会觉得，这些基础知识我都会好么，我大学可是足足学了四年的。工作了以后并不会刻意来回头再来加强自己在这些基础上的深层次的提升。</p>\n<p>高级的程序员，非常清楚自己当年学的那点知识太皮毛了。工作之余也会深入地去研究 Linux、研究网络等方向的底层实现。</p>\n<p>事实上，互联网业界的技术大牛们很大程度是因为对这些基础的理解相当是深厚，具备了深厚的内功以后才促使他们成长为了技术大牛。</p>\n<p>我很难相信一个不理解底层，只会 CURD，只会用别人框架的开发将来能在技术方向成长为大牛。</p>\n<p>所以，<strong>还建议多多锻炼底层技术内功能力</strong>。如果你不知道怎么练，那就坚持看「开发内功修炼」公众号。</p>\n<h3>建议 4：思考性能</h3>\n<p>普通程序员往往就是把需求开发完了就不管了，只要需求实现了，测试通过了就可以交付了。将来流量会有多大，没想过。自己的服务 QPS 能支撑多少，不清楚。</p>\n<p>而高级的程序员往往会关注自己写出来的代码的性能。</p>\n<p>在需求评审的时候，他们一般就会估算大概的请求流量有多大。进而设计阶段就会根据这个量设计符合性能要求的方案。</p>\n<p>在上线之前也会进行性能压测，检验一下在性能上是否符合预期。如果性能存在问题，瓶颈在哪儿，怎么样能进行优化一下。</p>\n<p>所以，<strong>第四个建议就是一定要多多主动你所负责业务的性能，并多多进行优化和改进</strong>。我想这个建议的重要程度非常之高。但这是需要你具备深厚的内功才可以办的到的，否则如果你连网络是怎么工作的都不清楚，谈何优化！</p>\n<h3>建议 5：重视线上</h3>\n<p>普通程序员往往对线上的事情很少去关注，手里记录的服务器就是自己的开发机和发布机，线上机器有几台，流量多大，最近有没有波动这些可能都不清楚。</p>\n<p>而高级的程序员深深的明白，有条件的话，会尽量多多观察自己的线上服务，观察一下代码跑的咋样，有没有啥 error log。请求峰值的时候 CPU、内存的消耗咋样。网络端口消耗的情况咋样，是否需要调节一些参数配置。</p>\n<p>当性能不尽如人意的时候，可能会回头再来思考出性能的改进方案，重新开发和上线。</p>\n<p>你会发现在线上出问题的时候，能紧急扑上前线救火的都是高级一点的程序员。</p>\n<p>所以，<strong>飞哥给的第五个建议就是要多多观察线上运行情况</strong>。只有多多关注线上，当线上出故障的时候，你才能承担的起快速排出线上问题的重任。</p>\n<h3>建议 6：关注全局</h3>\n<p>普通程序员是你分配给我哪个模块，我就干哪个模块，给自己的工作设定了非常小的一个边界，自己所有的眼光都聚集在这个小框框内。</p>\n<p>高级程序员是团队内所有项目模块，哪怕不是他负责的，他也会去熟悉，去了解。具备这种思维的同学无论在技术上，无论是在业务上，成长的也都是最快的。在职级上得到晋升，或者是职位上得到提拔的往往都是这类同学。</p>\n<p>甚至有更高级别的同学，还不止于把目光放在团队内，甚至还会关注公司内其它团队，甚至是业界的业务和技术栈。写到这里我想起了张一鸣说过的，不给自己的工作设边界。</p>\n<p>所以，<strong>建议要有大局观，不仅仅是你负责的模块，整个项目其实你都应该去关注</strong>。而不是连自己组内同学做的是啥都不知道。</p>\n<h3>建议 7：归纳总结能力</h3>\n<p>普通程序员往往是工作的事情做完就拉到，很少回头去对自己的技术，对业务进行归纳和总结。</p>\n<p>而高级的程序员往往都会在一件比较大的事情做完之后总结一下，做个 ppt，写个博客啥的记录下来。这样既对自己的工作是一个归纳，也可以分享给其它同学，促进团队的共同成长。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "Kaito"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "十年大厂成长之路",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road.html",
      "summary": "推荐语：这篇文章的作者有着丰富的工作经验，曾在大厂工作了 12 年。结合自己走过的弯路和接触过的优秀技术人，他总结出了一些对于个人成长具有普遍指导意义的经验和特质。 原文地址： https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w 最近这段时间，有好几个年轻的同学和我聊到自己的迷茫。其中有关于技术成长的、有...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：这篇文章的作者有着丰富的工作经验，曾在大厂工作了 12 年。结合自己走过的弯路和接触过的优秀技术人，他总结出了一些对于个人成长具有普遍指导意义的经验和特质。</p>\n<br>\n<p><strong>原文地址：</strong> <a href=\"https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w</a></p>\n</blockquote>\n<p>最近这段时间，有好几个年轻的同学和我聊到自己的迷茫。其中有关于技术成长的、有关于晋升的、有关于择业的。我很高兴他们愿意听我这个“过来人”分享自己的经验。</p>\n<p>我自己毕业后进入大厂，在大厂工作 12 年，我说的内容都来自于我自己或者身边人的真实情况。尤其，我会把 <strong>【我自己走过的弯路】</strong> 和 <strong>【我看到过的优秀技术人的特质】</strong> 相结合来给出建议。</p>\n<p>这些内容我觉得具有普遍的指导意义，所以决定做个整理分享出来。我相信，无论你在大厂还是小厂，如果你相信这些建议，或早或晚他们会帮助到你。</p>\n<p>我自己工作 12 年，走了些弯路，所以我就来讲讲，“在一个技术人 10 年的发展过程中，应该注意些什么”。我们把内容分为两块：</p>\n<ol>\n<li><strong>十年技术路怎么走</strong></li>\n<li><strong>一些重要选择</strong></li>\n</ol>\n<h2>01 十年技术路怎么走</h2>\n<h3>【1-2 年】=&gt; 从“菜鸟”到“职业”</h3>\n<p>应届生刚进入到工作时，会有各种不适应。比如写好的代码会被反复打回、和团队老司机讨论技术问题会有一堆问号、不敢提问和质疑、碰到问题一个人使劲死磕等等。</p>\n<p><strong>简单来说就是，即使日以继夜地埋头苦干，最后也无法顺利的开展工作。</strong></p>\n<p>这个阶段最重要的几个点：</p>\n<p><strong>【多看多模仿】</strong>：比如写代码的时候，不要就像在学校完成书本作业那样只关心功能是否正确，还要关心模块的设计、异常的处理、代码的可读性等等。在你还没有了解这些内容的精髓之前，也要照猫画虎地模仿起来，慢慢地你就会越来越明白真实世界的代码是怎么写的，以及为什么要这么写。</p>\n<p>做技术方案的时候也是同理，技术文档的要求你也许并不理解，但你可以先参考已有文档写起来。</p>\n<p><strong>【脸皮厚一点】</strong>：不懂就问，你是新人大家都是理解的。你做的各种方案也可以多找老司机们 review，不要怕被看笑话。</p>\n<p><strong>【关注工作方式】</strong>：比如发现需求在计划时间完不成就要尽快报风险、及时做好工作内容的汇报（例如周报）、开会后确定会议结论和 todo 项、承诺时间就要尽力完成、严格遵循公司的要求（例如发布规范、权限规范等）</p>\n<p>一般来说，工作 2 年后，你就应该成为一个职业人。老板可以相信任何工作交到你的手里，不会出现“意外”（例如一个重要需求明天要上线了，突然被告知上不了）。</p>\n<h3>【3-4 年】=&gt; 从“职业”到“尖兵”</h3>\n<p>工作两年后，对业务以及现有系统的了解已经到达了一定的程度，技术同学会开始承担更有难度的技术挑战。</p>\n<p>例如需要将性能提升到某一个水位、例如需要对某一个重要模块进行重构、例如有个重要的项目需要协同 N 个团队一起完成。</p>\n<p>可见，上述的这些技术问题，难度都已经远远超过一个普通的需求。解决这些问题需要有一定的技术能力，同时也需要具备更高的协同能力。</p>\n<p>这个阶段最重要的几个点：</p>\n<p><strong>【技术能力提升】</strong>：无论是公司内还是公司外的技术内容，都要多做主动的学习。基本上这个阶段的技术难题都集中在【性能】【稳定性】和【扩展性】上，而这些内容在业界都是有成型的方法论的。</p>\n<p><strong>【主人翁精神】</strong>：技术难题除了技术方案设计及落地外，背后还有一系列的其他工作。例如上线后对效果的观测、重点项目对于上下游改造和风险的了解程度、对于整个技改后续的计划（二期、三期的优化思路）等。</p>\n<p>在工作四年后，基本上你成为了团队的一、二号技术位。很多技术难题即使不是你来落地，也是由你来决定方案。你会做调研、会做方案对比、会考虑整个技改的生命周期。</p>\n<h3>【5-7 年】=&gt; 从“尖兵”到“专家”</h3>\n<p>技术尖兵重点在于解决某一个具体的技术难题或者重点项目。而下一步的发展方向，就是能够承担起来一整个“业务板块”，也就是“领域技术专家”。</p>\n<p>想要承担一整个“业务板块”需要 <strong>【对业务领域有深刻的理解，同时基于这些理解来规划技术的发展方向】</strong> 。</p>\n<p>拿支付做个例子。简单的支付功能其实很容易完成，只要处理好和双联（网联和银联）的接口调用（成功、失败、异常）即可。但在很多背景下，支付没有那么简单。</p>\n<p>例如，支付是一个用户敏感型操作，非常强调用户体验，如何能兼顾体验和接口的不稳定？支付接口还需要承担费用，同步和异步的接口费用不同，如何能够降本？支付接口往往还有限额等。这一系列问题的背后涉及到很多技术的设计，包括异步化、补偿设计、资金流设计、最终一致性设计等等。</p>\n<p>这个阶段最重要的几个点：</p>\n<p><strong>【深入理解行业及趋势】</strong>：密切关注行业的各种变化（新鲜的玩法、政策的变动、竞对的策略、科技等外在因素的影响等等），和业务同学加强沟通。</p>\n<p><strong>【深入了解行业解决方案】</strong>：充分对标已有的国内外技术方案，做深入学习和尝试，评估建设及运维成本，结合业务趋势制定计划。</p>\n<h3>【8-10 年】=&gt; 从“专家”到“TL”</h3>\n<p>其实很多时候，如果能做到专家，基本也是一个 TL 的角色了，但这并不代表正在执行 TL 的职责。</p>\n<p>专家虽然已经可以做到“为业务发展而规划好技术发展”，但问题是要怎么落地呢？显然，靠一个人的力量是不可能完成建设的。所以，这里的 TL 更多强调的不是“领导”这个职位，而是 <strong>【通过聚合一个团队的力量来实施技术规划】</strong> 。</p>\n<p>所以，这里的 TL 需要具备【团队技术培养】【合理分配资源】【确认工作优先级】【激励与奖惩】等各种能力。</p>\n<p>这个阶段最重要的几个点：</p>\n<p><strong>【学习管理学】</strong>：这里的管理学当然不是指 PUA，而是指如何在每个同学都有各自诉求的现实背景下，让个人目标和团队目标相结合，产生向前发展的动力。</p>\n<p><strong>【始终扎根技术】</strong>：很多时候，工作重心偏向管理以后，就会荒废技术。但事实是，一个优秀的领导永远是一个优秀的技术人。参与一起讨论技术方案并给予指导、不断扩展自己的技术宽度、保持对技术的好奇心，这些是让一个技术领导持续拥有向心力的关键。</p>\n<h2>02 一些重要选择</h2>\n<p>下面来聊聊在十年间我们可能会碰到的一些重要选择。这些都是真实的血与泪的教训。</p>\n<h3>我该不该转岗？</h3>\n<p>大厂都有转岗的机制。转岗可以帮助员工寻找自己感兴趣的方向，也可以帮助新型团队招募有即战力的同学。</p>\n<p>转岗看似只是在公司内部变动，但你需要谨慎决定。</p>\n<p>本人转岗过多次。虽然还在同一家公司，但转岗等同于换工作。无论是领域沉淀、工作内容、信任关系、协作关系都是从零开始。</p>\n<p>针对转岗我的建议是：**如果你是想要拓宽自己的技术广度，也就是抱着提升技术能力的想法，我觉得可以转岗。但如果你想要晋升，不建议你转岗。**晋升需要在一个领域的持续积淀和在一个团队信任感的持续建立。</p>\n<p>当然，转岗可能还有其他原因，例如家庭原因、身体原因等，这个不展开讨论了。</p>\n<h3>我该不该跳槽？</h3>\n<p>跳槽和转岗一样，往往有很多因素造成，不能一概而论，我仅以几个场景来说：</p>\n<p><strong>【晋升失败】</strong>：扪心自问，如果你觉得自己确实还不够格，那你就踏踏实实继续努力。如果你觉得评委有失偏颇，你可以尝试去外面面试一下，让市场来给你答案。</p>\n<p><strong>【成长局限】</strong>：觉得自己做的事情没有挑战，无法成长。你可以和老板聊一下，有可能是因为你没有看到其中的挑战，也有可能老板没有意识到你的“野心”。</p>\n<p><strong>【氛围不适】</strong>：一般来自于新入职或者领导更换，这种情况下不适是正常的。我的建议是，<strong>如果一个环境是“对事不对人”的，那就可以留下来</strong>，努力去适应，这种不适应只是做事方式不同导致的。但如果这个环境是“对人不对事”的话，走吧。</p>\n<h3>跳槽该找怎样的工作？</h3>\n<p>我们跳槽的时候往往会同时面试好几家公司。行情好的时候，往往可以收到多家 offer，那么我们要如何选择呢？</p>\n<p>考虑一个 offer 往往有这几点：【公司品牌】【薪资待遇】【职级职称】【技术背景】。每个同学其实都有自己的诉求，所以无论做什么选择都没有对错之分。</p>\n<p>我的一个建议是：<strong>你要关注新岗位的空间，这个空间是有希望满足你的期待的</strong>。</p>\n<p>比如，你想成为架构师，那新岗位是否有足够的技术挑战来帮助你提升技术能力，而不仅仅是疲于奔命地应付需求？</p>\n<p>比如，你想往技术管理发展，那新岗位是否有带人的机会？是否有足够的问题需要搭建团队来解决？</p>\n<p>比如，你想扎根在某个领域持续发展（例如电商、游戏），那新岗位是不是延续这个领域，并且可以碰到更多这个领域的问题？</p>\n<p>当然，如果薪资实在高到无法拒绝，以上参考可以忽略!</p>\n<h2>结语</h2>\n<p>以上就是我对互联网从业技术人员十年成长之路的心得，希望在你困惑和关键选择的时候可以帮助到你。如果我的只言片语能够在未来的某个时间帮助到你哪怕一点，那将是我莫大的荣幸。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "CodingBetterLife"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "程序员的技术成长战略",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant.html",
      "summary": "推荐语：波波老师的一篇文章，写的非常好，不光是对技术成长有帮助，其他领域也是同样适用的！建议反复阅读，形成一套自己的技术成长策略。 原文地址： https://mp.weixin.qq.com/s/YrN8T67s801-MRo01lCHXA 1. 前言 在波波的微信技术交流群里头，经常有学员问关于技术人该如何学习成长的问题，虽然是微信交流，但我依然可...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：波波老师的一篇文章，写的非常好，不光是对技术成长有帮助，其他领域也是同样适用的！建议反复阅读，形成一套自己的技术成长策略。</p>\n<br>\n<p><strong>原文地址：</strong> <a href=\"https://mp.weixin.qq.com/s/YrN8T67s801-MRo01lCHXA\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/YrN8T67s801-MRo01lCHXA</a></p>\n</blockquote>\n<h2>1. 前言</h2>\n<p>在波波的微信技术交流群里头，经常有学员问关于技术人该如何学习成长的问题，虽然是微信交流，但我依然可以感受到小伙伴们焦虑的心情。</p>\n<p><strong>技术人为啥焦虑？</strong> 恕我直言，说白了是胆识不足格局太小。胆就是胆量，焦虑的人一般对未来的不确定性怀有恐惧。识就是见识，焦虑的人一般看不清楚周围世界，也看不清自己和适合自己的道路。格局也称志向，容易焦虑的人通常视野窄志向小。如果从战略和管理的视角来看，就是对自己和周围世界的认知不足，没有一个清晰和长期的学习成长战略，也没有可执行的阶段性目标计划+严格的执行。</p>\n<p>因为问此类问题的学员很多，让我感觉有点烦了，为了避免重复回答，所以我专门总结梳理了这篇长文，试图统一来回答这类问题。如果后面还有学员问类似问题，我会引导他们来读这篇文章，然后让他们用三个月、一年甚至更长的时间，去思考和回答这样一个问题：<strong>你的技术成长战略究竟是什么？</strong> 如果你想清楚了这个问题，有清晰和可落地的答案，那么恭喜你，你只需按部就班执行就好，根本无需焦虑，你实现自己的战略目标并做出成就只是一个时间问题；否则，你仍然需要通过不断磨炼+思考，务必去搞清楚这个人生的大问题！！！</p>\n<p>下面我们来看一些行业技术大牛是怎么做的。</p>\n<h2>二. 跟技术大牛学成长战略</h2>\n<p>我们知道软件设计是有设计模式(Design Pattern)的，其实技术人的成长也是有成长模式(Growth Pattern)的。波波经常在 Linkedin 上看一些技术大牛的成长履历，探究其中的成长模式，从而启发制定自己的技术成长战略。</p>\n<p>当然，很少有技术大牛会清晰地告诉你他们的技术成长战略，以及每一年的细分落地计划。但是，这并不妨碍我们通过他们的过往履历和产出成果，去溯源他们的技术成长战略。实际上， <strong>越是牛逼的技术人，他们的技术成长战略和路径越是清晰，我们越容易从中探究出一些成功的模式。</strong></p>\n<h3>2.1 系统性能专家案例</h3>\n<p>国内的开发者大都热衷于系统性能优化，有些人甚至三句话离不开高性能/高并发，但真正能深入这个领域，做到专家级水平的却寥寥无几。</p>\n<p>我这边要特别介绍的这个技术大牛叫 <strong>Brendan Gregg</strong> ，他是系统性能领域经典书《System Performance: Enterprise and the Cloud》(中文版<a href=\"https://www.amazon.cn/dp/B08GC261P9\" target=\"_blank\" rel=\"noopener noreferrer\">《性能之巅：洞悉系统、企业和云计算》</a>)的作者，也是著名的<a href=\"https://github.com/brendangregg/FlameGraph\" target=\"_blank\" rel=\"noopener noreferrer\">性能分析利器火焰图(Flame Graph)</a>的作者。</p>\n<p>Brendan Gregg 之前是 Netflix 公司的高级性能架构师，在 Netflix 工作近 7 年。2022 年 4 月，他离开了 Netflix 去了 Intel，担任院士职位。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/cdb11ce2f1c3a69fd19e922a7f5f59bf.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>总体上，他已经在系统性能领域深耕超过 10 年，<a href=\"https://www.linkedin.com/in/brendangregg/\" target=\"_blank\" rel=\"noopener noreferrer\">Brendan Gregg 的过往履历</a>可以在 linkedin 上看到。在这 10 年间，除了书籍以外，Brendan Gregg 还产出了超过上百份和系统性能相关的技术文档，演讲视频/ppt，还有各种工具软件，相关内容都整整齐齐地分享在<a href=\"http://www.brendangregg.com/\" target=\"_blank\" rel=\"noopener noreferrer\">他的技术博客</a>上，可以说他是一个非常高产的技术大牛。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231802218.png\" alt=\"性能工具\" tabindex=\"0\"><figcaption>性能工具</figcaption></figure>\n<p>上图来自 Brendan Gregg 的新书《BPF Performance Tools: Linux System and Application Observability》。从这个图可以看出，Brendan Gregg 对系统性能领域的掌握程度，已经深挖到了硬件、操作系统和应用的每一个角落，可以说是 360 度无死角，整个计算机系统对他来说几乎都是透明的。波波认为，Brendan Gregg 是名副其实的，世界级的，系统性能领域的大神级人物。</p>\n<h3>2.2 从开源到企业案例</h3>\n<p>我要分享的第二个技术大牛是 <strong>Jay Kreps</strong>，他是知名的开源消息中间件 Kafka 的创始人/架构师，也是 Confluent 公司的联合创始人和 CEO，Confluent 公司是围绕 Kafka 开发企业级产品和服务的技术公司。</p>\n<p>从<a href=\"https://www.linkedin.com/in/jaykreps/\" target=\"_blank\" rel=\"noopener noreferrer\">Jay Kreps 的 Linkedin 的履历</a>上我们可以看出，Jay Kreps 之前在 Linkedin 工作了 7 年多(2007.6 ~ 2014. 9)，从高级工程师、工程主管，一直做到首席资深工程师。Kafka 大致是在 2010 年，Jay Kreps 在 Linkedin 发起的一个项目，解决 Linkedin 内部的大数据采集、存储和消费问题。之后，他和他的团队一直专注 Kafka 的打磨，开源(2011 年初)和社区生态的建设。</p>\n<p>到 2014 年底，Kafka 在社区已经非常成功，有了一个比较大的用户群，于是 Jay Kreps 就和几个早期作者一起离开了 Linkedin，成立了<a href=\"https://tech.163.com/14/1107/18/AAFG92LD00094ODU.html\" target=\"_blank\" rel=\"noopener noreferrer\">Confluent 公司</a>，开始了 Kafka 和周边产品的企业化服务道路。今年(2020.4 月)，Confluent 公司已经获得 E 轮 2.5 亿美金融资，公司估值达到 45 亿美金。从 Kafka 诞生到现在，Jay Kreps 差不多在这个产品和公司上投入了整整 10 年。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231805796.png\" alt=\"Confluent创始人三人组\" tabindex=\"0\"><figcaption>Confluent创始人三人组</figcaption></figure>\n<p>上图是 Confluent 创始人三人组，一个非常有意思的组合，一个中国人(左)，一个印度人(右)，中间的 Jay Kreps 是美国人。</p>\n<p>我之所以对 Kafka 和 Jay Kreps 的印象特别深刻，是因为在 2012 年下半年，我在携程框架部也是专门搞大数据采集的，我还开发过一套功能类似 Kafka 的 Log Collector + Agent 产品。我记得同时期有不止 4 个同类型的开源产品：Facebook Scribe、Apache Chukwa、Apache Flume 和 Apache Kafka。现在回头看，只有 Kafka 走到现在发展得最好，这个和创始人的专注和持续投入是分不开的，当然背后和几个创始人的技术大格局也是分不开的。</p>\n<p>当年我对战略性思维几乎没有概念，还处在<strong>什么技术都想学、认为各种项目做得越多越牛的阶段</strong>。搞了半年的数据采集以后，我就掉头搞其它“更有趣的”项目去了(从这个事情的侧面，也可以看出我当年的技术格局是很小的)。中间我陆续关注过 Jay 的一些创业动向，但是没想到他能把 Confluent 公司发展到目前这个规模。现在回想，其实在十年前，Jay Kreps 对自己的技术成长就有比较明确的战略性思考，也具有大的技术格局和成事的一些必要特质。Jay Kreps 和 Kafka 给我上了一堂生动的技术战略和实践课。</p>\n<h3>2.3 技术媒体大 V 案例</h3>\n<p>介绍到这里，有些同学可能会反驳说：波波你讲的这些大牛都是学历背景好，功底扎实起点高，所以他们才更能成功。其实不然，这里我再要介绍一位技术媒体界的大 V 叫 Brad Traversy，大家可以看<a href=\"https://www.linkedin.com/in/bradtraversy/\" target=\"_blank\" rel=\"noopener noreferrer\">他的 Linkedin 简历</a>，背景很一般，学历差不多是一个非正规的社区大学(相当于大专)，没有正规大厂工作经历，有限几份工作一直是在做网站外包。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/30d6d67dc6dd5f9251f2f01af4de53fc.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但是！！！Brad Traversy 目前是技术媒体领域的一个大 V，当前<a href=\"https://www.youtube.com/c/TraversyMedia\" target=\"_blank\" rel=\"noopener noreferrer\">他在 Youtube 上的频道</a>有 138 万多的订阅量，10 年累计输出 Web 开发和编程相关教学视频超过 800 个。Brad Traversy 也是 <a href=\"https://www.udemy.com/user/brad-traversy/\" target=\"_blank\" rel=\"noopener noreferrer\">Udemy</a> 上的一个成功讲师，目前已经在 Udemy 上累计输出课程 19 门，购课学生数量近 42 万。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/160b0bc4f689413757b9b5e2448f940b.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Brad Traversy 目前是自由职业者，他的 Youtube 广告+Udemy 课程的收入相当不错。</p>\n<p>就是这样一位技术媒体大 V，你很难想象，在年轻的时候，贴在他身上的标签是：不良少年，酗酒，抽烟，吸毒，纹身，进监狱。。。直</p>\n<p>到结婚后的第一个孩子诞生，他才开始担起责任做出改变，然后凭借对技术的一腔热情，开始在 Youtube 平台上持续输出免费课程。从此他找到了适合自己的战略目标，然后人生开始发生各种积极的变化。。。如果大家对 Brad Traversy 的过往经历感兴趣，推荐观看他在 Youtube 上的自述视频<a href=\"https://www.youtube.com/watch?v=zA9krklwADI\" target=\"_blank\" rel=\"noopener noreferrer\">《My Struggles &amp; Success》</a>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231830686.png\" alt=\"My Struggles &amp; Success\" tabindex=\"0\"><figcaption>My Struggles &amp; Success</figcaption></figure>\n<p>我粗略浏览了<a href=\"https://www.youtube.com/c/TraversyMedia/videos\" target=\"_blank\" rel=\"noopener noreferrer\">Brad Traversy 在 Youtube 上的所有视频</a>，10 年总计输出 800+视频，平均每年 80+。第一个视频提交于 2010 年 8 月，刚开始几年几乎没有订阅量，2017 年 1 月订阅量才到 50k，这中间差不多隔了 6 年。2017.10 月订阅量猛增到 200k，2018 年 3 月订阅量到 300k。当前 2021.1 月，订阅量达到 138 万。可以认为从 2017 开始，也就是在积累了 6 ～ 7 年后，他的订阅量开始出现拐点。<strong>如果把这些数据画出来，将会是一条非常漂亮的复利曲线</strong>。</p>\n<h3>2.4 案例小结</h3>\n<p>Brendan Gregg，Jay Kreps 和 Brad Traversy 三个人走的技术路线各不相同，但是他们的成功具有共性或者说模式：</p>\n<p><strong>1、找到了适合自己的长期战略目标。</strong></p>\n<ul>\n<li>Brendan Gregg: 成为系统性能领域顶级专家</li>\n<li>Jay Kreps：开创基于 Kafka 开源消息队列的企业服务公司，并将公司做到上市</li>\n<li>Brad Traversy: 成为技术媒体领域大 V 和课程讲师，并以此作为自己的职业</li>\n</ul>\n<p><strong>2、专注深耕一个(或有限几个相关的)细分领域(Niche)，保持定力，不随便切换领域。</strong></p>\n<ul>\n<li>Brendan Gregg：系统性能领域</li>\n<li>Jay Kreps: 消息中间件/实时计算领域+创业</li>\n<li>Brad Traversy: 技术媒体/教学领域，方向 Web 开发 + 编程语言</li>\n</ul>\n<p><strong>3、长期投入，三人都持续投入了 10 年。</strong></p>\n<p><strong>4、年度细分计划+持续可量化的价值产出(Persistent &amp; Measurable Value Output)。</strong></p>\n<ul>\n<li>Brendan Gregg：除公司日常工作产出以外，每年有超过 10 份以上的技术文档和演讲视频产出，平均每年有 2.5 个开源工具产出。十年共产出书籍 2 本，其中《System Performance》已经更新到第二版。</li>\n<li>Jay Kreps：总体有开源产品+公司产出，1 本书产出，每年有 Kafka 和周边产品发版若干。</li>\n<li>Brad Traversy: 每年有 Youtube 免费视频产出（平均每年 80+）+Udemy 收费视频课产出(平均每年 1.5 门)。</li>\n</ul>\n<p><strong>5、以终为始是牛人和普通人的一大区别。</strong></p>\n<p>普通人通常走一步算一步，很少长远规划。牛人通 常是先有远大目标，然后采用倒推法，将大目标细化到每年/月/周的详细落地计划。Brendan Gregg，Jay Kreps 和 Brad Traversy 三人都是以终为始的典型。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231833871.png\" alt=\"以终为始\" tabindex=\"0\"><figcaption>以终为始</figcaption></figure>\n<p>上面总结了几位技术大牛的成长模式，其中一个重点就是：这些大牛的成长都是通过 <strong>持续有价值产出(Persistent Valuable Output)</strong> 来驱动的。持续产出为啥如此重要，这个还要从下面的学习金字塔说起。</p>\n<h2>三、学习金字塔和刻意训练</h2>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231836811.png\" alt=\"学习金字塔\" tabindex=\"0\"><figcaption>学习金字塔</figcaption></figure>\n<p>学习金字塔是美国缅因州国家训练实验室的研究成果，它认为：</p>\n<blockquote>\n<ol>\n<li>我们平时上课听讲之后，学习内容平均留存率大致只有 5%左右；</li>\n<li>书本阅读的平均留存率大致只有 10%左右；</li>\n<li>学习配上视听效果的课程，平均留存率大致在 20%左右；</li>\n<li>老师实际动手做实验演示后的平均留存率大致在 30%左右；</li>\n<li>小组讨论(尤其是辩论后)的平均留存率可以达到 50%左右；</li>\n<li>在实践中实际应用所学之后，平均留存率可以达到 75%左右；</li>\n<li>在实践的基础上，再把所学梳理出来，转而再传授给他人后，平均留存率可以达到 90%左右。</li>\n</ol>\n</blockquote>\n<p>上面列出的 7 种学习方法，前四种称为 <strong>被动学习</strong> ，后三种称为 <strong>主动学习</strong>。</p>\n<p>拿学游泳做个类比，被动学习相当于你看别人游泳，而主动学习则是你自己要下水去游。我们知道游泳或者跑步之类的运动是要燃烧身体卡路里的，这样才能达到锻炼身体和长肌肉的效果(肌肉是卡路里燃烧的结果)。如果你只是看别人游泳，自己不实际去游，是不会长肌肉的。同样的，主动学习也是要燃烧脑部卡路里的，这样才能达到训练大脑和长脑部“肌肉”的效果。</p>\n<p>我们也知道，燃烧身体的卡路里，通常会让人感觉不舒适，如果燃烧身体卡路里会让人感觉舒适的话，估计这个世界上应该不会有胖子这类人。同样，燃烧脑部卡路里也会让人感觉不适、紧张、出汗或语无伦次，如果燃烧脑部卡路里会让人感觉舒适的话，估计这个世界上人人都很聪明，人人都能发挥最大潜能。当然，这些不舒适是短期的，长期会使你更健康和聪明。波波一直认为， <strong>人与人之间的先天身体其实都差不多，但是后天身体素质和能力有差异，这些差异，很大程度是由后天对身体和大脑的训练质量、频度和强度所造成的。</strong></p>\n<p>明白这个道理之后，心智成熟和自律的人就会对自己进行持续地 <strong>刻意训练</strong> 。这个刻意训练包括对身体的训练，比如波波现在每天坚持跑步 3km，走 3km，每天做 60 个仰卧起坐，5 分钟平板撑等等，每天保持让身体燃烧一定量的卡路里。刻意训练也包括对大脑的训练，比如波波现在每天做项目写代码 coding(训练脑+手)，平均每天在 B 站上输出十分钟免费视频(训练脑+口头表达)，另外有定期总结输出公众号文章(训练脑+文字表达)，还有每天打半小时左右的平衡球(下图)或古墓丽影游戏(训练小脑+手)，每天保持让大脑燃烧一定量的卡路里，并保持一定强度(适度不适感)。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231839985.png\" alt=\"平衡球游戏\" tabindex=\"0\"><figcaption>平衡球游戏</figcaption></figure>\n<p>关于刻意训练的专业原理和方法论，推荐看书籍《刻意练习》。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231842735.png\" alt=\"刻意练习\" tabindex=\"0\"><figcaption>刻意练习</figcaption></figure>\n<p>注意，如果你平时从来不做举重锻炼的，那么某天突然做举重会很不适应甚至受伤。脑部训练也是一样的，如果你从来没有做过视频输出，那么刚开始做会很不适应，做出来的视频质量会很差。不过没有关系，任何训练都是一个循序渐进，不断强化的过程。等大脑相关区域的\"肌肉\"长出来以后，会逐步进入正循环，后面会越来越顺畅，相关\"肌肉\"会越来越发达。所以，和健身一样，健脑也不能遇到困难就放弃，需要循序渐进(Incremental)+持续地(Persistent)刻意训练。</p>\n<p>理解了学习金字塔和刻意训练以后，现在再来看 Brendan Gregg，Jay Kreps 和 Brad Traversy 这些大牛的做法，他们的学习成长都是建立在持续有价值产出的基础上的，这些产出都是刻意训练+燃烧脑部卡路里的成果。他们的产出要么是建立在实践基础上的产出，例如 Jay Kreps 的 Kafka 开源项目和 Confluent 公司；要么是在实践的基础上，再整理传授给其他人的产出，例如，Brendan Greeg 的技术演讲 ppt/视频，书籍，还有 Brad Traversy 的教学视频等等。换句话说，他们一直在学习金字塔的 5 ～ 7 层主动和高效地学习。并且，他们的学习产出还可以获得用户使用，有客户价值(Customer Value)，有用户就有反馈和度量。记住，有反馈和度量的学习，也称闭环学习，它是能够不断改进提升的；反之，没有反馈和度量的学习，无法改进提升。</p>\n<p>现在，你也应该明白，晒个书单秀个技能图谱很简单，读个书上个课也不难。但是要你给出 5 ～ 10 年的总体技术成长战略，再基于这个战略给出每年的细分落地计划(尤其是产出计划)，然后再严格按计划执行，这的确是很难的事情。这需要大量的实践训练+深度思考，要燃烧大量的脑部卡路里！但这是上天设置的进化法则，成长为真正的技术大牛如同成长为一流的运动员，是需要通过燃烧与之相匹配量的卡路里来交换的。成长为真正的技术大牛，也是需要通过产出与之匹配的社会价值来交换的，只有这样社会才能正常进化。你推进了社会进化，社会才会回馈你。如果不是这样，社会就无法正常进化。</p>\n<h2>四、战略思维的诞生</h2>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc87167f53b243d49f9f4e8c7fe530a1~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"思考周期和机会点\" tabindex=\"0\"><figcaption>思考周期和机会点</figcaption></figure>\n<p>一般毕业生刚进入企业工作的时候，思考大都是以天/星期/月为单位的，基本上都是今天学个什么技术，明天学个什么语言，很少会去思考一年甚至更长的目标。这是个眼前漆黑看不到的懵懂时期，捕捉到机会点的能力和概率都非常小。</p>\n<p>工作了三年以后，悟性好的人通常会以一年为思考周期，制定和实施一些年度计划。这个时期是相信天赋和比拼能力的阶段，可以捕捉到一些小机会。</p>\n<p>工作了五年以后，一些悟性好的人会产生出一定的胆识和眼光，他们会以 3 ～ 5 年为周期来制定和实施计划，开始主动布局去捕捉一些中型机会点。</p>\n<p>工作了十年以后，悟性高的人会看到模式和规则变化，例如看出行业发展模式，还有人才的成长模式等，于是开始诞生出战略性思维。然后他们会以 5 ～ 10 年为周期来制定和实施自己的战略计划，开始主动布局去捕捉一些中大机会点。Brendan Gregg，Jay Kreps 和 Brad Traversy 都是属于这个阶段的人。</p>\n<p>当然还有很少一些更牛的时代精英，他们能够看透时代和人性，他们的思考是以一生甚至更长时间为单位的，这些超人不在本文讨论范围内。</p>\n<h2>五、建议</h2>\n<p><strong>1、以 5 ～ 10 年为周期去布局谋划你的战略。</strong></p>\n<p>现在大学生毕业的年龄一般在 22 ～ 23 岁，那么在工作了十年后，也就是在你 32 ～ 33 岁的时候，你也差不多看了十年了，应该对自己和周围的世界(你的行业和领域)有一个比较深刻的领悟了。<strong>如果你到这个年纪还懵懵懂懂，今天抓东明天抓西，那么只能说你的胆识格局是相当的低</strong>。在当前 IT 行业竞争这么激烈的情况下，到 35 岁被下岗可能就在眼前了。</p>\n<p>有了战略性思考，你应该以 5 ～ 10 年为周期去布局谋划你的战略。以 Brendan Gregg，Jay Kreps 和 Brad Traversy 这些大牛为例，<strong>人生若真的要干点成就出来，投入周期一般都要十年的</strong>。从 33 岁开始，你大致有 3 个十年，因为到 60 岁以后，一般人都老眼昏花干不了大事了。如果你悟性差一点，到 40 岁才开始规划，那么你大致还有 2 个十年。如果你规划好了，这 2 ～ 3 个十年可以成就不小的事业。否则，你很可能一生都成就不了什么事业，或者一直在帮助别人成就别人的事业。</p>\n<p><strong>2、专注自己的精力。</strong></p>\n<p>考虑到人生能干事业的时间也就是 2 ～ 3 个十年，你会发现人生其实很短暂，这时候你会把精力都投入到实现你的十年战略上去，没有时间再浪费在比如网上的闲聊和扯皮争论上去。</p>\n<p><strong>3、细分落地计划尤其是产出计划。</strong></p>\n<p>有了十年战略方向，下一步是每年的细分落地计划，尤其是产出计划。这些计划主要应该工作在学习金字塔的 5/6/7 层。<strong>产出应该是刻意训练+燃烧卡路里的结果，每天让身体和大脑都保持燃烧一定量的卡路里</strong>。</p>\n<p><strong>4、产出有价值的东西形成正反馈。</strong></p>\n<p>产出应该有客户价值，自己能学习(自己成长进化)，对别人还有用(推动社会成长进化)，这样可以得到<strong>用户回馈和度量</strong>，形成一个闭环，可以持续改进和提升你的学习。</p>\n<p><strong>5、少即是多。</strong></p>\n<p>深耕一个(或有限几个相关的)领域。所有细分计划应该紧密围绕你的战略展开。克制内心欲望，不要贪多和分心，不要被喧嚣的世界所迷惑。</p>\n<p><strong>6、战略方向+细分计划都要写下来，定期 review 优化。</strong></p>\n<p><strong>7、要有定力，持续努力。</strong></p>\n<p>曲则全、枉则直，战略实现是不可能直线的。战略方向和细分计划通常要按需调整，尤其在早期，但是最终要收敛。如果老是变不收敛，就是缺乏战略定力，是个必须思考和解决的大问题。</p>\n<p>别人的成长战略可以参考，但是不要刻意去模仿，你有你自己的颜色，<strong>你应该成为独一无二的你</strong>。</p>\n<p>战略方向和细分计划明确了，接下来就是按部就班执行，十年如一日铁打不动。</p>\n<p><strong>8、慢就是快。</strong></p>\n<p>战略目标的实现也和种树一样是生长出来的，需要时间耐心栽培，记住**慢就是快。**焦虑纠结的时候，像念经一样默念王阳明《传习录》中的教诲：</p>\n<blockquote>\n<p>立志用功，如种树然。方其根芽，犹未有干；及其有干，尚未有枝；枝而后叶，叶而后花实。初种根时，只管栽培灌溉。勿作枝想，勿作花想，勿作实想。悬想何益？但不忘栽培之功，怕没有枝叶花实？</p>\n<p>译文：</p>\n<p>实现战略目标，就像种树一样。刚开始只是一个小根芽，树干还没有长出来；树干长出来了，枝叶才能慢慢长出来；树枝长出来，然后才能开花和结果。刚开始种树的时候，只管栽培灌溉，别老是纠结枝什么时候长出来，花什么时候开，果实什么时候结出来。纠结有什么好处呢？只要你坚持投入栽培，还怕没有枝叶花实吗？</p>\n</blockquote>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/863dbfa7d8f64123a41cbc1406aa0c46~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"悬想何益\" tabindex=\"0\"><figcaption>悬想何益</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/cdb11ce2f1c3a69fd19e922a7f5f59bf.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "波波微课"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "工作五年之后，对技术和业务的思考",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work.html",
      "summary": "推荐语：这是我在两年前看到的一篇对我触动比较深的文章。确实要学会适应变化，并积累能力。积累解决问题的能力，优化思考方式，拓宽自己的认知。 原文地址： https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA 苦海无边，回头无岸。 01 前言 晃晃悠悠的，在互联网行业工作了五年，默然回首，你看哪里像灯火阑珊处？ ...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：这是我在两年前看到的一篇对我触动比较深的文章。确实要学会适应变化，并积累能力。积累解决问题的能力，优化思考方式，拓宽自己的认知。</p>\n<br>\n<p><strong>原文地址：</strong> <a href=\"https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA</a></p>\n</blockquote>\n<p>苦海无边，回头无岸。</p>\n<h2>01 前言</h2>\n<p>晃晃悠悠的，在互联网行业工作了五年，默然回首，你看哪里像灯火阑珊处？</p>\n<p>初入职场，大部分程序员会觉得苦学技术，以后会顺风顺水升职加薪，这样的想法没有错，但是不算全面，五年后你会不会继续做技术写代码这是核心问题。</p>\n<p>初入职场，会觉得努力加班可以不断提升能力，可以学到技术的公司就算薪水低点也可以接受，但是五年之后会认为加班都是在不断挤压自己的上升空间，薪水低是人生的天花板。</p>\n<p>这里想说的关键问题就是：初入职场的认知和想法大部分不会再适用于五年后的认知。</p>\n<p>工作五年之后面临的最大压力就是选择：职场天花板，技术能力天花板，薪水天花板，三十岁天花板。</p>\n<p>如何面对这些问题，是大部分程序员都在思考和纠结的。做选择的唯一参考点就是：利益最大化，这里可以理解为职场更好的升职加薪，顺风顺水。</p>\n<p>五年，变化最大不是工作经验，能力积累，而是心态，清楚的知道现实和理想之间是存在巨大的差距。</p>\n<h2>02 学会适应变化，并积累能力</h2>\n<p>回首自己的职场五年，最认可的一句话就是：学会适应变化，并积累能力。</p>\n<p>变化的就是，五年的时间技术框架更新迭代，开发工具的变迁，公司环境队友的更换，甚至是不同城市的流浪，想着能把肉体和灵魂安放在一处，有句很经典的话就是：唯一不变的就是变化本身。</p>\n<p>要积累的是：解决问题的能力，思考方式，拓宽认知。</p>\n<p>这种很难直白的描述，属于个人认知的范畴，不同的人有不一样的看法，所以只能站在大众化的角度去思考。</p>\n<p>首先聊聊技术，大部分小白级别的，都希望自己的技术能力不断提高，争取做到架构师级别，但是站在当前的互联网环境中，这种想法实现难度还是偏高，这里既不是打击也不是为了抬杠。</p>\n<p>可以观察一下现状，技术团队大的20-30人，小的10-15人，能有一个架构师去专门管理底层框架都是少有现象。</p>\n<p>这个问题的原因很多，首先架构师的成本过高，环境架构也不是需要经常升级，说的难听点可能框架比项目生命周期更高。</p>\n<p>所以大部分公司的大部分业务，基于现有大部分成熟的开源框架都可以解决，这也就导致架构师这个角色通常由项目主管代替或者级别较高的开发直接负责，这就是现实情况。</p>\n<p>这就导致技术框架的选择思路就是：只选对的。即这方面的人才多，开源解决方案多，以此降低技术方面对公司业务发展的影响。</p>\n<p>那为什么还要不断学习和积累技术能力？如果没有这个能力，程序员岗位可能根本走不了五年之久，需要用技术深度积累不断解决工作中的各种问题，用技术的广度提升自己实现业务需求的认知边界，这是安放肉体的根本保障。</p>\n<p>这就是导致很多五年以后的程序员压力陡然升高的原因，走向管理岗的另一个壁垒就是业务思维和认知。</p>\n<h2>03 提高业务能力的积累</h2>\n<p>程序员该不该用心研究业务，这个问题真的没有纠结的必要，只要不是纯技术型的公司，都需要面对业务。</p>\n<p>不管技术、运营、产品、管理层，都是在面向业务工作。</p>\n<p>从自己职场轨迹来看，五年变化最大就是解决业务问题的能力，职场之初面对很多业务场景都不知道如何下手，到几年之后设计业务的解决方案。</p>\n<p>这是大部分程序员在职场前五年跳槽就能涨薪的根本原因，面对业务场景，基于积累的经验和现有的开源工具，能快速给出合理的解决思路和实现过程。</p>\n<p>工作五年可能对技术底层的清晰程度都没有初入职场的小白清楚，但是写的程序却可以避开很多坑坑洼洼，对于业务的审视也是很细节全面。</p>\n<p>解决业务能力的积累，对于技术视野的宽度需求更甚，比如职场初期对于海量数据的处理束手无策，但是在工作几年之后见识数据行业的技术栈，真的就是技术选型的视野问题。</p>\n<p>什么是衡量技术能力的标准？站在一个共识的角度上看：系统的架构与代码设计能适应业务的不断变化和各种需求。</p>\n<p>相对比与技术，业务的变化更加快速频繁，高级工程师或者架构师之所以薪资高，这些角色一方面能适应业务的迭代，并且在工作中具有一定前瞻性，会考虑业务变化的情况下代码复用逻辑，这样的能力是需要一定的技术视野和业务思维的沉淀。</p>\n<p>所以职场中：业务能说的井井有条，代码能写的明明白白，得到机会的可能性更大。</p>\n<h2>04 不同的阶段技术和业务的平衡和选择</h2>\n<p>从理性的角度看技术和业务两个方面，能让大部分人职场走的平稳顺利，但是不同的阶段对两者的平衡和选择是不一样的。</p>\n<p>在思考如何选择的时候，可以参考二八原则的逻辑，即在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的，因此又称二八定律。</p>\n<p>个人真的非常喜欢这个原则，大部分人都不是天才，所以很难三心二意同时做好几件事情，在同一时间段内应该集中精力做好一件事件。</p>\n<p>但是单纯的二八原则模式可能不适应大部分职场初期的人，因为初期要学习很多内容，如何在职场生存：专业能力，职场关系，为人处世，产品设计等等。</p>\n<p>当然这些东西不是都要用心刻意学习，但是合理安排二二六原则或其他组合是更明智的，首先是专业能力要重点练习，其次可以根据自己的兴趣合理选择一到两个方面去慢慢了解，例如产品，运营，运维，数据等，毕竟三五年以后会不会继续写代码很难说，多给自己留个机会总是有备无患。</p>\n<p>在职场初期，基本都是从技术角度去思考问题，如何快速提升自己的编码能力，在公司能稳定是首要目标，因此大部分时间都是在做基础编码和学习规范，这时可能90%的心思都是放在基础编码上，另外10%会学习环境架构。</p>\n<p>最多一到两年，就会开始独立负责模块需求开发，需要自己设计整个代码思路，这里业务就会进入视野，要懂得业务上下游关联关系，学会思考如何设计代码结构，才能在需求变动的情况下代码改动较少，这个时候可能就会放20%的心思在业务方面，30%学习架构方式。</p>\n<p>三到五年这个时间段，是解决问题能力提升最快的时候，因为这个阶段的程序员基本都是在开发核心业务链路，例如交易、支付、结算、智能商业等模块，需要对业务整体有较清晰的把握能力，不然就是给自己挖坑，这个阶段要对业务流付出大量心血思考。</p>\n<p>越是核心的业务线，越是容易爆发各种问题，如果在日常工作中不花心思处理各种细节问题，半夜异常自动的消息和邮件总是容易让人憔悴。</p>\n<p>所以努力学习技术是提升自己，培养自己的业务认知也同样重要，个人认为这二者的分量平分秋色，只是需要在合适的阶段做出合理的权重划分。</p>\n<h2>05 学会在职场做选择和生存</h2>\n<p>基于技术能力和业务思维，学会在职场做选择和生存，这些是职场前五年一路走来的最大体会。</p>\n<p>不管是技术还是业务，这两个概念依旧是个很大的命题，不容易把握，所以学会理清这两个方面能力中的公共模块是关键。</p>\n<p>不管技术还是业务，都不可能从一家公司完全复制到另一家公司，但是可以把一家公司的技术框架，业务解决方案学会，并且带到另一家公司，例如技术领域内的架构、设计、流程、数据管理，业务领域内的思考方式、产品逻辑、分析等，这些是核心能力并且是大部分公司人才招聘的要求，所以这些才是工作中需要重点积累的。</p>\n<p>人的精力是有限的，而且面对三十这个天花板，各种事件也会接连而至，在职场中学会合理安排时间并不断提升核心能力，这样才能保证自己的竞争力。</p>\n<p>职场就像苦海无边，回首望去可能也没有岸边停泊，但是要具有换船的能力或者有个小木筏也就大差不差了。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "知了一笑"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "如何在技术初试中考察程序员的技术能力",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology.html",
      "summary": "推荐语：从面试官和面试者两个角度探讨了技术面试！非常不错！ 内容概览： 实战与理论结合。比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题? 项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。一般来说，会让候选人...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：从面试官和面试者两个角度探讨了技术面试！非常不错！</p>\n<br>\n<p><strong>内容概览：</strong></p>\n<ul>\n<li>实战与理论结合。比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题?</li>\n<li>项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障等。</li>\n<li>多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。</li>\n</ul>\n<br>\n<p><strong>原文地址</strong>：https://www.cnblogs.com/lovesqcc/p/15169365.html</p>\n</blockquote>\n<h2>灵魂三连问</h2>\n<ol>\n<li>你觉得人怎么样？ 【表达能力、沟通能力、学习能力、总结能力、自省改进能力、抗压能力、情绪管理能力、影响力、团队管理能力】</li>\n<li>如果让他独立完成项目的设计和实现，你觉得他能胜任吗？ 【系统设计能力、项目管理能力】</li>\n<li>他的分析和解决问题的能力，你的评价是啥？【原理理解能力、实战应用能力】</li>\n</ol>\n<h2>考察目标和思路</h2>\n<p>首先明确，技术初试的考察目标：</p>\n<ul>\n<li>候选人的技术基础；</li>\n<li>候选人解决问题的思路和能力。</li>\n</ul>\n<p>技术基础是基石（冰山之下的东西），占七分， 解决问题的思路和能力是落地（冰山之上露出的部分），占三分。 业务和技术基础考察，三七开。</p>\n<p>核心考察目标：分析和解决问题的能力。</p>\n<p>技术层面：深度 + 应用能力 + 广度。 对于校招或社招 P6 级别以下，要多注重 深度 + 应用能力，广度是加分项； 在 P6 之上，可增加 广度。</p>\n<ul>\n<li>校招：基础扎实，思维敏捷。 主要考察内容：基础数据结构与算法、进程与并发、内存管理、系统调用与 IO 机制、网络协议、数据库范式与设计、设计模式、设计原则、编程习惯；</li>\n<li>社招：经验丰富，里外兼修。 主要考察内容：有一定深度的基础技术机制，比如 Java 内存模型及内存泄露、 JVM 机制、类加载机制、数据库索引及查询优化、缓存、消息中间件、项目、架构设计、工程规范等。</li>\n</ul>\n<h3>技术基础是什么?</h3>\n<p>作为技术初试官，怎么去考察技术基础？究竟什么是技术基础？是知道什么，还是知道如何思考？知识作为现有的成熟原理体系，构成了基础的重要组成部分，而知道如何思考亦尤为重要。俗话说，知其然而知其所以然。知其然，是指熟悉现有知识体系，知其所以然，则是自底向上推导，真正理解知识的来龙去脉，理解为何是这样而不是那样。毕竟，对于本质是逻辑的程序世界而言，并无定法。知道如何思考，并能缜密地设计和开发，深入到细节，这就是技术基础吧。</p>\n<h3>为什么要考察技术基础?</h3>\n<p>程序员最重要的两种技术思维能力，是逻辑思维能力和抽象设计能力。逻辑思维能力是基础，抽象设计能力是高阶。 考察技术基础，正好可以同时考察这两种思维能力。能不能理解基础技术概念及关联，是考察逻辑思维能力；能不能把业务问题抽象成技术问题并合理的组织映射，是考察抽象设计能力。</p>\n<p>绝大部分业务问题，都可以抽象成技术问题。在某种意义上，业务问题只是技术问题的领域化表述。</p>\n<p>因此，通过技术基础考察候选者，才能考察到候选者的真实技术实力：技术深度和广度。</p>\n<h3>为什么不能单考察业务维度？</h3>\n<p>因为业务方面通常比较熟悉，可能就直接按照现有方案说出来了，很难考察到候选人的深入理解、横向拓展和归纳总结能力。</p>\n<p>这一点，建议有针对性地考察下候选人的归纳总结能力：比如， 微服务搭建或开发或维护/保证系统稳定性或性能方面的过程中，你收获了哪些可以分享的经验？</p>\n<h3>为什么要考察业务维度？</h3>\n<p>技术基础考察，容易错过的地方是，候选人的非技术能力特质，比如沟通组织能力、带项目能力、抗压能力、解决实际问题的能力、团队影响力、其它性格特质等。</p>\n<h2>考察方法</h2>\n<h3>技术基础考察</h3>\n<p>技术基础怎么考察？通过有效的多角度的发问模式来考察。</p>\n<p><strong>是什么-为什么</strong></p>\n<p>是什么考察对概念的基本理解，为什么考察对概念的实现原理。</p>\n<p>比如索引是什么？ 索引是如何实现的？</p>\n<p><strong>引导-横向发问-深入发问</strong></p>\n<p>引导性，比如 “你对 java 同步工具熟悉吗？” 作个试探，得到肯定答复后，可以进一步问：“你熟悉哪些同步工具类？” 了解候选者的广度；</p>\n<p>获取候选者的回答后，可以进一步问：“ 谈谈 ConcurrentHashMap 或 AQS 的实现原理？”</p>\n<p>一个人在多大程度上把技术原理能讲得清晰，包括思路和细节，说明他对技术的掌握能力有多强。</p>\n<p><strong>深度有梯度和层次的发问</strong></p>\n<p>设置三个深度层次的发问。每个深度层次可以对应到某个技术深度。</p>\n<ul>\n<li>第一个发问是基本概念层次，考察候选人对概念的理解能力和深度；</li>\n<li>第二个发问是原理机制层次，考察候选人对概念的内涵和外延的理解深度；</li>\n<li>第三个发问是应用层次，考察候选人的应用能力和思维敏捷程度。</li>\n</ul>\n<p><strong>跳跃式/交叉式发问</strong></p>\n<p>比如，讲到哈希高效查找，可以谈谈哈希一致性算法 。 两者既有关联又有很多不同点。也是一种技术广度的考察方法。</p>\n<p><strong>总结性发问</strong></p>\n<p>比如，你在做 XXX 中，获得了哪些可以分享的经验？ 考察候选人的归纳总结能力。</p>\n<p><strong>实战与理论结合</strong></p>\n<ul>\n<li>比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题?</li>\n<li>比如，候选人有谈到 SQL 优化和索引优化，那就正好谈谈索引的实现原理，如何建立最佳索引？</li>\n<li>比如，候选人有谈到事务，那就正好谈谈事务实现原理，隔离级别，快照实现等；</li>\n</ul>\n<p><strong>熟悉与不熟悉结合</strong></p>\n<p>针对候选人简历上写的熟悉的部分，和没有写出的都问下。比如候选人简历上写着：熟悉 JVM 内存模型， 那我就考察下内存管理相关（熟悉部分），再考察下 Java 并发工具类（不确定是否熟悉部分）。</p>\n<p><strong>死知识与活知识结合</strong></p>\n<p>比如，查找算法有哪些？顺序查找、二分查找、哈希查找。这些大家通常能说出来，也是“死知识”。</p>\n<p>这些查找算法各适用于什么场景？在你工作中，有哪些场景用到了哪些查找算法？为什么？ 这些是“活知识”。</p>\n<p><strong>学习或工作中遇到的</strong></p>\n<p>有时，在学习和工作中遇到的问题，也可以作为面试题。</p>\n<p>比如，最近在学习《操作系统导论》并发部分，有一章节是如何使数据结构成为线程安全的。这里就有一些可以提问的地方：如何实现一个锁？如何实现一个线程安全的计数器？如何实现一个线程安全的链表？如何实现一个线程安全的 Map ？如何提升并发的性能？</p>\n<p>工作中遇到的问题，也可以抽象提炼出来，作为技术基础面试题。</p>\n<p><strong>技术栈适配度发问</strong></p>\n<p>如果候选人（简历上所写的）使用的某些技术与本公司的技术栈比较契合，则可以针对这些技术点进行深入提问，考察候选人在这些技术点的掌握程度。如果掌握程度比较好，则技术适配度相对更高一些。</p>\n<p>当然，这一点并不能作为筛掉那些没有使用该技术栈的候选人的依据。比如本公司使用 MongoDB 和 MySQL， 而一个候选人没有用过 Mongodb， 但使用过 MySQL, Redis, ES, HBase 等多种存储系统，那么适配度并不比仅使用过 MySQL 和 Mongodb 的候选人逊色，因为他所涉及的技术广度更大，可以推断出他有足够能力掌握 Mongodb。</p>\n<p><strong>应对背题式面试</strong></p>\n<p>首先，背题式面试，说明候选人至少是有做准备的。当然，对于招聘的一方来说，更希望找到有能力而不是仅记忆了知识的候选人。</p>\n<p>应对背题式面试，可以通过 “引导-横向发问-深入发问” 的方式，先对候选人关于某个知识点的深度和广度做一个了解，然后出一道实际应用题来考察他是否能灵活使用知识。</p>\n<p>比如 Java 线程同步机制，可以出一道题：线程 A 执行了一段代码，然后创建了一个异步任务在线程 B 中执行，线程 A 需要等待线程 B 执行完成后才能继续执行，请问怎么实现？</p>\n<p>”理论 + 应用题“的模式。敌知我之变，而不知我变之形。变之形，不计其数。</p>\n<p><strong>实用不生僻</strong></p>\n<p>考察工作中频繁用到的知识、技能和能力，不考察冷僻的知识。</p>\n<p>比如我偏向考察数据结构与算法、并发、设计 这三类。因为这三类非常基础非常核心。</p>\n<p><strong>综合串联式发问</strong></p>\n<p>知识之间总是相互联系着的，不要单独考察一个知识点。</p>\n<p>设计一个初始问题，比如说查找算法，然后从这个初始问题出发，串联起各个知识点。比如：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/open-source-project/502996-20220211115505399-72788909.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在每一个技术点上，都可以应用以上发问技巧，导向不同的问题分支。同时考察面试者的深度、广度和应用能力。</p>\n<p><strong>创造有个性的面试题库</strong></p>\n<p>每个技术面试官都会有一个面试题库。持续积累面试题库，日常中突然想到的问题，就随手记录下来。</p>\n<h3>解决问题能力考察</h3>\n<p>仅仅只是技术基础还不够，通常最好结合实际业务，针对他项目里的业务，抽象出技术问题进行考察。</p>\n<p>解决思路重在层层递进。这一点对于面试官的要求也比较高，兼具良好的倾听能力、技术深度和业务经验。首先要仔细倾听候选人的阐述，找到适当的技术切入点，然后进行发问。如果进不去，那就容易考察失败。\n常见问题：</p>\n<ul>\n<li>性能方面，qps, tps 多少？采用了什么优化措施，达成了什么效果？</li>\n<li>如果有大数据量，如何处理？如何保证稳定性？</li>\n<li>你觉得这个功能/模块/系统的关键点在哪里？有什么解决方案？</li>\n<li>为什么使用 XXX 而不是 YYY ？</li>\n<li>长字段如何做索引？</li>\n<li>还有哪些方案或思路？各自的利弊？</li>\n<li>第三方对接，如何应对外部接口的不稳定性？</li>\n<li>第三方对接，对接大量外部系统，代码可维护性？</li>\n<li>资损场景？严重故障场景？</li>\n<li>线上出现了 CPU 飙高，如何处理？ OOM 如何处理？ IO 读写尖刺，如何排查？</li>\n<li>线上运行过程中，出现过哪些问题？如何解决的？</li>\n<li>多个子系统之间的数据一致性问题？</li>\n<li>如果需要新增一个 XXX 需求，如何扩展？</li>\n<li>重来一遍，你觉得可以在哪些方面改进？</li>\n</ul>\n<p>系统可问的关联问题：</p>\n<ul>\n<li>绝大多数系统都有性能相关问题。如果没有性能问题，则说明是小系统，小系统就不值得考察了；</li>\n<li>中大型系统通常有技术选型问题；</li>\n<li>绝大多数系统都有改进空间；</li>\n<li>大多数业务系统都涉及可扩展性问题和可维护性问题；</li>\n<li>大多数重要业务系统都经历过比较惨重的线上教训；</li>\n<li>大数据量系统必定有稳定性问题；</li>\n<li>消费系统必定有时延和堆积问题；</li>\n<li>第三方系统对接必定涉及可靠性问题；</li>\n<li>分布式系统必定涉及可用性问题；</li>\n<li>多个子系统协同必定涉及数据一致性问题；</li>\n<li>交易系统有资损和故障场景；</li>\n</ul>\n<p><strong>设计问题</strong></p>\n<ul>\n<li>比如多个机器间共享大量业务对象，这些业务对象之间有些联合字段是重复的，如何去重？ 如果字段比较长，怎么处理？</li>\n<li>如果瞬时有大量请求涌入，如何保证服务器的稳定性？</li>\n<li>组件级别：设计一个本地缓存？ 设计一个分布式缓存？</li>\n<li>模块级别：设计一个任务调度模块？需要考虑什么因素？</li>\n<li>系统级别：设计一个内部系统，从各个部门获取销售数据然后统计出报表。复杂性体现在哪里？关键质量属性是哪些？模块划分，模块之间的关联关系？技术选型？</li>\n</ul>\n<p><strong>项目经历</strong></p>\n<p>项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。</p>\n<p>一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思/感受到挫折的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障、重来一遍可以改进哪些等。</p>\n<h2>面试过程</h2>\n<h3>预先准备</h3>\n<p>面试官也需要做一些准备。比如熟悉候选者的技能优势、工作经历等，做一个面试设计。</p>\n<p>在面试将要开始时，做好面试准备。此外，面试官也需要对公司的一些基本情况有所了解，尤其是公司所使用技术栈、业务全景及方向、工作内容、晋升制度等，这一点技术型候选人问得比较多。</p>\n<h3>面试启动</h3>\n<p>一般以候选人自我介绍启动，不过候选人往往会谈得比较散，因此，我会直接提问：谈谈你有哪些优势以及自己觉得可以改进的地方？</p>\n<p>然后以一个相对简单的基础题作为技术提问的开始：你熟悉哪些查找算法？大多数人是能答上顺序查找、二分查找、哈希查找的。</p>\n<h3>问题设计</h3>\n<p>提前阅读候选人简历，从简历中筛选出关键词，根据这些关键词进行有针对性地问题设计。</p>\n<p>比如候选人简历里提到 MVVM ，可以问 MVVM 与 MVC 的区别； 提到了观察者模式，可以谈谈观察者模式，顺便问问他还熟悉哪些设计模式。</p>\n<p>可遵循“优势-标准-随机”原则：</p>\n<ul>\n<li>首先，问他对哪方面技术感兴趣、投入较多（优势部分），根据其优势部分，阐述原理及实战应用；</li>\n<li>其次，问若干标准化的问题，看看他的原理理解、实战应用如何；</li>\n<li>最后，随机选一个问题，看看他的原理理解、实战应用如何；</li>\n</ul>\n<p>对于项目同样可以如此：</p>\n<ul>\n<li>首先，问他最有成就感的项目，技术栈、模块及关联、技术选型、设计关键问题、解决方案、实现细节、改进空间；</li>\n<li>其次，问他有挫折感的项目，问题在哪里、做过什么努力、如何改进；</li>\n</ul>\n<h3>宽松氛围</h3>\n<p>即使问的问题比较多比较难，也要注意保持宽松氛围。</p>\n<p>在面试前，根据候选人基本信息适当调侃一下，比如一位候选人叫汪奎，那我就说：之前我们团队有位叫袁奎，我们都喊他奎爷。</p>\n<p>在面试过程中，适当提示，或者给出少量自己的看法，也能缓解候选人的紧张情绪。</p>\n<h3>学会倾听</h3>\n<p>多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。</p>\n<p>引导候选人表现他最优势的一面，让他或她感觉好一些：毕竟一场面试双方都付出了时间和精力，不应该是面试官 Diss 候选人的场合，而应该让彼此有更好的交流。很大可能，你也能从候选人那里学到不少东西。</p>\n<p>面试这件事，只不过双方的角色和立场有所不同，但并不代表面试官的水平就一定高于候选人。</p>\n<h3>记录重点</h3>\n<p>认真客观地记录候选人的回答，尽可能避免任何主观评价，亦不作任何加工（比如自己给总结一下，总结能力也是候选人的一个特质）。</p>\n<h3>多练习</h3>\n<p>模拟面试。</p>\n<h3>作出判断</h3>\n<p>面试过程是一种铺垫，关键的是作出判断。</p>\n<p>作出判断最容易陷入误区的是：贪深求全。总希望候选人技术又深入又全面。实际上，这是一种奢望。如果候选人的技术能力又深入又全面，很可能也会面临两种情况：1. 候选人有更好的选择； 2. 候选人在其它方面可能存在不足，比如团队协作方面。</p>\n<p>一个比较合适的尺度是：1. 他或她的技术水平能否胜任当前工作； 2. 他或她的技术水平与同组团队成员水平如何； 3. 他或她的技术水平是否与年限相对匹配，是否有潜力胜任更复杂的任务。</p>\n<h3>不同年龄看重的东西不一样</h3>\n<p>对于三年以下的工程师，应当更看重其技术基础，因为这代表着他的未来潜能；同时也考察下他在实际开发中的体现，比如团队协作、业务经验、抗压能力、主动学习的热情和能力等。</p>\n<p>对于三年以上的工程师，应当更看重其业务经验、解决问题能力，看看他或她是如何分析具体问题，在业务范畴内考察其技术基础的深度和广度。</p>\n<p>如何判断一个候选人的真实技术水平及是否适合所需，这方面，我也在学习中。</p>\n<h2>面试初上路</h2>\n<ul>\n<li>提前准备好摄像头和音频，可以用耳机测试下。</li>\n<li>提前阅读候选人简历，从中筛选关键字，准备几个基本问题。</li>\n<li>多问技术基础题，培养下面试感觉。</li>\n<li>适当深入问下原理和实现。</li>\n<li>如果候选人简历有突出的地方，就先问那个部分；如果没有，就让候选人介绍项目背景，根据项目背景及经验来提问。</li>\n<li>小量练习“连问”技巧，直到能够熟悉使用。</li>\n<li>着重考察分析和解决问题的能力，必要的话，可以出个编程题。</li>\n<li>留出时间给对方问：你有什么想问的？并告知对方三个工作日内回复面试结果。</li>\n</ul>\n<h2>高效考察</h2>\n<p>当作为技术面试官有一定熟悉度时，就需要提升面试效率。即：在更少的时间内有效考察候选人的技术深度和技术广度。可以准备一些常见的问题，作为标准化测试。</p>\n<p>比如我喜欢考察内存管理及算法、数据库索引、缓存、并发、系统设计、问题分析和思考能力等子主题。</p>\n<ul>\n<li>熟悉哪些用于查找的数据结构和算法？ 请任选一种阐述其思想以及你认为有意思的地方。</li>\n<li>如果运行到一个 Java 方法，里面创建了一个对象列表，内存是如何分配的？什么时候可能导致栈溢出？什么时候可能导致 OOM ？ 导致 OOM 的原因有哪些？如何避免？ 线上是否有遇到过 OOM ，怎么解决的？</li>\n<li>Java 分代垃圾回收算法是怎样的？ 项目里选用的垃圾回收器是怎样的？为什么选择这个回收器而不是那个？</li>\n<li>Java 并发工具有哪些？不同工具适合于什么场景？</li>\n<li><code>Atomic</code> 原子类的实现原理 ？ <code>ConcurrentHashMap</code> 的实现原理？</li>\n<li>如何实现一个可重入锁？</li>\n<li>举个项目中的例子，哪些字段使用了索引？为什么是这些字段？你觉得还有什么优化空间？如何建一个好的索引？</li>\n<li>缓存的可设置的参数有哪些？分别的影响是什么？</li>\n<li>Redis 过期策略有哪些？ 如何选择 redis 过期策略？</li>\n<li>如何实现病毒文件检测任务去重？</li>\n<li>熟悉哪些设计模式和设计原则？</li>\n<li>从 0 到 1 搭建一个模块/完整系统？你如何着手？</li>\n</ul>\n<p>如果候选人答不上，可以问：如果你来设计这样一个 XXX， 你会怎么做？</p>\n<p>时间占比大概为：技术基础（25-30 分钟） + 项目（20-25 分钟） + 候选人提问（5-10 分钟）</p>\n<h2>给候选人的话</h2>\n<p><strong>为什么候选人需要关注技术基础</strong></p>\n<p>一个常见的疑惑是：开发业务系统的大多数时候，基本不涉及数据结构与算法的设计与实现，为什么要考察 <code>HashMap</code> 的实现原理？为什么要学好数据结构与算法、操作系统、网络通信这些基础课程？</p>\n<p>现在我可以给出一个答案了：</p>\n<ul>\n<li>正如上面所述，绝大多数的业务问题，实际上最终都会映射到基础技术问题上：数据结构与算法的实现、内存管理、并发控制、网络通信等；这些是理解现代互联网大规模程序以及解决程序疑难问题的基石，—— 除非能祝福自己永远都不会遇到疑难问题，永远都只满足于编写 CRUD；</li>\n<li>这些技术基础正是程序世界里最有趣最激动人心的地方。如果对这些不感兴趣，就很难在这个领域里深入进去，不如及早转行从事其它职业，非技术的世界一直都很精彩广阔（有时我也想多出去走走，不想局限于技术世界）；</li>\n<li>技术基础是程序员的内功，而具体技术则是招式。徒有招式而内功不深，遇到高手（优秀同行从业者的竞争及疑难杂症）容易不堪一击；</li>\n<li>具备扎实的专业技术基础，能达到的上限更高，未来更有可能胜任复杂的技术问题求解，或者在同样的问题上能够做到更好的方案；</li>\n<li>人们喜欢跟与自己相似的人合作，牛人倾向于与牛人合作能得到更好的效果；如果一个团队大部分人技术基础比较好，那么进来一个技术基础比较薄弱的人，协作成本会变高；如果你想和牛人一起合作拿到更好的结果，那就要让自己至少在技术基础上能够与牛人搭配的上；</li>\n<li>在 CRUD 的基础上拓展其它才能也不失为一种好的选择，但这不会是一个真正的程序员的姿态，顶多是有技术基础的产品经理、项目经理、HR、运营、客满等其它岗位人才。这是职业选择的问题，已经超出了考察程序员的范畴。</li>\n</ul>\n<p><strong>不要在意某个问题回答不上来</strong></p>\n<p>如果面试官问你很多问题，而有些没有回答上来，不要在意。面试官很可能只是在测试你的技术深度和广度，然后判断你是否达到某个水位线。</p>\n<p>重点是：有些问题你答得很有深度，也体现了你的深度思考能力。</p>\n<p>这一点是我当了技术面试官才领会到的。当然，并不是每位技术面试官都是这么想的，但我觉得这应该是个更合适的方式。</p>\n<h2>参考资料</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/51404304\" target=\"_blank\" rel=\"noopener noreferrer\">技术面试官的 9 大误区</a></li>\n<li><a href=\"https://www.zhihu.com/question/26240321\" target=\"_blank\" rel=\"noopener noreferrer\">如何当一个好的面试官？</a></li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/open-source-project/502996-20220211115505399-72788909.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "琴水玉"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "校招进入飞书的个人经验",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/my-personal-experience-in-2021.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/my-personal-experience-in-2021.html",
      "summary": "推荐语：这篇文章的作者校招最终去了飞书做开发。在这篇文章中，他分享了自己的校招经历以及个人经验。 原文地址：https://www.ihewro.com/archives/1217/ 基本情况 我是 C++主要是后台开发的方向。 2021 春招入职字节飞书客户端，入职字节之前拿到了百度 offer（音视频直播部分） 以及腾讯 PCG （微视、后台开发）...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：这篇文章的作者校招最终去了飞书做开发。在这篇文章中，他分享了自己的校招经历以及个人经验。</p>\n<br>\n<p><strong>原文地址</strong>：https://www.ihewro.com/archives/1217/</p>\n</blockquote>\n<h2>基本情况</h2>\n<p>我是 C++主要是后台开发的方向。</p>\n<p>2021 春招入职字节飞书客户端，入职字节之前拿到了百度 offer（音视频直播部分） 以及腾讯 PCG （微视、后台开发）的 HR 面试通过（还没有收到录用意向书）。</p>\n<h2>不顺利的春招过程</h2>\n<h3>春招实习对我来说不太顺利</h3>\n<p>实验室在 1 月份元旦的那天正式可以放假回家，但回家仍然继续“远程工作”，工作并没有减少，每天日复一日的测试，调试我们开发的“流媒体会议系统”。</p>\n<p>在 1 月的倒数第三天，我们开了“年终总结”线上会议。至此，作为研二基本上与实验室的工作开始告别。也正式开始了春招复习的阶段。</p>\n<p>2 月前已经间歇性的开始准备，无非就是在 LeetCode 上面刷刷题目，一天刷不了几道，后面甚至象征性的刷一下每日一题。对我的算法刷题帮助很少。</p>\n<p>2 月份开始，2 月初的时候，LeetCode 才刷了大概 40 多道题目，挤出了几周时间更新了 handsome 主题的 8.x 版本，这又是一个繁忙的几周。直到春节的当天正式发布，春节过后又开始陆陆续续用一些时间修复 bug，发布修复版本。2 月份这样悄悄溜走。</p>\n<h3>找实习的过程</h3>\n<p><strong>2021-3 月初</strong></p>\n<p>3 月 初的时候，投了阿里提前批，没想到阿里 3 月 4 号提前批就结束了，那一天约的一面的电话面也被取消了。紧接了开学实验室开会同步进度的时候，发现大家都一面/二面/三面的进度，而我还没有投递的进度。</p>\n<p><strong>2021-3-8</strong></p>\n<p>投递了字节飞书</p>\n<p><strong>2021-4 月初</strong></p>\n<p>字节第一次一面，腾讯第一次一面</p>\n<p><strong>2021-4 中旬</strong></p>\n<p>美团一、二面，腾讯第二次一面和二面，百度三轮面试，通过了。</p>\n<p><strong>2021-4 底</strong></p>\n<p>腾讯第三次一面和字节第二次一面</p>\n<p><strong>2021-5 月初</strong></p>\n<p>腾讯第三次二面和字节第二次二面，后面这两个都通过了</p>\n<h4>阿里</h4>\n<p>第一次投了钉钉，没想到因为行测做的不好，在简历筛选给拒绝了。</p>\n<p>第二次阿里妈妈的后端面试，一面电话面试，我感觉面的还可以，最后题目也做出来了。最后反问阶段问对我的面试有什么建议，面试官说投阿里最好还是 Java 的… 然后电话结束后就给我拒了…</p>\n<p>当时真的心态有点崩，问了这个晚上 7 点半的面试，一直看书晚上都没吃…</p>\n<p>所以春招和阿里就无缘了。</p>\n<h4>美团</h4>\n<p>美团一面的面试官真的人很好。也很轻松，因为他们是 Java 岗位，也没问 c++知识，聊了一些基础知识，后面半个小时就是聊非技术问题，比如最喜欢网络上的某位程序员是谁，如何写出优雅的代码，推荐的技术类的书籍之类的。当时回答王垠是比较喜欢的程序员，面试官笑了说他也很喜欢。面试的氛围感觉很好。</p>\n<p>二面的时候全程就问简历上的一个项目，问了大概 90 分钟，感觉他从一开始就有点不太想要我的感觉，很大原因我觉的是我是 c++，转 Java 可能成本还是有一些的。最后问 HR 说结果待定，几天后通知被拒了。</p>\n<h4>百度</h4>\n<p>百度一共三轮面试，在一个下午一起进行，真的很刺激。一面就是很基础的一些 c++问题，写了一个题目说一下思路没让运行（真的要运行还不一定能运行起来:)）</p>\n<p>二面也是基础，第一个题目合并两个有序数组，第二个题目写归并排序，写的结果不对，又给我换了一个题目，树的 BFS。二面面试官最后问我对今天面试觉得怎么样，我说虽然中间有一个道题目结果不对，但是思路是对的，可能某个小地方写的有问题，但总体的应该还是可以的。二面就给我通过了。</p>\n<p>三面问的技术问题比较少，30 多分钟，也没写题目，问了一些基本情况和基础知识。最后问部门做的什么内容。面试官说后面 hr 会联系我告诉我内容。</p>\n<h4>字节飞书</h4>\n<p>第一次一面就凉了，原因应该是笔试题目结果不对…</p>\n<p>第二次一面在 4 月底了，很顺利。二面在五一劳动节后，面试官还让学姐告诉我让我多看看智能指针，面试的时候让我手写 shared_ptr，我之前看了一些实现，但是没有自己写过，导致代码考虑的不够完善，leader 就一直提醒我要怎么改怎么改。</p>\n<p>本来我以为凉了，在 5 月中旬的时候都准备去百度入职了，给我通知说过了，就这样决定去了字节。</p>\n<h4>感悟</h4>\n<p>这么多次面试中，让我感悟最深的是面试中的考察题目真的很重要，因为我在基础知识上面也不突出，再加上如果算法题（一般 1 道或者 2 道）如果没做出来，基本就凉了。而面试之前的笔试考试反而没那么重要，也没那么难。基本 4 题写出来 1~2 道题目就有发起面试的机会了。难度也基本就是 LeetCode top 100 上面的那些算法。</p>\n<p>面试中做题，我很容易紧张，头脑就容易一片空白，稍不注意，写错个符号，或者链表赋值错了，很难看出来问题，导出最终结果不对。</p>\n<h2>入职字节实习</h2>\n<p>入职字节之前我本来觉得这个岗位可能是我面试的最适合我的了，因为我主 c++，而且飞书用 c++应该挺深的。来之后就觉得我可能不太喜欢做客户端相关，感觉好复杂…也许服务端好一些，现在我仍然不能确定。</p>\n<p>字节的实习福利在这些公司中应该算是比较好的，小问题是工位比较窄，还是工作强度比其他的互联网公司大一些。字节食堂免费而且挺不错的。字节办公大厦很多，我所在的办公地点比较小。</p>\n<p>目前，需要放轻松，仓库代码慢慢看呗，mentor 也让我不急，准备有问题就多问问，不能憋着，浪费时间。拿到转正 offer 后，秋招还是想多试试外企或者国企。强度太大的工作目前很难适应。</p>\n<p>希望过段时间可以分享一下我的感受，以及能够更加适应目前的工作内容。</p>\n<h2>求职经验分享</h2>\n<h3>一些概念</h3>\n<h4>日常实习与正式（暑期）实习有什么区别</h4>\n<ul>\n<li><strong>日常实习如果一个组比较缺人，就很可能一年四季都招实习生，就会有日常实习的机会</strong>，只要是在校学生都可以去面试。而正式实习开始时间有一个范围比较固定，比如每年的 3-6 月，也就是暑期实习。</li>\n<li>日常实习相对要好进一些，但是有的日常实习没有转正名额，这个要先确认一下。</li>\n<li><strong>字节的日常实习和正式实习在转正没什么区别，都是一起申请转正的。</strong></li>\n</ul>\n<h4>正式实习拿到 offer 之后什么时候可以去实习</h4>\n<p>暑期实习拿到 offer 后就<strong>可以立即实习</strong>（一般需要走个流程 1 周左右的样子），<strong>也可以选择晚一点去实习</strong>，时间可以自己去把握，有的公司可以在系统上选择去实习的时间，有的是直接和 hr 沟通一下就可以。</p>\n<h4>提前批和正式批的区别</h4>\n<p>以找实习为例：</p>\n<ul>\n<li>先提前批，再正式批，提前批一般是小组直接招人<strong>不进系统</strong>，<strong>没有笔试</strong>，<strong>流程相对走的快</strong>，一般一面过了，很快就是二面。</li>\n<li>正式批面试都会有面评，如果上一次失败的面试评价会影响下一次面试，所以还是谨慎一点好</li>\n</ul>\n<h4>实习 offer 和正式 offer 区别</h4>\n<p>简单来说，实习 offer 只是给你一个实习的机会，如果在实习期间干的不错就可以转正，获得正式 offer。</p>\n<p>签署正式 offer 之后并不是意味着马上去上班，因为我们是校招生，拿到正式 offer 之后，可以继续实习（工资会是正式工资的百分比），也可以请假一段时间等真正毕业的时候再去正式工作。</p>\n<h3>时间节点</h3>\n<blockquote>\n<p>尽早把简历弄出来，最好就是最近一段时间，因为大家对实验室项目现在还很熟悉，现在写起来不是很难，再过几个月写简历就比较痛苦了。</p>\n</blockquote>\n<p>以去年为例：</p>\n<ul>\n<li>2 月份中旬的时候阿里提前批开始（基本上只有阿里这个时候开了提前批），3 月 8 号阿里提前批结束。腾讯提前批是 3 月多开始的，4 月 15 号结束</li>\n<li>3-5 月拿到实习 offer，最好在 4 月份可以拿到比较想去的实习 offer。</li>\n<li>4-8 月份实习，7 月初秋招提前批，7 月底或者 8 月初就是秋招正式批，9 月底秋招就少了挺多，但是只是相对来说，还是有机会，</li>\n<li>10 月底秋招基本结束，后面还会有秋招补录</li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "月色真美"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "如何甄别应聘者的包装程度",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/screen-candidates-for-packaging.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/screen-candidates-for-packaging.html",
      "summary": "推荐语：经常听到培训班待过的朋友给我说他们的老师是怎么教他们“包装”自己的，不光是培训班，我认识的很多朋友也都会在面试之前“包装”一下自己，所以这个现象是普遍存在的。但是面试官也不都是傻子，通过下面这篇文章来看看面试官是如何甄别应聘者的包装程度。 原文地址：https://my.oschina.net/hooker/blog/3014656 前言 上到...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：经常听到培训班待过的朋友给我说他们的老师是怎么教他们“包装”自己的，不光是培训班，我认识的很多朋友也都会在面试之前“包装”一下自己，所以这个现象是普遍存在的。但是面试官也不都是傻子，通过下面这篇文章来看看面试官是如何甄别应聘者的包装程度。</p>\n<br>\n<p><strong>原文地址</strong>：https://my.oschina.net/hooker/blog/3014656</p>\n</blockquote>\n<h2>前言</h2>\n<p>上到职场干将下到职场萌新，都会接触到包装简历这个词语。当你简历投到心仪的公司，公司内负责求职的工作人员是如何甄别简历的包装程度的？我根据自己的经验写下了这篇文章，谁都不是天才，包装无可厚非，切勿对号入座!</p>\n<h2>正文</h2>\n<p>在互联网极速膨胀的社会背景下，各行各业涌入互联网的 IT 民工日益增大。</p>\n<p>早在 2016 年，我司发布了 Java、Ios 工程师的招聘信息，就 Java 工程师单个岗位而言，日收简历近 200 份，Ios 日收简历近一千份。</p>\n<p>没错，这就是当年培训机构对 Ios 工程师这个岗位发起的市场讨伐。而随着近几年的发展，市场供大于求现象日益严重。人员摸底成为用人单位对人才考核的重大难题。</p>\n<p>笔者初次与求职者以面试的形式进行沟通是 2015 年 6 月。由于当时笔者从业时间短，经验不够丰富，错过了一些优秀的求职者。</p>\n<p>三年后的，今天，笔者再次因公司规模扩大而深入与求职者进行沟通。</p>\n<h3>1.初选如何鉴别劣质简历</h3>\n<p>培训机构除了提供技术培训，往往还提供<strong>简历编写指导</strong>、<strong>面试指导</strong>。很多潜移默化的东西，我们很难甄别。但培训机构包装的简历，存在千遍一律的特征。</p>\n<p><strong>年龄较小却具备高级文凭</strong></p>\n<p>年龄较小却具备高级文凭，这个或许不能作为一项标准，但是大部分的应聘者，均符合传统文凭的市场情况。个别技术爱好者可能通过自考获得文凭，这种情况需提供独有的技术亮点。</p>\n<p><strong>年龄较大却几乎不具备技术经验</strong></p>\n<p>年龄较大却几乎不具备技术经验，相对前一点，这个问题就比较严重了。大家都知道，一个正常的人，对新事物的接受能力会随着年龄的增长而降低，互联网技术也包括其内。如果一个人年龄较大不具备技术经验，那么只有两种情况：</p>\n<ol>\n<li>中途转行(通过培训、自学等方式强行入行)。</li>\n<li>由于能力问题，已有的经验不敢写入简历中(能力与经验/薪资不符)。</li>\n</ol>\n<p><strong>项目经验多为管理系统</strong></p>\n<p>项目经验，这一项用来评估应聘者的水平太合适不过了。随着互联网的发展迭代，每一年都会出来很多创新型的互联网公司和新兴行业。笔者最近发布的招聘需求里面。CRM 系统、商城、XX 管理系统、问卷系统、课堂系统占了 90%的份额。试问现在 2019 年，内部管理系统这么火爆么。言归正传，我们对于简历的评估，应当多考虑“确有其事”的项目。比如说该人员当时就职于 XX 公司，该公司当时的背景下确实研发了该项目（外包除外）。</p>\n<p><strong>项目的背景不符合互联网发展背景</strong></p>\n<p>项目背景，每年的市场走向不同，从早些年的电商、彩票风波，到后来的 O2O、夺宝、直播、新零售。每个系列的产品的出现，都符合市场的定义。如果简历中出现 18 年、19 年才刚立项做彩票(15 年政府禁止互联网彩票)、O2O、商城、夺宝(17 年初禁止夺宝类产品)、直播等产品。显然是非常不符合市场需求的。这种情况下需考虑具体情况是否存在理解空间。</p>\n<p><strong>缺乏新意</strong></p>\n<p>不同工作经验下多个项目技术架构或项目结构一致，缺乏新意。一般情况而言，不同的公司技术栈不同，甚至产品的走向和模式完全不同。故此，当一个应聘者多家公司的多个项目中写到的技术千遍一律，业务流程异曲同工。看似整洁，实则更加缺乏说服力。</p>\n<p><strong>技术过于新颖，对旧技术却只字不提</strong></p>\n<p>技术过于新颖，根据互联网技术发展的走向来看，我们在不断向新型技术靠拢。但是任何企业作为资历深厚的 CTO、架构师来说。往往会选择更稳定、更成熟、学习成本更低的已有技术。对新技术的追求不会过于明显。而培训机构则是“哪项技术火我们就教哪项”。故此，出现了很多走入互联网行业的新人对旧技术一窍不通。甚至很多技术都没听过。</p>\n<p><strong>工作经验较丰富，但从事的工作较低级。</strong></p>\n<p>工作经验比较丰富，单从事的工作比较低级，这里存在很大的问题，要么就是原公司没法提供合理的舞台给该人员更好的发展空间，要么就是该人员能力不够，没法完成更高级的工作。当然，还有一种情况就是该人员包装过多的经验导致简历中不和谐。这种情况需要评估公司规模和背景。</p>\n<p><strong>公司背景跨省跨市</strong></p>\n<p>可能很多用人单位和鄙人一样，最近接受到的简历，90%为跨市跳槽的人员。其中武汉占了 60%以上。均为武汉 XX 网络科技有限公司。公司规模均小于 50 人。也有厦门、宁波、南京等等。这个问题笔者就不提了，大家都懂的。跨地区跳槽不好查证。</p>\n<p><strong>缺少业余热情于技术的证明</strong></p>\n<p>有些眼高手低的技术员，做了几个管理系统。用到的技术确是各种分布式、集群、高并发、大数据、消息队列、搜索引擎、镜像容器、多数据库、数据中心等等。期望的薪资也高于行业标准。一个对技术很热情的人，业余时间肯定在技术方面花费过不少时间。那么可以从该人员的博客、git 地址入手。甚至可以通过手机号、邮箱、昵称、马甲。去搜索引擎进行搜集，核实该人员是否在论坛、贴吧、开源组织有过技术背景。</p>\n<h3>2. 进入面试阶段，如何甄别对方的水分</h3>\n<p>在甄别对方水分这一块，并没有明确的标准，但是笔者可以提几个点。这也是笔者在实际面试中惯用的做法。</p>\n<p><strong>通过公司规模、团队规模、人员分配是否合理、人员合作方式来判断对方是否具备工作经验</strong></p>\n<p>当招聘初级、初中级 IT 人员的时候，可以询问一些问题，比如公司有多少人、产品团队多少人、产品、技术、后端、前端、客户端、UI、测试各多少人。工作中如何合作的、产品做了多少时间、何时上线的、上线后多长时间迭代一个版本、多长时间迭代一个活动、发展至今多少用户(后端)、多大并发等等(后端)。根据笔者的经验，如果一个人没有任何从业周期，面对这些问题的时候，或多或少答非所问或者给出的答案非常不合理。</p>\n<p><strong>背景公司入职时间、项目立项实现、完工时间、产品技术栈、迭代流程的核实</strong></p>\n<p>很多应聘者对于简历过于包装，只为了追求更高的薪资。当我们问起：你是 xx 年 xx 月入职的该公司？你们项目是 xx 年 xx 月上线的？你们项目使用到 xx 技术？你们每次上线前夕是如何评审的。面对这些问题，应聘者给出的答案经常与简历不符合。这样问题就来了。关于项目使用到的技术，很多项目我们可以通过搜索该项目的地址、APP。通过 HTTP 协议、技术特征、抛出异常特征来大致判别对方使用到的技术。如果应聘者给出的答案明显与之不匹配，嘿嘿。</p>\n<p><strong>通过技术深度，甄别对方的技术水平</strong></p>\n<ol>\n<li>\n<p>确定对方的技术栈，如：你做过最满意的项目是哪个，为什么？你最喜欢使用的技术是哪些，为什么？</p>\n</li>\n<li>\n<p>确定对方项目的发展程度，如：你们产品做了多久，迭代了多久，发布了多少版本，发展到了多少用户，带来多大并发，多少流水？</p>\n</li>\n<li>\n<p>确定对方的技术属性，如：平时你会通过什么渠道跟其他技术人形成技术沟通与交流，主要交流过哪些技术？</p>\n</li>\n</ol>\n<p>笔者最近接待的面试者，很多面试者的简历上，写着层出不穷的各种技术，为了不跨越求职者的技术栈，笔者专门挑应聘者简历写到或用到的技术来进行询问。笔者举几个例子。</p>\n<p><strong>1)某求职者简历上写着熟练使用 Redis。</strong></p>\n<ol>\n<li>介绍一下你使用过 Redis 的哪些数据结构，并描述一下使用的业务场景；</li>\n<li>介绍一下你操作 Redis 用到的是什么插件；</li>\n<li>介绍一下你们使用的序列化方式；</li>\n<li>介绍一下你们使用 Redis 遇到过给你印象较深的问题；</li>\n</ol>\n<p><strong>2)某求职者声称熟练 HTTP 协议并编写过爬虫。</strong></p>\n<ol>\n<li>介绍一下你所了解的几个 HTTP head 头并描述其用途；</li>\n<li>如果前端提交成功，后端无法接受数据，这时候你将如何排查问题；</li>\n<li>描述一下 HTTP 基本报文结构;</li>\n<li>如果服务器返回 Cookie，存储在响应内容里面 head 头的字段叫做什么;</li>\n<li>当服务端返回 Transfer-Encoding：chunked 代表什么含义</li>\n<li>是否了解分段加载并描述下其技术流程。</li>\n</ol>\n<p>当然，面向不同的技术，对应的技术深度自然也不一样。</p>\n<p>大体上的套路便是如此：你说你杀过猪。那么你杀过几头猪，分别是啥时候，杀过多大的猪，有啥毛色。事实上对方可能给你的回答是：杀过、十几头、杀过五十斤的、杀过绿色、黄色、红色、蓝色的猪。那么问题就来了。</p>\n<p>然而笔者碰到的问题是：使用 Git 两年却不知道 GitHub、使用 Redis 一年却不知道数据结构也不知道序列化、专业做爬虫却不懂 <code>content-type</code> 含义、使用搜索引擎技术却说不出两个分词插件、使用数据库读写分离却不知道同步延时等等。</p>\n<p>写在最后，笔者认为在招聘途中，并不是不允许求职者包装，但是尽可能满足能筹平衡。虽然这篇文章没有完美的结尾，但是笔者提供了面试失败的各种经验。笔者最终招到了如意的小伙伴。也希望所有技术面试官早日找到符合自己产品发展的 IT 伙伴。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "Coody"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "阿里技术面试的一些秘密",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview.html",
      "summary": "推荐语：详细介绍了求职者在面试中应该具备哪些能力才会有更大概率脱颖而出。 原文地址： https://mp.weixin.qq.com/s/M2M808PwQ2JcMqfLQfXQMw 最近我的工作稍微轻松些，就被安排去校招面试了 当时还是有些激动的，以前都是被面试的，现在我自己也成为一个面试别人的面试官 接下来就谈谈我的面试心得(谈谈阿里面试的秘籍)...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：详细介绍了求职者在面试中应该具备哪些能力才会有更大概率脱颖而出。</p>\n<br>\n<p><strong>原文地址：</strong> https://mp.weixin.qq.com/s/M2M808PwQ2JcMqfLQfXQMw</p>\n</blockquote>\n<p>最近我的工作稍微轻松些，就被安排去校招面试了</p>\n<p>当时还是有些<strong>激动</strong>的，以前都是被面试的，现在我自己也成为一个面试别人的面试官</p>\n<p>接下来就谈谈我的面试心得(谈谈阿里面试的秘籍)</p>\n<h2>我是怎么筛选简历的？</h2>\n<p>面试之前都是要筛选简历，这个大家应该知道</p>\n<p>阿里对待招聘非常负责任，面试官必须对每位同学的简历进行查看和筛选，如果不合适还需要写清楚理由</p>\n<p>对于校招生来说，第一份工作非常重要，而且校招的面试机会也只有一次，一旦收到大家的简历意味着大家非常认可和喜爱阿里这家公司</p>\n<p>所以我们对每份简历都会认真看，大家可以非常放心，不会无缘无故挂掉大家的简历</p>\n<p>尽管我们报以非常负责任的态度，但有些同学们的简历实在是难以下看</p>\n<p>关于如何写简历，我之前写过类似的文章，这里就把之前的文章放这里让大家看看 <a href=\"https://mp.weixin.qq.com/s?__biz=MzI4MDYzNDc1Mg==&amp;mid=2247484010&amp;idx=1&amp;sn=afbe90c8446f5f21631cae750431d3ee&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">一份好的简历应该有哪些内容</a></p>\n<p>在筛选简历的时候会有以下信息非常重要，大家一定要认真写</p>\n<ul>\n<li><strong>项目经历</strong>，具体写法可以看上面提到的文章</li>\n<li><strong>个人含金量比较高的奖项</strong>，比如 ACM 奖牌、计算机竞赛等</li>\n<li><strong>个人技能</strong> 这块会看，但是大多数简历写法都差不多，尽量写得<strong>言简意赅</strong></li>\n<li><strong>重要期刊论文发表、开源项目</strong> 加分项</li>\n</ul>\n<p>这些信息非常重要，我筛选简历的时候这些信息占整份简历的比重 4/5 左右</p>\n<h2>面试的时候我会注重哪些方面？</h2>\n<h3><strong>表达要清楚</strong></h3>\n<p>这点是硬伤，在面试的时候有些同学半天说不清楚自己做的项目，我都在替你着急</p>\n<p>描述项目有个简单的方法论，我自己总结的 大家看看适不适合自己</p>\n<ul>\n<li>最好言简意赅的描述一下你的项目背景，让面试官很快知道项目干了啥(让面试官很快对项目感兴趣)</li>\n<li>说下项目用了哪些技术，做技术的用了哪些技术得说清楚，面试官会对你的技术比较感兴趣</li>\n<li>解决了什么问题，做项目肯定是为了解决问题，总不能为了做项目而做项目吧(解决问题的能力非常重要)</li>\n<li>遇到哪些难题，如何突破这些难题，项目遇到困难问题很正常，突破困难才是一次好的成长</li>\n<li>项目还有哪些完善的地方，不可能设计出完美的执行方案，有待改进说明你对项目认识深刻，思考深入</li>\n</ul>\n<p>一场面试时间一般 60—80 分钟，好的表达有助于彼此之间了解更多的问题</p>\n<h3><strong>基础知识要扎实</strong></h3>\n<p>校招非常注重基础知识，所以这块问的问题比较多，我一般会结合你项目去问，看看同学对技术是停留在用的阶段还是有自己的深入思考</p>\n<p>每个方向对基础知识要求不同，但有些基础知识是通用的</p>\n<p>比如<strong>数据结构与算法</strong>、<strong>操作系统</strong>、<strong>计算机网络</strong> 等</p>\n<p>这些基础技术知识一定要掌握扎实，技术岗位都会或多或少去问这些基础</p>\n<h3><strong>动手能力很重要</strong></h3>\n<p>action，action，action ，重要的事情说三遍，做技术的不可能光靠一张嘴，能落地才是最重要的</p>\n<p>面试官除了问你基础知识和项目还会去考考你的动手能力，面试时间一般不会太长，根据岗位的不同一般会让同学们写一些算法题目</p>\n<p>阿里面试，不会给你出非常变态的算法题目</p>\n<p>主要还是考察大家的动手能力、思考问题的能力、数据结构的应用能力</p>\n<p>在写代码的过程中，我也总结了自己的方法论：</p>\n<ul>\n<li>上来不要先写，审题、问清楚题目意图，不要自以为是的去理解思路，工作中 沟通需求、明确需求、提出质疑和建议是非常好的习惯</li>\n<li>接下来说思路 思路错了写到一半再去改会非常浪费时间</li>\n<li>描述清楚之后，先写代码思路的步骤注释，一边写注释，脑子里迭代一遍自己的思路是否正确，是否是最优解</li>\n<li>最后，代码规范</li>\n</ul>\n<h2>除了上面这些常规的方面</h2>\n<p>其实，现在面试已经非常<strong>卷</strong>了，上面说的这些很多都是 <strong>八股文</strong></p>\n<p>有些学生会拿到很多面试题目和答案，反复的去记忆，面试官问问题他就开始在脑子里面检索答案</p>\n<p>我一般问几个问题就知道该学生是不是在背八股文了。</p>\n<p>对于背八股文的同学，我真的非常难过。</p>\n<p>尽管你背的很好，但不能给你过啊，得对得起自己职责，得对公司负责啊！</p>\n<p>背的在好，不如理解一个知识点，理解一个知识点会有助于你去理解很多其他的知识点，很多知识点连起来就是一个知识体系。</p>\n<p>当面试官问你体系中的任何一个问题，都可以把这个体系讲给他听，不是<strong>背诵</strong> 。</p>\n<p>深入理解问题，我会比较关注。</p>\n<p>我在面试过程中，会通过一个问题去问一串问题，慢慢就把整体体系串起来。</p>\n<p>你的<strong>比赛</strong>和<strong>论文</strong>是你的亮点，这些东西是非常重要的加分项。</p>\n<p>我也会在面试中穿插一些<strong>开放性题目</strong>，都是思考题 考验一个同学思考问题的方式。</p>\n<h2>最后</h2>\n<p>作为一个面试官，我很想对大家说，每个企业都非常渴望人才，都希望找到最适合企业发展的人</p>\n<p>面试的时候面试官会尽量去挖掘你的价值。</p>\n<p>但是，面试时间有限，同学们一定要在有限的时间里展现出自己的<strong>能力</strong>和<strong>无限的潜力</strong> 。</p>\n<p>最后，祝愿优秀的你能找到自己理想的工作！</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "龙叔"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "普通人的春招总结（阿里、腾讯offer）",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/summary-of-spring-recruitment.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/summary-of-spring-recruitment.html",
      "summary": "推荐语：牛客网热帖，写的很全面！暑期实习，投了阿里、腾讯、字节，拿到了阿里和腾讯的 offer。 原文地址： https://www.nowcoder.com/discuss/640519 下篇：十年饮冰，难凉热血——秋招总结 背景 写这篇文章的时候，腾讯 offer 已经下来了，春招也算结束了，这次找暑期实习没有像去年找日常实习一样海投，只投了 BA...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：牛客网热帖，写的很全面！暑期实习，投了阿里、腾讯、字节，拿到了阿里和腾讯的 offer。</p>\n<br>\n<p><strong>原文地址：</strong> https://www.nowcoder.com/discuss/640519</p>\n<br>\n<p><strong>下篇</strong>：<a href=\"https://www.nowcoder.com/discuss/804679\" target=\"_blank\" rel=\"noopener noreferrer\">十年饮冰，难凉热血——秋招总结</a></p>\n</blockquote>\n<h2>背景</h2>\n<p>写这篇文章的时候，腾讯 offer 已经下来了，春招也算结束了，这次找暑期实习没有像去年找日常实习一样海投，只投了 BAT 三家，阿里和腾讯收获了 offer，字节没有给面试机会，可能是笔试太拉垮了。</p>\n<p>楼主大三，双非本科，我的春招的起始时间应该是 2 月 20 日到 3 月 23 日收到阿里意向书为止，但是从 3 月 7 日蚂蚁技术终面面完之后就没有面过技术面了，只面过两个 HR 面，剩下的时间都在等 offer。最开始是找朋友内推了字节财经的日常实习，但是到现在还在简历评估，后面又投了财经的暑期实习，笔试之后就一直卡在流程里了。腾讯是一开始被天美捞了，一面挂了之后被 PCG 捞了，最后走完了流程。阿里提前批投了好多部门，蚂蚁最先走完了终面，就录入了系统，最后拿了 offer。这一路走过来真的是酸甜苦辣都经历过，因为学历自卑过，以至于想去考研。总而言之，一定要找一个搭档和你一起复习，比如说 @你怕是个憨批哦，这是我实验室的同学，也是我们实验室的队长，这个人是真的强，阿里核心部门都拿遍了，他在我复习的过程中给了我很多帮助。</p>\n<h2>写这个帖子的目的</h2>\n<ol>\n<li>写给自己：总结反思一下大学前三年以及找工作的一些经历与感悟。</li>\n<li>写给还在找实习的朋友：希望自己的经历以及面经]能给你们一些启发和帮助。</li>\n<li>写给和我一样有着大厂梦的学弟学妹们：你们还有很长的准备时间，无论你之前在干什么，没有目标也好，碌碌无为也好，没找对方向也好，只要从现在开始，找对学习的方向，并且坚持不懈的学上一年两年，一定可以实现你的梦想的。</li>\n</ol>\n<h2>我的大学经历</h2>\n<p>先简单聊聊一下自己大学的经历。</p>\n<p>本人无论文、无比赛、无 ACM，要啥奖没啥奖，绩点还行，不是很拉垮，也不亮眼。保研肯定保不了，考研估计也考不上。</p>\n<p>大一时候加入了工作室，上学期自学了 C 语言和数据结构，从寒假开始学 Java，当时还不知道 Java 那么卷，我得到的消息是 Java 好找工作，这里就不由得感叹信息差的重要性了，我当时只知道前端、后端和安卓开发，而我确实对后端开发感兴趣，但是因为信息差，我只知道 Java 可以做后端开发，并不知道后端开发其实是一个很局限的概念，后面才慢慢了解到后台开发、服务端开发这些名词，也不知道 C++、Golang 等语言也可以做后台开发，所以就学了 Java。但其实 Java 更适合做业务，C++ 更适合做底层开发、服务端开发，我虽然对业务不反感，但是对 OS、Network 这些更感兴趣一些，当然这些会作为我的一些兴趣，业余时间会自己去研究下。</p>\n<h3>学习路线</h3>\n<p>大概学习的路线就是：Java SE 基础 -&gt; MySQL -&gt; Java Web（主要包括 JDBC、Servlet、JSP 等）-&gt; SSM（其实当时 Spring Boot 已经兴起，但是我觉得没有 SSM 基础很难学会 Spring Boot，就先学了 SSM）-&gt; Spring Boot -&gt; Spring Cloud（当时虽然学了 Spring Cloud，但是缺少项目的锤炼，完全不会用，只是了解了分布式的一些概念）-&gt; Redis -&gt; Nginx -&gt; 计算机网络（本来是计算机专业的必修课，可是我们专业要到大三下才学，所以就提前自学了）-&gt; Dubbo -&gt; Zookeeper -&gt; JVM -&gt; JUC -&gt; Netty -&gt; Rabbit MQ -&gt; 操作系统（同计算机网络）-&gt; 计算机组成原理（直接不开这门课）。</p>\n<p>这就是我的一个具体的学习路线，大概是在大二的下学期学完的这些东西，都是通过看视频学的，只会用，并不了解底层原理，达不到面试八股文的水准，把这些东西学完之后，搭建起了知识体系，就开始准备面试了，大概的开始时间是去年的六月份，开始在牛客网上看一些面经，然后会自己总结。准备面试的阶段我觉得最重要的是啃书 + 刷题，八股文只是辅助，我们只是自嘲说面试就背背八股文，但其实像阿里这样的公司，背八股文是完全不能蒙混过关的，除非你有非常亮眼的项目或者实习经历。</p>\n<h3>书籍推荐</h3>\n<ul>\n<li>《Thinking in Java》：不多说了，好书，但太厚了，买了没看。</li>\n<li>《深入理解 Java 虚拟机》：JVM 的圣经，看了两遍，每一遍都有不同的收获。</li>\n<li>《Java 并发编程的艺术》：阿里人写的，基本涵盖了面试会问的并发编程的问题。</li>\n<li>《MySQL 技术内幕》：写的很深入，但是对初学者可能不太友好，第一感觉写的比较深而杂，后面单独去看每一章节，觉得收获很大。</li>\n<li>《Redis 设计与实现》：书如其名，结合源码深入讲解了 Redis 的实现原理，必看。</li>\n<li>《深入理解计算机系统》：大名鼎鼎的 CSAPP，对你面 Java 可能帮助不是很大，但是不得不说这是一本经典，涵盖了计算机系统、体系结构、组成原理、操作系统等知识，我蚂蚁二面的时候就被问了遇到的最大的困难，我就和面试官交流了读这本书中遇到的一些问题，淘系二面的时候也和面试官交流了这本书，我们都觉得这本书还需要二刷。</li>\n<li>《TCP/IP 详解卷 1》：我只看了 TCP 相关的章节，但是是有必要通读一遍的，面天美时候和面试官交流了这本书。</li>\n<li>《操作系统导论》：颇具盛名的 OSTEP，南大操作系统的课本，看的时候可以结合在 B 站蒋炎岩老师的视频，我会在下面放链接。</li>\n</ul>\n<p>这几本书理解透彻了，我相信面试的时候可以面试官面试官聊的很深入了，面试官也会对你印象非常好。但是对于普通人来说，看一遍是肯定记不住的，遗忘是非常正常的现象，我很多也只看了一遍，很多细节也记不清了，最近准备二刷。</p>\n<p>更多书籍推荐建议大家看 <a href=\"https://javaguide.cn/books/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 这个网站上的书籍推荐，比较全面。</p>\n<figure><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62099c9b2fd24d3cb6511e49756f486b~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>教程推荐</h3>\n<p>我上面谈到的学习路线，我建议是跟着视频学，尚硅谷和黑马的教程都可以，一定要手敲一遍。</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1HN41197Ko\" target=\"_blank\" rel=\"noopener noreferrer\">2021 南京大学 “操作系统：设计与实现” (蒋炎岩)</a>：我不多说了，看评论就知道了。</li>\n<li><a href=\"https://www.bilibili.com/video/BV16J41127jq\" target=\"_blank\" rel=\"noopener noreferrer\">SpringSecurity-Social-OAuth2 社交登录接口授权鉴权系列课程</a>：字母哥讲的 Spring Security 也很好，Spring Security 或者 Shiro 是做项目必备的，会一个就好，根据实际场景以及个人喜好（笑）来选型。</li>\n<li><a href=\"https://www.bilibili.com/video/BV1jt4y117KR\" target=\"_blank\" rel=\"noopener noreferrer\">清华大学邓俊辉数据结构与算法</a>：清华不解释了。</li>\n<li><a href=\"https://time.geekbang.org/column/intro/100020801\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 实战 45 讲</a>：前 27 讲多看几遍基本可以秒杀面试中遇到的 MySQL 问题了。</li>\n<li><a href=\"https://time.geekbang.org/column/intro/100056701\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 核心技术与实战</a>：讲解了大量的 Redis 在生产上的使用场景，和《Redis 设计与实现》配合着看，也可以秒杀面试中遇到的 Redis 问题了。</li>\n<li><a href=\"https://javaguide.cn/books/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a>：「Java 学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。</li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247519384&amp;idx=1&amp;sn=bc7e71af75350b755f04ca4178395b1a&amp;chksm=cea1c353f9d64a458f797696d4144b4d6e58639371a4612b8e4d106d83a66d2289e7b2cd7431&amp;token=660789642&amp;lang=zh_CN&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>：这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</li>\n</ul>\n<h2>找工作</h2>\n<p>大概是去年 11 月的时候，牛客上日常实习的面经开始多了起来，我也有了找实习的意识，然后就开始一边复习一边海投，投了很多公司，给面试机会的就那几家，腾讯二面挂了两次，当时心态完全崩了，甚至有了看空春招的想法。很幸运最后收获了一个实习机会，在实习的时候，除了完成日常的工作以外，其余时间也没有松懈，晚上下班后、周末的时间都用来复习，心里也暗暗下定决心，春招一定要卷土重来！</p>\n<p>从二月下旬开始海投阿里提前批，基本都有了面试，开系统那天收到了 16 封内推邮件，具体的面经可以看我以前发的文章。</p>\n<p>从 3.1 到 3.7 那一个周平均每天三场面试，真的非常崩溃，一度想考研，也焦虑过、哭过、笑过，还好结果是好的，最后也去了一直想去的支付宝。</p>\n<p>我主要是想通过自己对面试过程的总结给大家提一些建议，大佬不喜勿喷。</p>\n<h3>面试准备</h3>\n<p>要去面试首先要准备一份简历，我个人认为一份好的简历应该有一下三个部分：</p>\n<ol>\n<li>完整的个人信息，这个不多说了吧，个人信息不完整面试官或 HR 都联系不上你，就算学校不好也要写上去，因为听说有些公司没有学校无法进行简历评估，非科班或者说学校不太出名可以将教育信息写在最下面。</li>\n<li>项目/实习经历，项目真的很重要，面试大部分时间会围绕着项目来，你项目准备好了可以把控面试的节奏，引导面试官问你擅长的方向，我就是在这方面吃了亏。如果没有项目怎么办，可以去 GitHub 上找一些开源的项目，自己跟着做一遍，加入一些自己的思考和理解。还有做项目不能简单实现功能，还要考虑性能和优化，面试官并不关注你这个功能是怎么实现的，他想知道的是你是如何一步步思考的，一开始的方案是什么，后面选了什么方案，对性能有哪些提升，还能再改进吗？</li>\n<li>具备的专业技能，这个可以简单的写一下你学过的专业知识，这样可以让面试官有针对的问一些基础知识，切忌长篇罗列，最擅长的一定要写在上面，依次往下。</li>\n</ol>\n<p>简历写好了之后就进入了投递环节，最好找一个靠谱的内推人，因为内推人可以帮你跟进面试的进度，必要时候和 HR 沟通，哪怕挂了也可以告诉你原因，哪些方面表现的不好。现在内推已经不再是门槛，而是最低的入场券，没有认识的人内推也可以在牛客上找一些师兄内推，他们往往也很热情。</p>\n<p>在面试过程中一定不要紧张，因为一面面试官可能比我们大不了几岁，也工作没几年，所以 duck 不必紧张的不会说话，不会就说不会，然后笑一下，会就流利的表达出来，面试并不是一问一答，面试是沟通，是交流，你可以大胆的说出自己的思考，表达沟通能力也是面试的一个衡量指标。</p>\n<p>我个人认为面试和追妹子是差不多的，都是尽快的让对方了解自己，发现你身上的闪光点，只不过面试是让面试官了解你在技术上的造诣。所以，自我介绍环节就变得非常重要，你可以简单介绍完自己的个人信息之后，介绍一下你做过的项目，自我介绍最好长一些，因为在面试前，面试官可能没看过你的简历（逃），你最好留给面试官充足的时间去看你的简历。自我介绍包括项目的介绍可以写成一遍文档，多读几遍，在面试的时候能够背下来，实在不行也可以照着读。</p>\n<h3>项目</h3>\n<p>我还是要重点讲一下项目，我以前认为项目是一个不确定性非常大的地方，后来经过面试才知道项目是最容易带面试官节奏的地方。问项目的意义是通过项目来问基础知识，所以就要求你对自己的项目非常熟悉，考虑各种极端情况以及优化方案，熟悉用到的中间件原理，以及这些中间件是如何处理这些情况的，比如说，MQ 的宕机恢复，Redis 集群、哨兵，缓存雪崩、缓存击穿、缓存穿透等。</p>\n<p>优化主要可以从缓存、MQ 解耦、加索引、多线程、异步任务、用 ElasticSearch 做检索等方面考虑，我认为项目优化主要的着手点就是减少数据库的访问量，减少同步调用的次数，比如说加缓存、用 ElasticSearch 做检索就是通过减少数据库的访问来实现的优化，MQ 解耦、异步任务等就是通过减少同步调用的次数来实现的优化。</p>\n<p>项目中还可以学到很多东西，比如下面的这些就是通过项目来学习的：</p>\n<ol>\n<li>权限控制（ABAC、RBAC）</li>\n<li>JWT</li>\n<li>单点登录</li>\n<li>分库分表</li>\n<li>分片上传/导出</li>\n<li>分布式锁</li>\n<li>负载均衡</li>\n</ol>\n<p>当然还有很多东西，每个人的项目不一样，能学到的东西也天差地别，但是你要相信的是，你接触到的东西，面试官应该是都会的，所以一定要好好准备，不然容易被怼。</p>\n<p>本质上来讲，项目也可以拆解成八股文，可以用准备基础知识的方式来准备项目。</p>\n<h3>算法</h3>\n<p>项目的八股文化，会进一步导致无法准确的甄选候选人，所以就到了面试的第三个衡量标准，那就是算法，我曾经在反问阶段问过面试官刷算法对哪些方面有帮助，面试官直截了当的对我说，刷题对你以后找工作有帮助。我的观点是算法其实也是可以通过记忆来提高的，LeetCode 前 200 道题能刷上 3 遍，我不信面试时候还能手撕不了，所以在复习的过程中一定要保持算法的训练。</p>\n<h3>面试建议</h3>\n<ol>\n<li>自我介绍尽量丰富一下，项目提前准备好如何介绍。</li>\n<li>在面试的时候，遇到不会的问题最好不要直接说不会，然后愣着，等面试官问下一个问题，你可以说自己对这方面不太了解，但是对 XX 有一些了解，然后讲一下，如果面试官感兴趣，你就可以继续说，不感兴趣他就会问下一个问题，面试官一般是不会打断的，这也是让面试官快速了解你的一个小技巧。</li>\n<li>尽量向面试官展示你的技术热情，比如说你可以和面试官聊 Java 每个版本的新特性，最近技术圈的一些新闻等等，因为就我所知，技术热情也是阿里面试考察的一方面。</li>\n<li>面试是一个双向选择的过程，不要表现的太过去谄媚。</li>\n<li>好好把握好反问阶段，问一些有价值的内容，比如说新人培养机制、转正机制等。</li>\n</ol>\n<h2>经验</h2>\n<ol>\n<li>如果你现在大一，OK，我希望你能多了解一下互联网就业的方向，看看自己的兴趣在哪，先把基础打好，比如说数据结构、操作性、计算机网络、计算机组成原理，因为这四门课既是大部分学校考研的专业课，也是面试中常常会被问到的问题。</li>\n<li>如果已经大二了，那就要明确自己的方向，要有自驱力，知道你学习的这个方向都要学哪些知识，学到什么程度能够就业，合理安排好时间，知道自己在什么阶段要达到什么样的水准。</li>\n<li>如果你学历比较吃亏，亦或是非科班出身，那么我建议你一定要付出超过常人的努力，因为在我混迹牛客这么多年，我看到的面经一般是学校好一些的问的简单一些，相对差一些的问的难一些，其实也可以理解，毕竟普遍上来说名校出身的综合实力要强一些。</li>\n<li>尽量早点实习，如果你现在大二，已经有了能够实习的水平，我建议你早点投简历，尽量找暑期实习，你相信我，如果你这个暑假去实习了，明年一定是乱杀。</li>\n<li>接上条，如果找不到实习，尽量要做几个有挑战的项目，并且找到这个项目的抓手。</li>\n<li>多刷刷牛客，我在牛客上就认识了很多志同道合的人，他们在我找工作过程中给了我很多帮助。</li>\n</ol>\n<h2>建议</h2>\n<ol>\n<li>一定要抱团取暖，一起找工作的同学可以拉一个群，无论是自己学校的还是网上认识的，平常多交流复习心得，n 个 1 相加的和一定是大于 n 的。</li>\n<li>知识的深度和广度都很重要，平常一定要多了解新技术，而且每学一门技术一定要争取了解它的原理，不然你学的不算是计算机，而是英语系，工作职位也不是研发工程师，而是 API 调用工程师。</li>\n<li>运营好自己的 CSDN、掘金等博客平台，我有个学弟大二是 CSDN 博客专家，已经有猎头联系他了，平常写的代码尽量都提交到 GitHub 上，无论是项目也好，实验也好，如果有能力的话最好能录制一些视频发到哔哩哔哩上，因为这是面试官在面试你之前了解你表达能力的一个重要途径。</li>\n<li>心态一定要好，面试不顺利，不一定是你的能力问题，也可能是因为他们招人很少，或者说某一些客观条件与他们不匹配，一定要多尝试不同的选择。</li>\n<li>多和人沟通交流，不要自己埋头苦干，因为你以后进公司里也需要和别人合作，所以表达和沟通能力是一项基本的技能，要提前培养。</li>\n</ol>\n<h2>闲聊</h2>\n<h3>谈谈信息差</h3>\n<p>我觉得学校的差距并不只是体现在教学水平上，诚然名校的老师讲课水平、实验水平都是高于弱校的，但是信息差才是主要的差距。在 985 学校里面读书，不仅能接触到更多优质企业的校招宣讲、讲座，还能接触到更好的就业氛围，因为名校里面去大厂、去外企的人、甚至出国的人更多，学长学姐的内推只是一方面，另一方面是你可以从他们身上学到技术以外的东西，而双非学校去大厂的人少，他们能影响的只是很少一部分人，这就是信息差。信息差的劣势主要体现在哪些方面呢？比如人家大二已经开始找日常实习了，而你认为找工作是大四的事情，人家大三已经找到暑期实习了，你暑假还需要去参加学校组织的培训，一步步的就这样拉下了。</p>\n<p>好在，互联网的出现让信息更加透明，你可以在网上检索各种各样你想要的信息，比如我就在牛客]上认识了一些志同道合的朋友，他们在找工作的过程中给了我很多帮助。平常可以多刷刷牛客，能够有效的减小信息差。</p>\n<h3>谈谈 Java 的内卷</h3>\n<p>Java 卷吗？毫无疑问，很卷，我个人认为开发属于没有什么门槛的工作，本科生来干正合适，但是因为算法岗更是神仙打架，导致很多的研究生也转了开发，而且基本都转了 Java 开发。Java 的内卷只是这个原因造成的吗？当然不是，我认为还有一个原因就是培训机构的兴起，让这个行业的门槛进一步降低，你要学什么东西，怎么学，都有人给你安排好了，这是造成内卷的第二个原因。第三个原因就是非科班转码，其它行业的凋落和互联网行业的繁荣形成了鲜明对比，导致很多其它专业的人也自学计算机，找互联网的工作，导致这个行业的人越来越多，蛋糕就那么大，分蛋糕的人却越来越多。</p>\n<p>其实内卷也不一定是个坏现象，这说明阶级上升的通道还没有完全关闭，还是有不少人愿意通过努力来改变现状，这也一定程度上会加快行业的发展，社会的发展。选择权在你自己手上，你可以选择回老家躺平或者进互联网公司内卷，如果选择后者的话，我的建议还是尽早占下坑位，因为唯一不变的是变化，你永远不知道三年后是什么样子。</p>\n<h2>祝福</h2>\n<p>惟愿诸君，前程似锦！</p>\n",
      "image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62099c9b2fd24d3cb6511e49756f486b~tplv-k3u1fbpfcp-zoom-1.image",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "钟期既遇"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "从面试官和候选者的角度谈如何准备技术初试",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/technical-preliminary-preparation.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/technical-preliminary-preparation.html",
      "summary": "推荐语：从面试官和面试者两个角度探讨了技术面试！非常不错！ 内容概览： 通过技术基础考察候选者，才能考察到候选者的真实技术实力：技术深度和广度。 实战与理论结合。比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题? 项目经历考察不宜超过两个。因...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：从面试官和面试者两个角度探讨了技术面试！非常不错！</p>\n<p><strong>内容概览：</strong></p>\n<ul>\n<li>通过技术基础考察候选者，才能考察到候选者的真实技术实力：技术深度和广度。</li>\n<li>实战与理论结合。比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题?</li>\n<li>项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障等。</li>\n<li>多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。</li>\n</ul>\n<p><strong>原文地址：</strong> https://www.cnblogs.com/lovesqcc/p/15169365.html</p>\n</blockquote>\n<h2>考察目标和思路</h2>\n<p>首先明确，技术初试的考察目标：</p>\n<ul>\n<li>候选人的技术基础；</li>\n<li>候选人解决问题的思路和能力。</li>\n</ul>\n<p>技术基础是基石（冰山之下的东西），占七分， 解决问题的思路和能力是落地（冰山之上露出的部分），占三分。 业务和技术基础考察，三七开。</p>\n<h2>技术基础考察</h2>\n<h3>为什么要考察技术基础?</h3>\n<p>程序员最重要的两种技术思维能力，是逻辑思维能力和抽象设计能力。逻辑思维能力是基础，抽象设计能力是高阶。 考察技术基础，正好可以同时考察这两种思维能力。能不能理解基础技术概念及关联，是考察逻辑思维能力；能不能把业务问题抽象成技术问题并合理的组织映射，是考察抽象设计能力。</p>\n<p>绝大部分业务问题，都可以抽象成技术问题。在某种意义上，业务问题只是技术问题的领域化表述。</p>\n<p>因此，<strong>通过技术基础考察候选者，才能考察到候选者的真实技术实力：技术深度和广度。</strong></p>\n<h3>技术基础怎么考察？</h3>\n<p>技术基础怎么考察？通过有效的多角度的发问模式来考察。</p>\n<h4>是什么-为什么</h4>\n<p>是什么考察对概念的基本理解，为什么考察对概念的实现原理。</p>\n<p>比如：索引是什么？ 索引是如何实现的？</p>\n<h4>引导-横向发问-深入发问</h4>\n<p>引导性，比如 “你对 Java 同步工具熟悉吗？” 作个试探，得到肯定答复后，可以进一步问：“你熟悉哪些同步工具类？” 了解候选者的广度；</p>\n<p>获取候选者的回答后，可以进一步问：“ 谈谈 <code>ConcurrentHashMap</code> 或 <code>AQS</code> 的实现原理？”</p>\n<p>一个人在多大程度上把技术原理能讲得清晰，包括思路和细节，说明他对技术的掌握能力有多强。</p>\n<h4>跳跃式/交叉式发问</h4>\n<p>比如：讲到哈希高效查找，可以谈谈哈希一致性算法 。 两者既有关联又有很多不同点。也是一种技术广度的考察方法。</p>\n<h4>总结性发问</h4>\n<p>比如：你在做 XXX 中，获得了哪些可以分享的经验？ 考察候选人的归纳总结能力。</p>\n<h4>实战与理论结合</h4>\n<p>比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题?</p>\n<p>比如，候选人有谈到 SQL 优化和索引优化，那就正好谈谈索引的实现原理，如何建立最佳索引？</p>\n<p>再比如，候选人有谈到事务，那就正好谈谈事务实现原理，隔离级别，快照实现等；</p>\n<h4>熟悉与不熟悉结合</h4>\n<p>针对候选人简历上写的熟悉的部分，和没有写出的都问下。比如候选人简历上写着：熟悉 JVM 内存模型， 那我就考察下内存管理相关（熟悉部分），再考察下 Java 并发工具类（不确定是否熟悉部分）。</p>\n<h4>死知识与活知识结合</h4>\n<p>比如，查找算法有哪些？顺序查找、二分查找、哈希查找。这些大家通常能说出来，也是“死知识”。</p>\n<p>这些查找算法各适用于什么场景？在你工作中，有哪些场景用到了哪些查找算法？为什么？ 这些是“活知识”。</p>\n<h4>学习或工作中遇到的</h4>\n<p>有时，在学习和工作中遇到的问题，也可以作为面试题。</p>\n<p>比如，最近在学习《操作系统导论》并发部分，有一章节是如何使数据结构成为线程安全的。这里就有一些可以提问的地方：如何实现一个锁？如何实现一个线程安全的计数器？如何实现一个线程安全的链表？如何实现一个线程安全的 <code>Map</code> ？如何提升并发的性能？</p>\n<p>工作中遇到的问题，也可以抽象提炼出来，作为技术基础面试题。</p>\n<h4>技术栈适配度发问</h4>\n<p>如果候选人（简历上所写的）使用的某些技术与本公司的技术栈比较契合，则可以针对这些技术点进行深入提问，考察候选人在这些技术点的掌握程度。如果掌握程度比较好，则技术适配度相对更高一些。</p>\n<p>当然，这一点并不能作为筛掉那些没有使用该技术栈的候选人的依据。比如本公司使用 <code>MongoDB</code> 和 <code>MySQL</code>， 而一个候选人没有用过 <code>Mongodb，</code> 但使用过 <code>MySQL</code>, <code>Redis</code>, <code>ES</code>, <code>HBase</code> 等多种存储系统，那么适配度并不比仅使用过 <code>MySQL</code> 和 <code>MongoDB</code> 的候选人逊色，因为他所涉及的技术广度更大，可以推断出他有足够能力掌握 <code>Mongodb</code>。</p>\n<h4>创造有个性的面试题库</h4>\n<p>每个技术面试官都会有一个面试题库。持续积累面试题库，日常中突然想到的问题，就随手记录下来。</p>\n<h2>业务维度考察</h2>\n<h3>为什么要考察业务维度？</h3>\n<p>技术基础考察，容易错过的地方是，候选人的非技术能力特质，比如沟通组织能力、带项目能力、抗压能力、解决实际问题的能力、团队影响力、其它性格特质等。</p>\n<h3>为什么不能单考察业务维度？</h3>\n<p>因为业务方面通常比较熟悉，可能就直接按照现有方案说出来了，很难考察到候选人的深入理解、横向拓展和归纳总结能力。</p>\n<p>这一点，建议有针对性地考察下候选人的归纳总结能力：比如， 微服务搭建或开发或维护/保证系统稳定性或性能方面的过程中，你收获了哪些可以分享的经验？</p>\n<h2>解决问题能力考察</h2>\n<p>仅仅只是技术基础还不够，通常最好结合实际业务，针对他项目里的业务，抽象出技术问题进行考察。</p>\n<p>解决思路重在层层递进。这一点对于面试官的要求也比较高，兼具良好的倾听能力、技术深度和业务经验。首先要仔细倾听候选人的阐述，找到适当的技术切入点，然后进行发问。如果进不去，那就容易考察失败。</p>\n<h3>设计问题</h3>\n<ul>\n<li>比如多个机器间共享大量业务对象，这些业务对象之间有些联合字段是重复的，如何去重？</li>\n<li>如果瞬时有大量请求涌入，如何保证服务器的稳定性？</li>\n</ul>\n<h3>项目经历</h3>\n<p>项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。</p>\n<p>一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障等。</p>\n<h2>面试官如何做好一场面试?</h2>\n<h3>预先准备</h3>\n<p>面试官也需要做一些准备。比如熟悉候选者的技能优势、工作经历等，做一个面试设计。</p>\n<p>在面试将要开始时，做好面试准备。此外，面试官也需要对公司的一些基本情况有所了解，尤其是公司所使用技术栈、业务全景及方向、工作内容、晋升制度等，这一点技术型候选人问得比较多。</p>\n<h3>面试启动</h3>\n<p>一般以候选人自我介绍启动，不过候选人往往会谈得比较散，因此，我会直接提问：谈谈你有哪些优势以及自己觉得可以改进的地方？</p>\n<p>然后以一个相对简单的基础题作为技术提问的开始：你熟悉哪些查找算法？大多数人是能答上顺序查找、二分查找、哈希查找的。</p>\n<h3>问题设计</h3>\n<p>提前阅读候选人简历，从简历中筛选出关键词，根据这些关键词进行有针对性地问题设计。</p>\n<p>比如候选人简历里提到 <code>MVVM</code> ，可以问 <code>MVVM</code> 与 <code>MVC</code> 的区别； 提到了观察者模式，可以谈谈观察者模式，顺便问问他还熟悉哪些设计模式。</p>\n<h3>宽松氛围</h3>\n<p>即使问的问题比较多比较难，也要注意保持宽松氛围。</p>\n<p>在面试前，根据候选人基本信息适当调侃一下，比如一位候选人叫汪奎，那我就说：之前我们团队有位叫袁奎，我们都喊他奎爷。</p>\n<p>在面试过程中，适当提示，或者给出少量自己的看法，也能缓解候选人的紧张情绪。</p>\n<h3>学会倾听</h3>\n<p>多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。</p>\n<p>引导候选人表现他最优势的一面，让他或她感觉好一些：毕竟一场面试双方都付出了时间和精力，不应该是面试官 Diss 候选人的场合，而应该让彼此有更好的交流。很大可能，你也能从候选人那里学到不少东西。</p>\n<p>面试这件事，只不过双方的角色和立场有所不同，但并不代表面试官的水平就一定高于候选人。</p>\n<h3>记录重点</h3>\n<p>认真客观地记录候选人的回答，尽可能避免任何主观评价，亦不作任何加工（比如自己给总结一下，总结能力也是候选人的一个特质）。</p>\n<h2>作出判断</h2>\n<p>面试过程是一种铺垫，关键的是作出判断。</p>\n<p>作出判断最容易陷入误区的是：贪深求全。总希望候选人技术又深入又全面。实际上，这是一种奢望。如果候选人的技术能力又深入又全面，很可能也会面临两种情况：</p>\n<ol>\n<li>候选人有更好的选择；</li>\n<li>候选人在其它方面可能存在不足，比如团队协作方面。</li>\n</ol>\n<p>一个比较合适的尺度是：</p>\n<ol>\n<li>他或她的技术水平能否胜任当前工作；</li>\n<li>他或她的技术水平与同组团队成员水平如何；</li>\n<li>他或她的技术水平是否与年限相对匹配，是否有潜力胜任更复杂的任务。</li>\n</ol>\n<p><strong>不同年龄看重的东西不一样。</strong></p>\n<p>对于三年以下的工程师，应当更看重其技术基础，因为这代表着他的未来潜能；同时也考察下他在实际开发中的体现，比如团队协作、业务经验、抗压能力、主动学习的热情和能力等。</p>\n<p>对于三年以上的工程师，应当更看重其业务经验、解决问题能力，看看他或她是如何分析具体问题，在业务范畴内考察其技术基础的深度和广度。</p>\n<p>如何判断一个候选人的真实技术水平及是否适合所需，这方面，我也在学习中。</p>\n<h2>给候选人的话</h2>\n<h3>关注技术基础</h3>\n<p>一个常见的疑惑是：开发业务系统的大多数时候，基本不涉及数据结构与算法的设计与实现，为什么要考察 <code>HashMap</code> 的实现原理？为什么要学好数据结构与算法、操作系统、网络通信这些基础课程？</p>\n<p>现在我可以给出一个答案了：</p>\n<ul>\n<li>正如上面所述，绝大多数的业务问题，实际上最终都会映射到基础技术问题上：数据结构与算法的实现、内存管理、并发控制、网络通信等；这些是理解现代互联网大规模程序以及解决程序疑难问题的基石，—— 除非能祝福自己永远都不会遇到疑难问题，永远都只满足于编写 CRUD；</li>\n<li>这些技术基础正是程序世界里最有趣最激动人心的地方。如果对这些不感兴趣，就很难在这个领域里深入进去，不如及早转行从事其它职业，非技术的世界一直都很精彩广阔（有时我也想多出去走走，不想局限于技术世界）；</li>\n<li>技术基础是程序员的内功，而具体技术则是招式。徒有招式而内功不深，遇到高手（优秀同行从业者的竞争及疑难杂症）容易不堪一击；</li>\n<li>具备扎实的专业技术基础，能达到的上限更高，未来更有可能胜任复杂的技术问题求解，或者在同样的问题上能够做到更好的方案；</li>\n<li>人们喜欢跟与自己相似的人合作，牛人倾向于与牛人合作能得到更好的效果；如果一个团队大部分人技术基础比较好，那么进来一个技术基础比较薄弱的人，协作成本会变高；如果你想和牛人一起合作拿到更好的结果，那就要让自己至少在技术基础上能够与牛人搭配的上；</li>\n<li>在 CRUD 的基础上拓展其它才能也不失为一种好的选择，但这不会是一个真正的程序员的姿态，顶多是有技术基础的产品经理、项目经理、HR、运营、客满等其它岗位人才。这是职业选择的问题，已经超出了考察程序员的范畴。</li>\n</ul>\n<h3>不要在意某个问题回答不上来</h3>\n<p>如果面试官问你很多问题，而有些没有回答上来，不要在意。面试官很可能只是在测试你的技术深度和广度，然后判断你是否达到某个水位线。</p>\n<p>重点是：有些问题你答得很有深度，也体现了你的深度思考能力。</p>\n<p>这一点是我当了技术面试官才领会到的。当然，并不是每位技术面试官都是这么想的，但我觉得这应该是个更合适的方式。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "琴水玉"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "一位大龄程序员所经历的面试的历炼和思考",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer.html",
      "summary": "推荐语：本文的作者，今年 36 岁，已有 8 年 JAVA 开发经验。在阿里云三年半，有赞四年半，已是标准的大龄程序员了。在这篇文章中，作者给出了一些关于面试和个人能力提升的一些小建议，非常实用！ 内容概览： 个人介绍，是对自己的一个更为清晰、深入和全面的认识契机。 简历是充分展示自己的浓缩精华，也是重新审视自己和过往经历的契机。不仅仅是简要介绍技能和...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：本文的作者，今年 36 岁，已有 8 年 JAVA 开发经验。在阿里云三年半，有赞四年半，已是标准的大龄程序员了。在这篇文章中，作者给出了一些关于面试和个人能力提升的一些小建议，非常实用！</p>\n<p><strong>内容概览</strong>：</p>\n<ol>\n<li>个人介绍，是对自己的一个更为清晰、深入和全面的认识契机。</li>\n<li>简历是充分展示自己的浓缩精华，也是重新审视自己和过往经历的契机。不仅仅是简要介绍技能和经验，更要最大程度凸显自己的优势领域（差异化）。</li>\n<li>我个人是不赞成海投的，而倾向于定向投。找准方向投，虽然目标更少，但更有效率。</li>\n<li>技术探索，一定要先理解原理。原理不懂，就会浮于表层，不能真正掌握它。技术原理探究要掌握到什么程度？数据结构与算法设计、考量因素、技术机制、优化思路。要在脑中回放，直到一切细节而清晰可见。如果能够清晰有条理地表述出来，就更好了。技术原理探究，一定要看源码。看了源码与没看源码是有区别的。没看源码，虽然说得出来，但终是隔了一层纸；看了源码，才捅破了那层纸，有了自己的理解，也就能说得更加有底气了。当然，也可能是我缺乏演戏的本领。</li>\n<li>要善于从失败中学习。正是在杭州四个月空档期的持续学习、思考、积累和提炼，以及面试失败的反思、不断调整对策、完善准备、改善原有的短板，采取更为合理的方式，才在回武汉的短短两个周内拿到比较满意的 offer 。</li>\n<li>面试是通过沟通来理解双方的过程。面试中的问题，千变万化，但有一些问题是需要提前准备好的。</li>\n</ol>\n<p><strong>原文地址</strong>：https://www.cnblogs.com/lovesqcc/p/14354921.html</p>\n</blockquote>\n<p>从每一段经历中学习，在每一件事情中修行。善于从挫折中学习。</p>\n<h2>引子</h2>\n<p>我今年 36 岁，已有 8 年 JAVA 开发经验。在阿里云三年半，有赞四年半，已是标准的大龄程序员了。</p>\n<p>在多年的读书、学习和思考中，我的价值观、人生观和世界观也逐步塑造成型。我意识到自己的志趣在于做教育文化方面，因此在半冲动之下，8 月份下旬，裸辞去找工作了。有限理性难以阻挡冲动的个性。不建议裸辞，做事应该有规划、科学合理。</p>\n<p>尽管我最初认为自己“有理想有目标有意愿有能力”，找一份教育开发的工作应该不难，但事实上我还是过于乐观了。现实很快给我泼了一瓢瓢冷水。我屡战屡败，又屡败屡战。惊讶地发现自己还有这个韧性。面试是一项历炼，如果没有被失败击倒，那么从中会生长出一份韧性，这种韧性能让人走得更远。谁没有经历过失败的历练呢？失败是最伟大的导师了，如果你愿意跟他学一学的话。</p>\n<p>在面试的过程中，我很快发现自己的劣势：</p>\n<ul>\n<li>投入精力做业务，技术深度不够，对原理的理解局限于较浅的层次；</li>\n<li>视野不够开阔，局限于自己所做的订单业务线，对其它关联业务线（比如商品、营销、支付等）了解不够；</li>\n<li>思维不够开阔，大部分时间投入在开发和测试上，对运维、产品、业务、商业层面思考都思考不多；</li>\n<li>缺乏管理经验，年龄偏大；这两项劣势我一度低估，但逐渐凸显出来，甚至让我一度不自信，但最终我还是走出来了。</li>\n</ul>\n<p>但我也有自己的优势。职业竞争的基本法则是稀缺性和差异化。能够解决大型项目的架构设计和攻克技术难题，精通某个高端技术领域是稀缺性体现；而能够做事能做到缜密周全精细化，有高并发大流量系统开发经验，则是差异性体现。稀缺性是上策，差异化是中策，而降格以求就是下策了。</p>\n<p>我缺乏稀缺性优势，但还有一点差异化优势：</p>\n<ul>\n<li>对每一份工作都很踏实，时间均在 3 年 - 5 年之间，有一点大厂光环，能获得更多面试机会（虽然不一定能面上）；</li>\n<li>坚持写博客，孜孜不倦地追求软件开发的“道”，时常思考记录开发中遇到的问题及解决方案；</li>\n<li>做事认真严谨，能够从整体分析和思考问题，也很注重基础提升；</li>\n<li>对工程质量、性能优化、稳定性建设、业务配置化设计有实践经验；</li>\n<li>大流量微服务系统的长期开发维护经验。</li>\n</ul>\n<p>我投出简历的公司并不多。在不多的面试中，我逐渐意识到网上的“斩获几十家大厂 offer”的说法并不可信。理由如下：</p>\n<ul>\n<li>如果能真斩获大量大厂 offer ，面试的级别很大概率是初级工程师。要知道面试 4 年以上的工程师，面试的深度和广度令人发指，从基础的算法、到各种中间件的原理机制到实际运维架构，无所不包，真个是沉浸在“技术的海洋”，除非一个人的背景和实力非常强大，平时也做了非常深且广的沉淀；</li>\n<li>一个背景和实力非常强大的人，是不会有兴趣去投入这么多精力去面各种公司，仅仅是为了吹嘘自己有多能耐；实力越强的人，他会有自己的选择逻辑，投的简历会更定向精准。话说，他为什么不花更多精力投入在那些能够让他有最大化收益的优秀企业呢？</li>\n<li>培训机构做的广告。因为他们最清楚新手需要的是信心，哪怕是伪装出来的信心。</li>\n</ul>\n<p>好了，闲话不多说了。我讲讲自己在面试中所经受的历练和思考吧。</p>\n<h2>准备工作</h2>\n<p>人生或许很长，但面试的时间很短，最长不过一小时或一个半小时。别人如何在短短一小时内能够更清晰地认识长达三十多年的你呢？这就需要你做大量细致的准备工作了。在某种程度上，面试与舞蹈有异曲同工之妙：台上五分钟，台下十年功。</p>\n<p>准备工作主要包括简历准备、个人介绍、公司了解、技术探索、表述能力、常见问题、中高端职位、好的心态。准备工作是对自身和对外部世界的一次全面深入的重新认知。</p>\n<p>初期，我以为自己准备很充分，简历改改就完事了。随着一次次受挫，才发现自己的准备很不充分。在现在的我看来，准备七分，应变三分。准备，就是要知己知彼，知道对方会问哪些问题（通常是系统/项目/技术的深度和广度）、自己应当如何作答；应变，就是当自己遇到不会、不懂、不知道的问题时，如何合理地展示自己的解决思路，以及根据面试中答不上来的问题查漏补缺，夯实基础。</p>\n<p>这个过程，实际上也是学习的过程。持续的反思和提炼、学习新的内容、重新认识自己和过往经历等。</p>\n<h3>简历准备</h3>\n<p>最开始，我做得比较简单。把以前的简历拿出来，添加上新的工作经历，略作修改，但整体上模板基本不变。</p>\n<p>在基本面上，我做的是较为细致的，诚实地写上了自己擅长和熟悉的技能和经验经历，排版也尽力做得整洁美观（学过一些 UI 设计）。不浮夸也不故作谦虚。</p>\n<p>在扩展面上，我做的还是不够的。有一天，一位猎头打电话给我，问：“你最大的优势是什么？”。我顿时说不上来。当时也未多加思考。在后续面试屡遭失败之后，一度有些不自信之后，我开始仔细思考自己的优势来。然后将“对工程质量、性能优化、稳定性建设、业务配置化设计有深入思考和实践经验”写在了“技能素养”栏的第一行，因为这确实是我所做过的、最实在且脚踏实地的且具备概括性的。</p>\n<p>有时，简历内容的编排顺序也很重要。之前，我把掌握的语言及技术写在前面，而“项目管理能力和团队影响力”之类的写在后面。但投年糕妈妈之后，未有面试直接被拉到不合适里面，受到了刺激，我意识到或许是对方觉得我管理经验不足。因此，刻意将“项目管理能力和团队影响力”提到了前面，表示自己是重视管理方面的，不过，投过新的简历之后，没有回应。我意识到，这样的编排顺序可能会让人误解我是管理能力偏重的（事实上有一位 HR 问我是不是还在写代码），但实际上管理方面我是欠缺的，最后，我还是调回了原来的顺序，凸出自己“工程师的本色”。后面，我又做了一些语句的编排上的修改。</p>\n<p>随着面试的进展，有时，也会发现自己的简历上写得不够或者以前做得不够的地方。比如，在订单导出这段经历里，我只是写了大幅提升性能和稳定性，显得定性描述化，因此，我添加了一些量化的东西（2w 阻塞 =&gt; 300w+，1w/1min）作为证实；比如，8 月份离职，到 12 月份面试的时候，有一段空档期，有些企业会问到这个。因此，我索性加了一句话，说明这段时间我在干些啥；比如，代表性系统和项目，每一个系统和项目的价值和意义（不一定写在上面，但是心里要有数）。功夫要下足。</p>\n<p>再比如，我很详细地写了有赞的工作经历及经验，但阿里云的那段基本没动。而有些企业对这段经历更感兴趣，我却觉得没太多可说的，留在脑海里的只有少量印象深刻的东西，以及一些博客文章的记录，相比这段工作经历来说显得太单薄。这里实质上不是简历的问题，而是过往经历复盘的问题。建议，在每个项目结束后，都要写个自我复盘。避免时间将这些可贵的经历冲淡。</p>\n<p>每个人其实都有很多可说的东西，但记录下来的又有多少呢？值得谈道的有多少呢？过往不努力，面试徒伤悲。</p>\n<p><strong>简历更新的心得</strong>：</p>\n<ul>\n<li>简历是充分展示自己的浓缩精华，也是重新审视自己和过往经历的契机；</li>\n<li>不仅仅是简要介绍技能和经验，更要最大程度凸显自己的优势领域（差异化）；</li>\n<li>增强工作经历的表述，凸显贡献，赢得别人的认可；</li>\n<li>复盘并记录每一个项目中的收获，为跳槽和面试打下好的铺垫。</li>\n</ul>\n<h3>个人介绍</h3>\n<p>面试前通常会要求做个简要的个人介绍。个人介绍通常作为进入面试的前奏曲和缓冲阶段，缓和下紧张气氛。</p>\n<p>我最开始的个人介绍，个性啊业余生活啊工作经历啊志趣啊等等，似乎不知道该说些什么。实际上，个人介绍是一个充分展示自己的主页。主页应当让自己最最核心的优势一目了然（需要挖掘自己的经历并仔细提炼）。我现在的个人介绍一般会包括：个性（比如偏安静）、做事风格（工作认真严谨、注重质量、善于整体思考）、最大优势（owner 意识、执行力、工程把控能力）、工作经历简述（在每个公司的工作负责什么、贡献了什么、收获了什么）。个人介绍简明扼要，无需赘言。</p>\n<p>个人介绍，是对自己的一个更为清晰、深入和全面的认识契机。</p>\n<h3>公司了解</h3>\n<p>很多人可能跟我一样，对公司业务了解甚少，就直接投出去了。这样其实是不合理的。首先，我个人是不赞成海投的，而倾向于定向投。找准方向投，虽然目标更少，但更有效率。这跟租房一样，我一般在豆瓣上租房，虽然目标源少，但逮着一个就是好运。</p>\n<p>投一家公司，是因为这家公司符合意向，值得争取，而不是因为这是一家公司。就像找对象，不是为了找一个女人。要确定这家公司是否符合意向，就应当多去了解这家公司：主营业务、未来发展及规划、所在行业及地位、财务状况、业界及网络评价等。</p>\n<p>在面试的过程中适当谈到公司的业务及思考，是可加分项。亦可用于“你有什么想问的？”的提问。</p>\n<h3>技术探索</h3>\n<p>技术能力是一个技术人的基本素养。因此，我觉得，无论未来做什么工作，技术能力过硬，总归是最不可或缺的不可忽视的。</p>\n<p>原理和设计思想是软件技术中最为精髓的东西。一般软件技术可以分为两个方面：</p>\n<ul>\n<li>原理：事物如何工作的基本规律和流程；</li>\n<li>架构：如何组织大规模逻辑的艺术。</li>\n</ul>\n<p><strong>技术探索，一定要先理解原理。原理不懂，就会浮于表层，不能真正掌握它。技术原理探究要掌握到什么程度？数据结构与算法设计、考量因素、技术机制、优化思路。要在脑中回放，直到一切细节而清晰可见。如果能够清晰有条理地表述出来，就更好了。</strong></p>\n<p><strong>技术原理探究，一定要看源码。看了源码与没看源码是有区别的。没看源码，虽然说得出来，但终是隔了一层纸；看了源码，才捅破了那层纸，有了自己的理解，也就能说得更加有底气了。当然，也可能是我缺乏演戏的本领。</strong></p>\n<p>我个人不太赞成刷题式面试。虽然刷题确实是进厂的捷径，但也有缺点：</p>\n<ul>\n<li>它依然是别人的知识体系，而不是自己总结的知识体系；</li>\n<li>技术探究是为了未来的工作准备，而不是为了应对一时之需，否则即使进去了还是会处于麻痹状态。</li>\n</ul>\n<p>经过系统的整理，我逐步形成了适合自己的技术体系结构：<a href=\"https://www.cnblogs.com/lovesqcc/p/13633409.html\" target=\"_blank\" rel=\"noopener noreferrer\">“互联网应用服务端的常用技术思想与机制纲要”</a> 。在这个基础上，再博采众长，看看面试题进行自测和查漏补缺，是更恰当的方式。我会在这个体系上深耕细作。</p>\n<h3>表述能力</h3>\n<p>目前，绝大多数企业的主要面试形式是通过口头沟通进行的，少部分企业可能有笔试或机试。口头沟通的形式是有其局限性的。对表述能力的要求比较高，而对专业能力的凸显并不明显。一个人掌握的专业和经验的深度和广度，很难通过几分钟的表述呈现出来。往往深度和广度越大，反而越难表述。而技术人员往往疏于表达。</p>\n<p>我平时写得多说得少，说起来不利索。有时没讲清楚背景，就直接展开，兼之啰嗦、跳跃和回旋往复（这种方式可能更适合写小说），让面试官有时摸不着头脑。表述的条理性和清晰性也是很重要的。不妨自己测试一下：Dubbo 的架构设计是怎样的？ Redis 的持久化机制是怎样的？然后自己回答试试看。</p>\n<p>表述能力的基本法则：</p>\n<ul>\n<li>先总后分，先整体后局部；</li>\n<li>先说基本思路，然后说优化；</li>\n<li>体现互动。先综述，然后向面试官询问要听哪方面，再分述。避免自己一脑瓜子倾倒出来，让面试官猝不及防；系统设计的场景题，多问一些要求，比如时间要求、空间要求、要支持多大数据量或并发量、是否要考虑某些情况等。</li>\n</ul>\n<h3>常见问题</h3>\n<p>面试是通过沟通来理解双方的过程。面试中的问题，千变万化，但有一些问题是需要提前准备好的。</p>\n<p>比如“灵魂 N 问”：</p>\n<ul>\n<li>你为什么从 XXX 离职？</li>\n<li>你的期望薪资是多少？</li>\n<li>你有一段空档期，能解释下怎么回事么？</li>\n<li>你的职业规划是怎样的？</li>\n</ul>\n<p>高频技术问题：</p>\n<ul>\n<li>基础：数据结构与算法、网络；</li>\n<li>微服务：技术体系、组件、基础设施等；</li>\n<li>Dubbo：Dubbo 整体架构、扩展机制、服务暴露、引用、调用、优雅停机等；</li>\n<li>MySQL：索引与事务的实现原理、SQL 优化、分库分表；</li>\n<li>Redis : 数据结构、缓存、分布式锁、持久化机制、复制机制；</li>\n<li>分布式：分布式事务、一致性问题；</li>\n<li>消息中间件：原理、对比；</li>\n<li>架构：架构设计方法、架构经验、设计模式；</li>\n<li>性能优化：JVM、GC、应用层面的性能优化；</li>\n<li>并发基础：ConcurrentHashMap, AQS, CAS，线程池等；</li>\n<li>高并发：IO 多路复用；缓存问题及方案；</li>\n<li>稳定性：稳定性的思想及经验；</li>\n<li>生产问题：工具及排查方法。</li>\n</ul>\n<h3>中高端职位</h3>\n<p>说起来，我这人可能有点不太自信。我是怀着“踏实做一个工程师”的思想投简历的。</p>\n<p>对于大龄程序员，企业的期望更高。我的每一份“高级工程师”投递，自动被转换为“技术专家”或“架构师”。无力反驳，倍感压力。面试中高端职位，需要更多准备：</p>\n<ul>\n<li>你有带团队经历吗？</li>\n<li>在你 X 年的工作经历中，有多少时间用于架构设计？</li>\n<li>架构过程是怎样的？你有哪些架构设计思想或方法论？</li>\n</ul>\n<p>如果不作准备，就被一下子问懵，乱了阵脚。实际上，我或许还是存着侥幸心理把“技术专家”和“架构师”岗位当做“高工”来面试的，也就无一不遭遇失败了。显然，我把次序弄反了：应当以“技术专家”和“架构师”的规格来面试高级工程师。</p>\n<p>好吧，那就迎难而上吧！我不是惧怕挑战的人。</p>\n<p>此外，“技术专家”和“架构师”职位应当至少留一天的时间来准备。已经有丰富经验的技术专家和架构师可以忽略。</p>\n<h3>好的心态</h3>\n<p>保持好的心态也尤为重要。我经历了“乐观-不自信-重拾信心”的心态变化过程。</p>\n<p>很长一段时间，由于“求成心切”，生怕某个技术问题回答不上来搞砸，因此小心谨慎，略显紧张，结果已经梳理好的往往说不清楚或者说得不够有条理。冲着“拿 offer ”的心态去面试，真的很难受，会觉得每场面试都很被动那么难过，甚至有点想要“降格以求”。</p>\n<p>有时，我在想：咋就混成这个样子了呢？按理来说，这个时候我应该有能力去追求自己喜爱的事业了啊！还是平时有点松懈了，视野狭窄，积累不够，导致今天的不利处境。</p>\n<p>我是一个守时的人，也希望对方尽可能守时。杭州的面试官中，基本是守时的，即使迟到也在心理接受范围内，回武汉面试后，节奏就有点被少量企业带偏了。有一两次，我甚至不确定面试官什么时候进入会议。我想，难道这是人才应该受到的“礼待”吗？我有点被轻微冒犯的感觉了。不过我还是“很有涵养地”表示没事。但我始终觉得：面试官迟到，是对人才的不尊重。进入不尊重人才的公司，我是怀有疑虑的。良禽择木而栖，良臣择主而事。难道我能因为此刻的不利处境，而放弃一些基本的原则底线，而屈从于一份不尊重人才的 offer 吗？</p>\n<p>我意识到：一个人应当用其实力去赢得对方的尊重和赏识，以后的合作才会更顺畅。不若，哪怕惜其无缘，亦不可强留。无论别人怎么存疑，心无旁骛地打磨实力，挖掘自己的才干和优势，终会发出自己的光芒。因此，我的心态顿时转变了：应当专注去沟通，与对方充分认识了解，赢得对方心服的认可，而不是拿到一张入门券，成为干活的工具。</p>\n<p>有一个“石头和玉”的小故事，把自己当做人才，并努力去提升自己，才能获得“人才的礼遇”；把自己当石头贱卖，放松努力，也就只能得到“石头的礼遇”。尽管一个人不一定马上就具备人才的能力，但在自己的内心里，就应当从人才的视角去观察待入职的企业，而不仅仅是为了找一份“赚更多钱”的工作。</p>\n<p>此外，焦虑也是不必要的。焦虑的实质是现实与目标的差距。一个人总可以评估目标的合理性及如何达成目标。如果目标过高，则适当调整目标级别；目标可行，则作出合理的决策，并通过持续的努力和恰当的出击来实现目标。决策、努力和出击能力都是可以持续修炼的。</p>\n<h2>面试历炼</h2>\n<p>技术人的面试还是更偏重于技术，因此，技术的深度和广度还是要好好准备的。面试官和候选人的处境是不一样的，一个面试官问的只是少量点，但是多个面试官合起来就是一个面。明白这一点，作为面试官的你就不要忘乎所以，以为自己就比候选人厉害。</p>\n<p>我面的企业不多，因为我已经打算从事教育事业，用“志趣和驱动力”这项就直接过滤了很多企业的面试邀请。在杭州面试的基本是教育企业，连阿里华为等抛来的橄榄枝都婉拒了（尽管我也不一定能面上）。虽然做法有点“直男”，但投入最多精力于自己期望从事的行业和事业，才是值得的。</p>\n<p>我所认为的教育事业，并不局限于现在常谈起的在线教育或 K12 教育，而是一个教育体系，任何可以更好滴起到教育效果的事业，包括而不限于教学、阅读、音乐、设计等。</p>\n<h3>接力棒科技-高工</h3>\n<p>面的第一家。畅谈一番后，没音讯了。但我也没有太在意。面试官问的比较偏交易业务性的东西，较深的就是如何保证应用的数据一致性了。</p>\n<p>此时的我，就像在路上扔了一颗探路的小石子，尚未意识到自己的处境。</p>\n<h3>网易云音乐-高工</h3>\n<p>接着是网易云音乐。大厂就是大厂。一面问的尽是缓存、分布式锁、Dubbo、ZK， MQ 中间件相关的机制。很遗憾，由于我平时关于技术原理的沉淀还是很少，基本是“一问两不知”，挂得很出彩。</p>\n<p>此时，我初步意识到自己的技术底子还很薄弱，也就开始了广阔的技术学习和夯实，自底向上地梳理原理和逻辑，系统地进行整理总结，最终初步形成了自己的互联网服务端技术知识体系结构。</p>\n<h3>铭师堂-技术专家</h3>\n<p>架构师面试的。问的相对多了一些，DB, Redis 等。反馈是技术还行，但缺乏管理经验。这是我第一次意识到大龄程序员缺乏管理经验的不利。中小企业的技术专家线招聘中，往往附加了管理经验的需求。应聘时要注意。</p>\n<p>缺乏管理经验，该怎么办呢？思考过一段时间后，我的想法是：</p>\n<ul>\n<li>改变能改变的，不能改变的，学习它。比如技术原理的学习是我能够改变的，但管理经验属于难以一时改变的，那就多了解点管理的基本理论吧。</li>\n<li>从经历中挖掘相关经验。虽然我没有正式带团队的实际经验，但是有带项目和带工程师，管控某个业务线的基本管理经验。多多挖掘自己的经历。</li>\n</ul>\n<h3>字节教育-高工</h3>\n<p>字节教育面试，我给自己挖了不少坑往里跳。</p>\n<p>比如面试官问，讲一个你比较成就感的项目经历。我选择的是近 4 年前的周期购项目。虽然这是我入职有赞的第一个有代表性的项目，但时间太久，又没有详细记录，很多技术细节遗忘不清晰了。我讲到当时印象比较深的“一体化”设计思想，却忘记了当时为什么会有这种思想（未做仔细记录）。</p>\n<p>再比如，一个上课的场景题，我问是用 CS 架构还是 BS 架构？面试官说用 CS 架构吧。这不是给自己挖坑吗？明明自己不熟悉 CS 架构，何必问这个选择呢，不如直接按照 BS 架构来讲解。哎！</p>\n<p>字节教育给我的反馈是：业务 Sense 不错，系统设计能力有待提高。我觉得还是比较中肯的。因此，也开始注重系统设计实战方面的文章阅读和思考训练。</p>\n<p>经验是：</p>\n<ul>\n<li>做项目时，要详细记录每个项目的技术栈、技术决策及原因、技术细节，为面试做好铺垫；</li>\n<li>提前准备好印象最深刻的最代表性的系统和项目，避免选择距离当前时间较久的缺乏详细记录的项目；</li>\n<li>选择熟悉的项目和架构，至少有好的第一印象，不然给面试官的印象就是你啥都不会。</li>\n</ul>\n<h3>咪咕数媒-架构师</h3>\n<p>好家伙，一下子 3 位面试官群面。可能我以前经历的太少了吧。似乎国企面试较高端职位，喜欢采取这种形式。兼听则明偏听则暗嘛。问的问题也很广泛，从 ES 的基本原理，到机房的数据迁移。有些技术机制虽然学习过，但不牢固，不清晰，答的也不好。比如 ES 的搜索原理优化，讲过倒排索引后，我对 Term Index 和 Trie 树 讲不清楚。这说明，知道并不代表真正理解了。只有能够清晰有条理地把思路和细节都讲清楚，才算是真正理解了。</p>\n<p>印象深刻的是，有一个问题：你有哪些架构思想？这是第一次被问到架构设计方面的东西，我顿时有点慌乱。虽然平时多有思考，也有写过文章，却没有形成系统精炼的方法论，结果就是答的比较凌乱。</p>\n<h3>涂鸦智能-高工</h3>\n<p>应聘涂鸦智能，是因为我觉得这家企业不错。优秀的企业至少应该多沟通一下，说不准以后有合作机会呢！看问题的思维要开阔一些，不能死守在自己想到的那一个事情上。</p>\n<p>涂鸦智能给我的整体观感还是不错的。面试官也很有礼貌有耐心，整体架构、技术和项目都问了很多，问到了我熟悉的地方，答得也还可以。也许我的经验正好是切中他们的需求吧。</p>\n<p>若不是当时想做教育的执念特别强，我很大概率会入职涂鸦智能。物联网在我看来应该是很有趣的领域。</p>\n<h3>跟谁学-技术专家</h3>\n<p>“跟谁学”基本能答上来。不过反馈是：对于提问抓重点的能力有所欠缺，对于技术的归纳整理也不够。我当时还有点不服气，认为自己写了那么多文章，也算是有不少思考，怎能算是总结不够呢？顶多是有技术盲点。技术犹如海洋，谁能没有盲点？</p>\n<p>不过现在反观，确实距离自己应该有的程度不够。对技术原理机制和生产问题排查的总结不够，不够清晰细致；对设计实践的经验总结也不够，不够系统扎实。这个事情还要持续深入地去做。</p>\n<p>此外，面得越多，越发现自己的表述能力确实有所欠缺。啰嗦、容易就一点展开说个没完、脱离背景直接说方案、跳跃、回旋往复，然后面试官很可能没耐心了。应该遵循“先总后分”、“基本思路-实现-优化”的一些基本逻辑来作答会更好一些。表述能力真的很重要，不可只顾着敲代码。还有每次面教育企业就不免紧张，生怕错过这个机会。</p>\n<p>这是第二家直接告诉我年龄与经验不匹配的企业，加深了我对年龄偏大的忧虑，以致于开始有点不自信了。</p>\n<p>那么我又是怎么重拾信心的呢？有一句老话：“留得青山在，不怕没柴烧”。就算我年龄比较大，如果我的技术能力打磨得足够硬朗，就不信找不到一家能够认可我的企业。大不了我去做开源项目好了。具备好的技术能力，并不一定就局限在企业的范围内去发挥作用，也没必要局限于那些被年龄偏见所蒙蔽的人的认知里。外界的认可固然重要，内在的可贵性却远胜于外在。</p>\n<h3>亿童文教-架构师</h3>\n<p>也是采用的 3 人同时面试。主要问的是项目经历，技术方面问得倒不是深入。个人觉得答得还行。面试官也问了架构设计相关的问题，我答得一般。此时，我仍然没有意识到自己在以面“高级工程师”的规格来面试“架构师”岗位。</p>\n<p>面试官比较温和，HR 也在积极联系和沟通，感觉还不错。只是，我没有主动去问反馈意见，也就没有下文了。</p>\n<h3>新东方-高工</h3>\n<p>面试新东方，主要是因为切中我做教育的期望，虽然职位需求是做信息管理系统，距离我理想中的业务还有一定距离。经过沟通了解，他们更需要的是对运维方面更熟悉的工程师，不过我正好对运维方面不太熟悉，平时关注不多，因此不太符合他们的真实招聘要求。面试官也是很温和的人，老家在宜昌，是我本科上大学的地方，面试体验不错。</p>\n<p>以后要花些时间学习一些运维相关的东西。作为一名优秀的工程师和合格的架构师，是要广泛学习和熟悉系统所采用的各种组件、中间件、运维部署等的。要有综观能力，不过我醒悟的可能有点迟。Better later than never.</p>\n<h3>ZOOM-高工</h3>\n<p>ZOOM 的一位面试官或许是我见过的所有面试官中最差劲的。共有两位面试官，一位显得很有耐心，另一位则挺着胖胖的肚子，还打着哈欠，一副不怎么关心面试和候选人的样子。我心想，你要不想面，为啥还要来面呢？你以为候选人就低你一等么？换个位置我可以暴打你。不过我还是很有礼貌的，当做什么事也没发生。公司在挑人，候选人也在挑选公司。</p>\n<p>想想，ZOOM 还是疫情期间我们公司用过的远程通信会议软件。印象还不错，有这样的工程师和面试官藏于其中，我也是服了。难倒他是传说中的大大神？据我所知，国外对国内的互联网软件技术设施基本呈碾压态势，中国大部分企业所用的框架、中间件、基础设施等基本是拿国外的来用或者做定制化，真正有自研的很少，有什么好自满的呢？</p>\n<h3>阿优文化-高工</h3>\n<p>阿优文化有四轮技术面。其中第一个技术面给我印象比较深刻。看上去，面试官对操作系统的原理机制特别擅长和熟悉。很多问题我都没答上来。本以为挂了，不过又给了扳回一局的机会。第二位面试问的项目经历和技术问题是我很熟悉的。第三位面试官问的比较广泛，有答的上来的，有答不上来的。不过面试官很耐心。第四位是技术总监，也问得很广泛细致。</p>\n<p>整体来说，面试氛围还是很宽松的。不过，阿优当时的招聘需求并不强烈，估计是希望后续有机会时再联系我。可惜我那时准备回武汉了。主要是考虑父母年事已高，希望能多陪陪父母。</p>\n<p>想想，我想问题做决策还是过于简单的，不会做很复杂的计算和权衡。</p>\n<h3>小米-专家/架构</h3>\n<p>应聘小米，主要是因为职位与之前在有赞做的很相似，都是做交易中台相关。浏览小米官网之后，觉得他们做的事情很棒，可是与我想做教育文化事业的初衷不太贴合。</p>\n<p>加入小米的意愿不太强烈，面试也就失去了大半动力。我这个性子还是要改一改。</p>\n<h3>视觉中国-高工</h3>\n<p>围绕技术、项目和经历来问。总体来说，技术深度并不是太难，项目方面也涉及到了。人力面前辈很温和，我以为会针对自己的经历进行一番“轰炸”，结果是为前辈讲了讲有赞的产品服务和生意模式，然后略略带了下自己的一些经历。</p>\n<h3>科大讯飞-架构师</h3>\n<p>一二面，感觉面试官对安排的面试不太感兴趣。架构师，至少是一个对技术和设计能力非常高要求的职位。一面的技术和架构都问了些，二面总围绕我的背景和非技术相关的东西问，似乎对我的外在更关注，而对我自身的技术和设计能力不感兴趣。交流偏浅。</p>\n<p>能力固然有高下之分，但尊重人才的基本礼节却是不变的。尊重人才，是指聚焦人才的能力和才学，而不是一些与才学不甚相关的东西。</p>\n<h3>青藤云-高工</h3>\n<p>青藤云的技术面试风格是温和的。感受到坦率交流的味道，被认可的感觉。感受到 HR 求才若渴的心情。和我之前认为的“应当用其实力去赢得对方的尊重和赏识”不谋而合。</p>\n<h3>腾讯会议-高工</h3>\n<p>和腾讯面试官是用腾讯会议软件面试腾讯会议的职位。哈哈。由于网络不太稳定，面试过程充满了磕磕碰碰，一句话没说完整就听不清楚了。可想情况如何。但是我们都很有很有很有耐心，最终一起完成了一面。面试是双方智慧与力量的较量，更是双方一起去完成一件事情、发现彼此的合作。这样想来，传统的“单方考验筛选式”的面试观念需要革新。</p>\n<p>由于我已经拿到 offer , 且腾讯会议的事情并不太贴合自己的初衷，因此，我与腾讯方面沟通，停止了二面。</p>\n<h3>最终选择</h3>\n<p>当拿到多个 offer 时，如何选择呢？我个人主要看重：</p>\n<ol>\n<li>志趣与驱动力；</li>\n<li>薪资待遇；</li>\n<li>公司发展前景和个人发展空间；</li>\n<li>工作氛围；</li>\n<li>小而有战斗力的企业。</li>\n</ol>\n<p>在视觉中国与青藤云之间如何选择？作个对比：</p>\n<ul>\n<li>薪资待遇：两者的薪资待遇不相上下，也都是认可我的；视觉中国给出的是 Leader 的职位，而青藤云给出的是核心业务的承诺；</li>\n<li>工作氛围：青藤云应该更偏工程师文化氛围，而视觉中国更偏业务化；</li>\n<li>挑战性：青藤云的技术挑战更强，而视觉中国的业务挑战性更强；</li>\n<li>志趣与驱动力：视觉中国更符合我想做文化的事情，而青藤云安全并不贴合我想做教育文化事业的初衷，而且比较偏技术和底层（我更希望做一些人文性的事情）。但青藤云做的是关于安全的事情，安全是一件很有价值很有意义的事情。而且，以后安全也可以服务于教育行业。有点曲线救国的味道。尤其是创始人张福的理想主义信念“让安全之光照亮互联网的每个角落”及自己的身体力行，让人更有一些触动。最终，我觉得做安全比做图片版权保护稍胜出一小筹。</li>\n</ul>\n<p>此外，我觉得做教育，更适合自己的是编程教育，或者是工程师教育。我还想成为一名系统设计师。还需要积累更多生产实践经验。可以多与初中级工程师打交道，在企业内部做培训指导。或者工作之余录制视频，上传到 B 站，服务广大吃瓜群众。将来，我或许还会写一本关于编程设计的书，汇聚毕生所学。</p>\n<p>因此，经过一天慎重的考虑，我决定，加入青藤云安全。当然，做这个选择的同时，也意味着我选择了一个更大的挑战：在安全方面我基本一穷二白，需要学习很多很多的知识和经验，对于我这个大龄程序员来说，是一项不小的挑战。</p>\n<h2>小结</h2>\n<p>很多事情都有解决的方法，即使“头疼的”大龄程序员找工作也不例外。确立明确清晰的目标、制定科学合理的决策、持续的努力、掌握基本面、恰当的出击，终能斩获胜利的果实。但要强调一下：功夫在平时。平时要是不累积好，面试的时候就要花更多时间去学习，会受挫、磕磕碰碰、过得也不太舒坦。还是平摊到平时比较好。此外，平时视野也要保持开阔，切忌在面试的时候才“幡然醒悟”。</p>\n<p>一个重要经验是，要善于从失败中学习。正是在杭州四个月空档期的持续学习、思考、积累和提炼，以及面试失败的反思、不断调整对策、完善准备、改善原有的短板，采取更为合理的方式，才在回武汉的短短两个周内拿到比较满意的 offer 。</p>\n<p>此外，值得提及的是，对于技术人员，写博客是一件很有价值的事情。面试通过沟通去了解对方，有其局限性所在。面试未能筛选出符合的人才其实是有比较大概率的：</p>\n<ol>\n<li>面试的时间很短，即使是很有经验的面试官，也会看走眼（根本局限性）；</li>\n<li>面试官问到的正好是自己不会的（运气问题）；</li>\n<li>面试官情绪不好，没兴趣（运气问题）；</li>\n<li>面试官自身的水平。</li>\n</ol>\n<p>因此，具备真才实学而被 PASS 掉，并不值得伤心。写博客的意义在于，有更多展示自己思考和平时工作的维度。</p>\n<p>尊重人才的企业，一定是希望从多方面去认识候选人（在优点和缺点之间选择确认是否符合期望），包括博客；不尊重人才的企业，则会倾向于用偷懒的方法，对候选人真实的本领不在意，用一些外在的标准去快速过滤，固然高效，最终对人才的识别能力并不会有多大进步。</p>\n<p>经过这一段面试的历炼，我觉得现在相比离职时的自己，又有了不少进步的。不说脱胎换骨，至少也是蜕了一层皮吧。差距，差距还是有的。起码面试那些知名大厂企业的技术专家和架构师还有差距。这与我平时工作的挑战性、认知视野的局限性及总结不足有关。下一次，我希望积蓄足够实力做到更好，和内心热爱的有价值有意义的事情再近一些些。</p>\n<p>面试，其实也是一段工作经历。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "琴水玉"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "斩获 20+ 大厂 offer 的面试经验分享",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies.html",
      "summary": "推荐语：很实用的面试经验分享！ 原文地址：https://mp.weixin.qq.com/s/HXKg6-H0kGUU2OA1DS43Bw 突然回想起当年，我也在秋招时也斩获了 20+的互联网各大厂 offer。现在想起来也是有点唏嘘，毕竟拿得再多也只能选择一家。不过许多朋友想让我分享下互联网面试方法，今天就来给大家仔细讲讲打法！ 如今金九银十已经过...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：很实用的面试经验分享！</p>\n<br>\n<p><strong>原文地址</strong>：https://mp.weixin.qq.com/s/HXKg6-H0kGUU2OA1DS43Bw</p>\n</blockquote>\n<p>突然回想起当年，我也在秋招时也斩获了 20+的互联网各大厂 offer。现在想起来也是有点唏嘘，毕竟拿得再多也只能选择一家。不过许多朋友想让我分享下互联网面试方法，今天就来给大家仔细讲讲打法！</p>\n<p>如今金九银十已经过去，满是硝烟的求职战场上也只留下一处处炮灰。在现在这段日子，又是重新锻炼，时刻准备着明年金三银四的时候。</p>\n<p>对于还没毕业的学生来说，明年三四月是春招补招或者实习招聘的机会；对于职场老油条来说，明年三四月也是拿完年终奖准备提桶跑路的时候。</p>\n<p>所以这段日子，就需要好好准备积累面试方法以及面试经验，明年的冲锋陷阵打下基础。这篇文章将为大家讲讲，程序员应该如何准备好技术面试。</p>\n<p>一般而言，互联网公司技术岗的招聘都会根据需要设置为 3 ～ 4 轮面试，一些 HC 较少的岗位可能还会经历 5 ～ 8 轮面试不等。除此之外，视公司情况，面试之前还可能也会设定相应的笔试环节。</p>\n<p>多轮的面试中包括技术面和 HR 面。相对来说，在整体的招聘流程中，技术面的决定性比较重要，HR 面更多的是确认候选人的基本情况和职业素养。</p>\n<p>不过在某些大厂，HR 也具有一票否决权，所以每一轮面试都该好好准备和应对。技术面试一般可分为五个部分：</p>\n<ol>\n<li>双方自我介绍</li>\n<li>项目经历</li>\n<li>专业知识考查</li>\n<li>编码能力考察</li>\n<li>候选人 Q&amp;A</li>\n</ol>\n<h2>双方自我介绍</h2>\n<p>面试往往是以自我介绍作为开场，很多时候一段条理清晰逻辑明确的开场会决定整场面试的氛围和节奏。</p>\n<p><strong>作为候选人，我们可以在自我介绍中适当的为本次面试提供指向性的信息，以辅助面试官去发掘自己身上的亮点和长处</strong>。</p>\n<p>其实自我介绍并不是简单的个人基本情况的条条过目，而是对自己简历的有效性概括。</p>\n<p>什么是有效性概括呢，就是意味着需要对简历中的信息进行核心关键词的提取整合。一段话下来，就能够让面试官对你整体的情况有了了解，从而能够引导面试官的联系提问。</p>\n<h2>项目经历</h2>\n<p>项目经历是面试过程中非常重要的一环，特别是在社招的面试中。一般社招的职级越高，往往越看重项目经历。</p>\n<p>而对于一般的校招生而言，几份岗位度匹配度以及项目完整性高的项目经历可以成为面试的亮点，也是决定于拿<code>SP</code> or <code>SSP</code>的关键。</p>\n<p>但是准备好项目经历，并不是一件容易的事情。很多人并不清楚应该怎样去描述自己的项目，更不知道应该在经历中如何去体现自己的优势和亮点。</p>\n<p>这里针对项目经历给大家提几点建议：</p>\n<p><strong>1、高效有条理的描述</strong></p>\n<p>项目经历的一般是简历里篇幅最大的部分，所以在面试时这部分同样重要。在表述时，语言的逻辑和条理一定要清晰，以保证面试官能够在最快的时间抓到你的项目的整体思路。</p>\n<p>相信很多人都听说过写简历的各种原则，比如<code>STAR</code>、<code>SMART</code>等。但实际上这些原则都可以用来规范自己的表达逻辑。</p>\n<p><code>STAR</code>原则相对简单，用来在面试过程中规范自己的条理非常有效。所谓<code>STAR</code>，即<code>Situation</code>、<code>Target</code>、<code>Action</code>、<code>Result</code>。这跟写论文写文档的逻辑划分大体一致。</p>\n<ul>\n<li><code>Situation</code>: 即项目背景，需要将项目提出的原因、现状以及出发点表述清楚。简单来说，就是要将项目提出的来龙去脉描述清晰。比如某某平台建设的原因，是切入用户怎样的痛点之类的。</li>\n<li><code>Target</code>: 即项目目标，这点描述的是项目预期达到或完成的程度。**最好是有可量化的指标和预期结果。**比如性能优化的指标、架构优化所带来的业务收益等等。</li>\n<li><code>Action</code>: 即方法方案，意味着完成项目具体实施的行为。这点在技术面试中最为重要，也是表现候选人能力的基础。**项目的方法或方案可以从技术栈出发，根据采用的不同技术点来具体写明解决了哪些问题。**比如用了什么框架/技术实现了什么架构/优化/设计，解决了项目中什么样的问题。</li>\n<li><code>Result</code>: 即项目获得结果，这点可以在面试中讲讲自己经历过项目后的思考和反思。这样会让面试官感受到你的成长和沉淀，会比直接的结果并动人。</li>\n</ul>\n<p><strong>2、充分准备项目亮点</strong></p>\n<p>说实话，大部分人其实都没有十分亮眼的项目，但是并不意味着没有项目经历的亮点。特别是在面试中。</p>\n<p>在面试中，你可以通过充分的准备以及深入的思考来突出你的项目亮点。比如可以从以下几个方向入手：</p>\n<ul>\n<li>充分了解项目的业务逻辑和技术架构</li>\n<li>熟悉项目的整体架构和关键设计</li>\n<li>明确的知道业务架构或技术方案选型以及决策逻辑</li>\n<li>深入掌握项目中涉及的组件以及框架</li>\n<li>熟悉项目中的疑难杂症或长期遗留 bug 的解决方案</li>\n<li>......</li>\n</ul>\n<h2>专业知识考查</h2>\n<p>有经验的面试官往往会在对项目经历刨根问底的同时，从中考察你的专业知识。</p>\n<p>所谓专业知识，对于程序员而言就是意向岗位的计算机知识图谱。对于校招生来说，大部分都是计算机基础；而对于社招而言，很大部分可能是对应岗位的技能树。</p>\n<p>计算机基础主要就是计算机网络、操作系统、编程语言之类的，也就是所谓的八股文。虽然这些东西在实际的工作中可能用处并不多，但是却是面试官评估候选人潜力的标准。</p>\n<p>而对应岗位的技能树就需要根据具体的岗位来划分，<strong>比如说客户端岗位可能会问移动操作系统理解、端性能优化、客户端架构以及跨端框架之类的。跟直播视频相关的岗位，还会问音视频处理、通信等相关的知识。</strong></p>\n<p>而后端岗位可能就更偏向于<strong>高可用架构、事务理论、分布式中间件以及一些服务化、异步、高可用可扩展的架构设计思想</strong>。</p>\n<p>总而言之，工作经验越丰富，岗位技术能的问题也就越深入。</p>\n<p>怎么在面试前去准备这些技术点，在这里我就不过多说了， 因为很多学习路线以及说的很清楚了。</p>\n<p>这里我就讲讲在应对面试的时候，该怎样去更好的表达描述清楚。</p>\n<p>这里针对专业知识考察给大家提几点建议：</p>\n<p><strong>1、提前建立一份技术知识图谱</strong></p>\n<p>在面试之前，可以先将自己比较熟悉的知识点做一个简单的归纳总结，根据不同方向和领域画个简单的草图。这是为了辅助自己在面试时能够进行合理的扩展和延伸。</p>\n<p>面试官一问一答形式的面试总是会给人不太好的面试体验，所以在回答技术要点的过程中，要善于利用自己已有的知识图谱来进行技术广度的扩展和技术深度的钻研。这样一来能够引导面试官往你擅长的方向去提问，二来能够尽可能多的展现自己的亮点。</p>\n<p><strong>2、结合具体经验来总结理解</strong></p>\n<p>技术点本身都是非常死板和冰冷的，但是如果能够将生硬的技术点与具体的案例结合起来描述，会让人眼前一亮。同时也能够表明自己是的的确确理解了该知识点。</p>\n<p>现在网上各种面试素材应有尽有，可能你背背题就能够应付面试官的提问。但是面试官也同样知道这点，所以他能够很清楚的判别出你是否在背题。</p>\n<p>因此，结合具体的经验来解释表达问题是能够防止被误认为背题的有效方法。可能有人会问了，那具体的经验哪里去找呢。</p>\n<p>这就得靠平时的积累了，平时需要多积累沉淀，多看大厂的各类技术输出。经验不一定是自己的，也可以是从别的地方总结而来的。</p>\n<p>此外，也可以结合自己在做项目的过程中的一些技术选型经验以及技术方案更新迭代的过程进行融会贯通，相互结合的来进行表述。</p>\n<h2>编码能力考察</h2>\n<p>编码能力考察就是咱们俗称的手撕代码，也是许多同学最害怕的一关。很多人会觉得面试结果就是看手撕代码的表现，但其实并不一定。</p>\n<p>**首先得明确的一点是，编码能力不完全等于算法能力。**很多同学面试时候算法题明明写出来了，但是最终的面试评价却是编码能力一般。还有很多同学面试时算法题死活没通过，但是面试官却觉得他的编码能力还可以。</p>\n<p>所以一定要注意区分这点，编码能力不完全等于算法能力。从公司出发，如果纯粹为了出难度高的算法题来筛选候选人，是没有意义的。因为大家都知道，进了公司可能工作几年都写不了几个算法。</p>\n<p>要记住，做算法题只是一个用来验证编码能力和逻辑思维的手段和方式。</p>\n<p>当然说到底，在准备这一块的面试时，算法题肯定得刷，但是不该盲目追求难度，甚至是死记硬背。</p>\n<p>几点面试时的建议：</p>\n<p><strong>1、数据结构和算法思想是基础</strong></p>\n<p>算法本身实际上是逻辑思考的产物，所以掌握算法思想比会做某一道题要更有意义。数据结构是帮助实现算法的工具，这也很编程的基本能力。所以这二者的熟悉程度是手撕代码的基础。</p>\n<p><strong>2、不要忽视编码规范</strong></p>\n<p>这点就是提醒大家要记住，就算是一段很简单的算法题也能够从中看出你的编码能力。这往往就体现在一些基本的编码规范上。你说你编程经验有 3 年，但是发现连基本的函数封装类型保护都不会，让人怎么相信呢。</p>\n<p><strong>3、沟通很重要</strong></p>\n<p>手撕代码绝对不是一个闭卷考试的过程，而是一个相互沟通的过程。上面也说过，考察算法也是为了考察逻辑思维能力。所以让面试官知道你思考问题的思路以及逻辑比你直接写出答案更重要。</p>\n<p>不仅如此，提前沟通清楚思路，遇到题意不明确的地方及时询问，也是节省大家时间，给面试官留下好印象的机会。</p>\n<p>此外，自己写的代码一定要经得住推敲和质疑，自己能够讲的明白。这也是能够区分「背题」和「真正会做」的地方。</p>\n<p>最后，如果代码实在写不出来，但是也可以适当的表达自己的思路并与面试官交流探讨。毕竟面试也是一个学习的过程。</p>\n<h2>候选人 Q&amp;A</h2>\n<p>一般正常的话，都会有候选人反问环节。倘若没有，可能是想让你回家等消息。</p>\n<p>反问环节其实也可以是面试中重要的环节，因为这个时候你能够从面试官口中获得关于公司关于岗位更具体真实的信息。</p>\n<p>这些信息可以帮助我们做出更全面更理性的决策，毕竟求职也是一个双向选择的过程。</p>\n<h2>加分项</h2>\n<p>最后，给能够坚持看到最后的同学一个福利。我们来谈谈面试中的加分项。</p>\n<p>很多同学会觉得明明面试时候的问题都答上来了，但是最终却没有通过面试，或者面试评价并不高。这很有可能就是面试过程中缺少了亮点，可能你并不差，但是没有打动面试官的地方。</p>\n<p>一般面试官会从下面几个方面去考察候选人的亮点：</p>\n<p><strong>1、沟通</strong></p>\n<p>面试毕竟是问答与表达的艺术，所以你流利的表达，清晰有条理的思路自然能够增加面试官对你的高感度。同时如果还具有举一反三的思维，那也能够从侧面证明你的潜力。</p>\n<p><strong>2、匹配度</strong></p>\n<p>这一点毋庸置疑，但是却很容易被忽视。因为往往大家都会认为，匹配度不高的都在简历筛选阶段被刷掉了。但其实在面试过程中，面试官同样也会评估面试人与岗位的匹配度。</p>\n<p>这个匹配度与工作经历强相关，与之前做过的业务和技术联系很大。特别是某些垂直领域的技术岗位，比如财经、资金、音视频等。</p>\n<p>所以在面试中，如若有跟目标岗位匹配度很高的经历和项目，可以着重详细介绍。</p>\n<p><strong>3、高业绩，有超出岗位的思考</strong></p>\n<p>这点就是可遇不可及，毕竟不是所有人都能够拿着好业绩然后跳槽。但是上一份工作所带来的好业绩，以及在重要项目中的骨干身份会为自己的经历加分。</p>\n<p>同时，如果能在面试中表现出超出岗位本身的能力，更能引起面试官注意。比如具备一定的技术视野，具备良好的规划能力，或者对业务方向有比较深入的见解。这些都能够成为亮点。</p>\n<p><strong>4、技术深度或广度</strong></p>\n<p>相信很多人都听过，职场中最受欢迎的是<code>T</code>型人才。也就是在拥有一定技术广度的基础上，在自己擅长的领域十分拔尖。这样的人才的确很难得，既要求能够胜任自己的在职工作，又能够不设边界的学习和输出其它领域的知识。</p>\n<p>除此之外，<strong>比 T 型人才更为难得是所谓 π 型人才，相比于 T 型人才，有了不止一项拔尖的领域。这类人才更是公司会抢占的资源。</strong></p>\n<h2>总结</h2>\n<p>面试虽说是考察和筛选优秀人才的过程，但说到底还是人与人沟通并展现自我的方式。所以掌握有效面试的技巧也是帮助自己收获更多的工具。</p>\n<p>这篇文章其实算讲的是方法论，很多我们一看就明白的「道理」实施起来可能会很难。可能会遇到一个不按常理出牌的面试官，也可能也会遇到一个沟通困难的面试官，当然也可能会撞上一个不怎么匹配的岗位。</p>\n<p>总而言之，为了自己想要争取的东西，做好足够的准备总是没有坏处的。祝愿大家能成为<code>π</code>型人才，获得想要的<code>offer</code>！</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "业余码农"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "一个中科大差生的 8 年程序员工作总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary.html",
      "summary": "推荐语：这篇文章讲述了一位中科大的朋友 8 年的经历：从 2013 年毕业之后加入上海航天 x 院某卫星研究所，再到入职华为，从华为离职。除了丰富的经历之外，作者在文章还给出了很多自己对于工作/生活的思考。我觉得非常受用！我在这里，向这位作者表达一下衷心的感谢。 原文地址：https://www.cnblogs.com/scada/p/14259332...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：这篇文章讲述了一位中科大的朋友 8 年的经历：从 2013 年毕业之后加入上海航天 x 院某卫星研究所，再到入职华为，从华为离职。除了丰富的经历之外，作者在文章还给出了很多自己对于工作/生活的思考。我觉得非常受用！我在这里，向这位作者表达一下衷心的感谢。</p>\n<br>\n<p><strong>原文地址</strong>：https://www.cnblogs.com/scada/p/14259332.html</p>\n</blockquote>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "陈小房"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "从校招入职腾讯的四年工作总结",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary.html",
      "summary": "程序员是一个流动性很大的职业，经常会有新面孔的到来，也经常会有老面孔的离开，有主动离开的，也有被动离职的。 再加上这几年卷得厉害，做的事更多了，拿到的却更少了，互联网好像也没有那么香了。 人来人往，变动无常的状态，其实也早已习惯。 打工人的唯一出路，无外乎精进自己的专业技能，提升自己的核心竞争力，这样无论有什么变动，走到哪里，都能有口饭吃。 今天分享一...",
      "content_html": "<p>程序员是一个流动性很大的职业，经常会有新面孔的到来，也经常会有老面孔的离开，有主动离开的，也有被动离职的。</p>\n<p>再加上这几年卷得厉害，做的事更多了，拿到的却更少了，互联网好像也没有那么香了。</p>\n<p>人来人往，变动无常的状态，其实也早已习惯。</p>\n<p>打工人的唯一出路，无外乎精进自己的专业技能，提升自己的核心竞争力，这样无论有什么变动，走到哪里，都能有口饭吃。</p>\n<p>今天分享一位博主，校招入职腾讯，工作四年后，离开的故事。</p>\n<p>至于为什么离开，我也不清楚，可能是有其他更好的选择，或者是觉得当前的工作对自己的提升有限。</p>\n<p><strong>下文中的“我”，指这位作者本人。</strong></p>\n<blockquote>\n<p>原文地址：https://zhuanlan.zhihu.com/p/602517682</p>\n</blockquote>\n<p>研究生毕业后， 一直在腾讯工作，不知不觉就过了四年。个人本身没有刻意总结的习惯，以前只顾着往前奔跑了，忘了停下来思考总结。记得看过一个职业规划文档，说的三年一个阶段，五年一个阶段的说法，现在恰巧是四年，同时又从腾讯离开，该做一个总结了。</p>\n<p>先对自己这四年做一个简单的评价吧：个人认为，没有完全的浪费和辜负这四年的光阴。为何要这么说了？因为我发现和别人对比，好像意义不大，比我混的好的人很多；比我混的差的人也不少。说到底，我只是一个普普通通的人，才不惊人，技不压众，接受自己的平凡，然后看自己做的，是否让自己满意就好。</p>\n<p>下面具体谈几点吧，我主要想聊下工作，绩效，EPC，嫡系看法，最后再谈下收获。</p>\n<h2>工作情况</h2>\n<p>我在腾讯内部没有转过岗，但是做过的项目也还是比较丰富的，包括：BUGLY、分布式调用链（Huskie)、众包系统（SOHO)，EPC 度量系统。其中一些是对外的，一些是内部系统，可能有些大家不知道。还是比较感谢这些项目经历，既有纯业务的系统，也有偏框架的系统，让我学到了不少知识。</p>\n<p>接下来，简单介绍一下每个项目吧，毕竟每一个项目都付出了很多心血的：</p>\n<p>BUGLY，这是一个终端 Crash 联网上报的系统，很多 APP 都接入了。Huskie，这是一个基于 zipkin 搭建的分布式调用链跟踪项目。SOHO，这是一个众包系统，主要是将数据标准和语音采集任务众包出去，让人家做。EPC 度量系统，这是研发效能度量系统，主要是度量研发效能情况的。这里我谈一下对于业务开发的理解和认识，很多人可能都跟我最开始一样，有一个疑惑，整天做业务开发如何成长？换句话说，就是说整天做 CRUD，如何成长？我开始也有这样的疑惑，后来我转变了观念。</p>\n<p>我觉得对于系统的复杂度，可以粗略的分为技术复杂度和业务复杂度，对于业务系统，就是业务复杂度高一些，对于框架系统就是技术复杂度偏高一些。解决这两种复杂度，都具有很大的挑战。</p>\n<p>此前做过的众包系统，就是各种业务逻辑，搞过去，搞过来，其实这就是业务复杂度高。为了解决这个问题，我们开始探索和实践领域驱动（DDD），确实带来了一些帮助，不至于系统那么混乱了。同时，我觉得这个过程中，自己对于 DDD 的感悟，对于我后来的项目系统划分和设计以及开发都带来了帮助。</p>\n<p>当然 DDD 不是银弹，我也不是吹嘘它有多好，只是了解了它后，有时候设计和开发时，能换一种思路。</p>\n<p>可以发现，其实平时咱们做业务，想做好，其实也没那么容易，如果可以多探索多实践，将一些好的方法或思想或架构引入进来，与个人和业务都会有有帮助。</p>\n<h2>绩效情况</h2>\n<p>我在腾讯工作四年，腾讯半年考核一次，一共考核八次，回想了下，四年来的绩效情况为:三星，三星，五星，三星，五星，四星，四星，三星。统计一下， 四五星占比刚好一半。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/640.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>PS：还好以前有奖杯，不然一点念想都没了。(现在腾讯似乎不发了）</p>\n<p>印象比较深的是两次五星获得经历。第一次五星是工作的第二年，那一年是在做众包项目，因为项目本身难度不大，因此我把一些精力投入到了团队的基础建设中，帮团队搭建了 java 以及 golang 的项目脚手架，又做了几次中心技术分享，最终 Leader 觉得我表现比较突出，因此给了我五星。看来，主动一些，与个人与团队都是有好处的，最终也能获得一些回报。</p>\n<p>第二次五星，就是与 EPC 有关了。说一个搞笑的事，我也是后来才知道的，项目初期，总监去汇报时，给老板演示系统，加载了很久指标才刷出来，总监很不好意思的说正在优化；过了一段时间，又去汇报演示，结果又很尴尬的刷了很久才出来，总监无赖表示还是在优化。没想到，自己曾经让总监这么丢脸，哈哈。好吧，说一下结果，最终，我自己写了一个查询引擎替换了 Mondrian，之后再也没有出现那种尴尬的情况了。随之而来，也给了好绩效鼓励。做 EPC 度量项目，我觉得自己成长很大，比如抗压能力，当你从零到一搭建一个系统时，会有一个先扛住再优化的过程，此外如果你的项目很重要，尤其是数据相关，那么任何一点问题，都可能让你神经紧绷，得想尽办法降低风险和故障。此外，另一个不同的感受就是，以前得项目，我大多是开发者，而这个系统，我是 Owner 负责人，当你 Owner 一个系统时，你得时刻负责，同时还需要思考系统的规划和方向，此外还需要分配好需求和把控进度，角色体验跟以前完全不一样。</p>\n<h2>谈谈 EPC</h2>\n<p>很多人都骂 EPC，或者笑 EPC，作为度量平台核心开发者之一，我来谈谈客观的看法。</p>\n<p>其实 EPC 初衷是好的，希望通过全方位多维度的研效指标，来度量研发效能各环节的质量，进而反推业务，提升研发效能。然而，最终在实践的过程中，才发现，客观条件并不支持（工具还没建设好）；此外，一味的追求指标数据，使得下面的人想方设法让指标好看，最终违背了初衷。</p>\n<p>为什么，说 EPC 好了，其实如果你仔细了解下 EPC，你就会发现，他是一套相当完善且比较先进的指标度量体系。覆盖了需求，代码，缺陷，测试，持续集成，运营部署各个环节。</p>\n<p>此外，这个过程中，虽然一些人和一些业务做弊，但绝大多数业务还是做出了改变的，比如微视那边的人反馈是，以前的代码写的跟屎一样，当有了 EPC 后，代码质量好了很多。虽然最后微视还是亡了，但是大厦将倾，EPC 是救不了的，亡了也更不能怪 EPC。</p>\n<h2>谈谈嫡系</h2>\n<p>大家都说腾讯，嫡系文化盛行。但其实我觉得在那个公司都一样吧。这也符合事物的基本规律，人们只相信自己信任并熟悉的人。作为领导，你难道会把把重要的事情交给自己不熟悉的人吗？</p>\n<p>其实我也不知道我算不算嫡系，脉脉上有人问过”怎么知道自己算不算嫡系”，下面有一个回答，我觉得很妙：如果你不知道你是不是嫡系，那你就不是。哈哈，这么说来，我可能不是。</p>\n<p>但另一方面，后来我负责了团队内很重要的事情，应该是中心内都算很重要的事，我独自负责一个方向，直接向总监汇报，似乎又有点像。</p>\n<p>网上也有其他说法，一针见血，是不是嫡系，就看钱到不到位，这么说也有道理。我在 7 级时，就发了股票，自我感觉，还是不错的。我当时以为不出意外的话，我以后的钱途和发展是不是就会一帆风顺。不出意外就出了意外，第二年，EPC 不达预期，部门总经理和总监都被换了，中心来了一个新的的总监。</p>\n<p>好吧，又要重新建立信任了。再到后来，是不是嫡系已经不重要了，因为大环境不好，又加上裁员，大家主动的被动的差不多都走了。</p>\n<p>总结一下，嫡系的存在，其实情有可原。怎么样成为嫡系了？其实我也不知道。不过，我觉得，与其思考怎么成为嫡系，不如思考怎么展现自己的价值和能力，当别人发现你的价值和能力了，那自然更多的机会就会给予你，有了机会，只要把握住了，那就有更多的福利了。</p>\n<h2>再谈收获</h2>\n<p>收获，什么叫做收获了？个人觉得无论是外在的物质，技能，职级；还是内在的感悟，认识，都算收获。</p>\n<p>先说一些可量化的吧，我觉得有:</p>\n<ul>\n<li>级别上，升上了九级，高级工程师。虽然大家都在说腾讯职级缩水，但是有没有高工的能力自己其实是知道的，我个人感觉，通过我这几年的努力，我算是达到了我当时认为的我需要在高工时达到的状态；</li>\n<li>绩效上，自我评价，个人不是一个特别卷的人，或者说不会为了卷而卷。但是，如果我认定我应该把它做好得，我的 Owner 意识，以及负责态度，我觉得还是可以的。最终在腾讯四年的绩效也还算过的去。再谈一些其他软技能方面:</li>\n</ul>\n<p><strong>1、文档能力</strong></p>\n<p>作为程序员，文档能力其实是一项很重要的能力。其实我也没觉得自己文档能力有多好，但是前后两任总监，都说我的文档不错，那看来，我可能在平均水准之上。</p>\n<p><strong>2、明确方向</strong></p>\n<p>最后，说一个更虚的，但是我觉得最有价值的收获: 我逐渐明确了，或者确定了以后的方向和路，那就是走数据开发。</p>\n<p>其实，找到并确定一个目标很难，身边有清晰目标和方向的人很少，大多数是迷茫的。</p>\n<p>前一段时间，跟人聊天，谈到职业规划，说是可以从两个角度思考：</p>\n<ul>\n<li>选一个业务方向，比如电商，广告，不断地积累业务领域知识和业务相关技能，随着经验的不断积累，最终你就是这个领域的专家。</li>\n<li>深入一个技术方向，不断钻研底层技术知识，这样就有希望成为此技术专家。坦白来说，虽然我深入研究并实践过领域驱动设计，也用来建模和解决了一些复杂业务问题，但是发自内心的，我其实更喜欢钻研技术，同时，我又对大数据很感兴趣。因此，我决定了，以后的方向，就做数据相关的工作。</li>\n</ul>\n<p>腾讯的四年，是我的第一份工作经历，认识了很多厉害的人，学到了很多。最后自己主动离开，也算走的体面（即使损失了大礼包），还是感谢腾讯。</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/640.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "pioneeryi"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "华为 OD 275 天后，我进了腾讯！",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/personal-experience/huawei-od-275-days.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/personal-experience/huawei-od-275-days.html",
      "summary": "推荐语：一位朋友的华为 OD 工作经历以及腾讯面试经历分享，内容很不错。 原文地址：https://www.cnblogs.com/shoufeng/p/14322931.html 时间线 18 年 7 月，毕业于某不知名 985 计科专业； 毕业前，在某马的 JavaEE（后台开发）培训了 6 个月； 第一份工作（18-07 ~ 19-12）接触了大...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：一位朋友的华为 OD 工作经历以及腾讯面试经历分享，内容很不错。</p>\n<br>\n<p><strong>原文地址</strong>：https://www.cnblogs.com/shoufeng/p/14322931.html</p>\n</blockquote>\n<h2>时间线</h2>\n<ul>\n<li>18 年 7 月，毕业于某不知名 985 计科专业；</li>\n<li>毕业前，在某马的 JavaEE（后台开发）培训了 6 个月；</li>\n<li>第一份工作（18-07 ~ 19-12）接触了大数据，感觉大数据更有前景；</li>\n<li>19 年 12 月，入职中国平安产险（去到才发现是做后台开发 😢）；</li>\n<li>20 年 3 月，从平安辞职，跳去华为 OD 做大数据基础平台；</li>\n<li>2021 年 1 月，入职鹅厂</li>\n</ul>\n<h2>华为 OD 工作经历总结</h2>\n<h3>为什么会去华为 OD</h3>\n<p>在平安产险（正式员工）只待了 3 个月，就跳去华为 OD，朋友们都是很不理解的 —— 好好的正编不做，去什么外包啊 😂</p>\n<p>但那个时候，我铁了心要去做大数据，不想和没完没了的 CRUD 打交道。刚好面试通过的岗位是华为 Cloud BU 的大数据部门，做的是国内政企中使用率绝对领先的大数据平台……\n平台和工作内容都不错，这么好的机会，说啥也要去啊 💪</p>\n<blockquote>\n<p>其实有想过在平安内部转岗到大数据的，但是不满足“入职一年以上”这个要求；\n「等待就是浪费生命」，在转正流程还没批下来的时候，赶紧溜了 😂</p>\n</blockquote>\n<h3>华为 OD 的工作内容</h3>\n<p><strong>带着无限的期待，火急火燎地去华为报到了。</strong></p>\n<p>和招聘的 HR 说的一样，和华为自有员工一起办公，工作内容和他们完全一样：</p>\n<blockquote>\n<p>主管根据你的能力水平分配工作，逐渐增加难度，能者多劳；\n试用期 6 个月，有导师带你，一般都是高你 2 个 Level 的华为自有员工，基本都是部门大牛。</p>\n</blockquote>\n<p>所以，<strong>不存在外包做的都是基础的、流程性的、没有技术含量的工作</strong> —— 顾虑这个的完全不用担心，你只需要打听清楚要去的部门/小组具体做什么，能接受就再考虑其他的。</p>\n<p>感触很深的一点是：华为是有着近 20 万员工的巨头，内部有很多流程和制度。好处是：能接触到大公司的产品从开发、测试，到发布、运维等一系列的流程，比如提交代码的时候，会由经验资深、经过内部认证的大牛给你 Review，在拉会检视的时候，可以学习他们考虑问题的角度，还有对整个产品全局的把控。</p>\n<p>但同时，个人觉得这也有不好的地方：流程繁琐会导致工作效率变低，比如改动几行代码，就需要跑完整个 CI（有些耗时比较久），还要提供自验和 VT 的报告。</p>\n<h3>OD 与华为自有员工的对比</h3>\n<p>什么是 OD？Outstanding Dispatcher，人员派遣，官方强调说，OD 和常说的“外包”是不一样的。</p>\n<p>说说我了解的 OD：</p>\n<ul>\n<li>参考华为的薪酬框架，OD 人员的薪酬体系有一定的市场竞争力 —— 的确是这样，貌似会稍微倒挂同级别的自有员工；</li>\n<li>可以参与华为主力产品的研发 —— 是的，这也是和某软等“供应商”的兄弟们不一样的地方；</li>\n<li>外网权限也可以申请打开（对，就是梯子），部门内部的大多数文档都是可以看的；</li>\n<li>工号是单独的 300 号段，其他供应商员工的工号是 8 开头，或着 WX 开头；</li>\n<li>工卡带是红色的，和自有员工一样，但是工卡内容不同，OD 的明确标注：办公区通行证，并有德科公司的备注：</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124231550508-1315720640.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>还听到一些内部的说法：</p>\n<ul>\n<li>没股票，没 TUP，年终奖少，只有工资可能比我司高一点点而已；</li>\n<li>不能借针对 HW 的消费贷，也不能买公司提供的优惠保险…</li>\n</ul>\n<h3>那，到底要不要去华为 OD？</h3>\n<p>我想，搜到我这篇文字的你，心里其实是有偏向的，只是缺最后一片雪花 ❄️，让自己下决心。</p>\n<p>作为过来人之一，我再提供一些参考吧 😃</p>\n<p>1）除了华为 OD，<strong>还有没有更好的选择？</strong> 综合考虑加班（996、有些是 9106 甚至更多）、薪资、工作内容，以及这份工作经历对你整个职业的加成等等因素；</p>\n<p>2）有看到一些内部的说法，比如：“奇怪 OD 这么棒，为啥大家不自愿转去 OD 啊？”；再比如：“OD 等同华为？这话都说的出口，既然都等同，为啥还要 OD？就是降成本嘛……”</p>\n<p>3）内心够强大吗？虽然没有人会说你是 OD，但总有一些事情会提醒你：<strong>你不是华为员工</strong>。比如：</p>\n<p>a) 内部发文啥的，还有心声平台的大部分内容，都是无权限看的：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124225007848-1701355006.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>b) 你的考勤是在租赁人员管理系统里考核，绩效管理也是；</p>\n<p>c) 自有员工的工卡具有消费功能（包括刷夜宵），OD 的工卡不能消费，需要办个消费卡，而且夜宵只能通过手机软件领取（自有员工是用工卡领的）；</p>\n<p>d) 你的加班一定要提加班申请电子流换 Double 薪资，不然只能换调休，离职时没时间调休也换不来 Double —— 而华为员工即使自己主动离职，也是有 N+1，以及加班时间换成 Double 薪资的；</p>\n<h3>网传的 OD 转华为正编，真的假的？</h3>\n<p>这个放到单独的一节，是因为它很重要，有很多纠结的同学在关注这个问题。</p>\n<p><strong>答案是：真的。</strong></p>\n<p>据各类非官方渠道（比如知乎上的一些分享），转华为自有是有条件的（https://www.zhihu.com/question/356592219/answer/1562692667）：</p>\n<p>1）入职时间：一年以上\n2）绩效要求：连续两次绩效 A\n3）认证要求：通过可信专业级认证\n4）其他条件：根据业务部门的人员需求及指标要求确定</p>\n<p>说说这些条件吧 😃</p>\n<p><strong>条件 2 连续两次绩效 A</strong></p>\n<p>上面链接里的说法：</p>\n<blockquote>\n<p>绩效 A 大约占整个部门的前 10%，连续两次 A 的意思就是一年里两次考评都排在部门前 10%，能做到这样的在华为属于火车头，这种难得的绩效会舍得分给一个租赁人员吗？</p>\n</blockquote>\n<p>OD 同学能拿到 A 吗？不知道，我入职晚，都没有经历一个完整的绩效考评。</p>\n<p>（20210605 更新下）一年多了，还留着的 OD 同学告知我：OD 是单独评绩效的，能拿到 A 的比例，大概是 1/5，对应的年终奖就是 4 个月；绩效是 B，年终奖就是 2 个月。</p>\n<p>在我看来，在试用期答辩时，能拿 A，接下来半年的绩效大概率也是拿 A 的。</p>\n<p>但总的来说，这种事既看实力，又看劳动态度（能不能拼命三郎疯狂加班），还要看运气（主管对你是不是认可）……</p>\n<p><strong>条件 3 通过可信专业级认证</strong></p>\n<p>可信专业级认证考试是啥？华为在推动技术人员的可信认证，算是一项安全合规的工作。\n专业级有哪些考试呢？共有四门：</p>\n<ul>\n<li>科目一：上级编程，对比力扣 2 道中等、1 道困难；</li>\n<li>科目二：编程知识与应用，考察基础的编程语言知识等；</li>\n<li>科目三：安全编程、质量、隐私，还有开发者测试等；</li>\n<li>科目四：重构知识，包括设计模式、代码重构等。</li>\n</ul>\n<p>上面这些，每一门单季度只能考一次（好像有些一年只能考 3 次），每个都要准备，少则 3 天，多则 1 星期，不准备，基本都过不了。\n我在 4 个月左右、还没转正的时候，就考过了专业级的科目二、三、四，只剩科目一大半年都没过（算法确实太菜了 😂\n但也有同事没准备，连着好几次都没通过。</p>\n<p><strong>条件 4 部门人员需求指标？</strong></p>\n<p>这个听起来都感觉很玄学。还是那句话，实力和运气到了，应该可以的！成功转正员工图镇楼：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124231943817-1976130336.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>真的感谢 OD，也感谢华为</h3>\n<p>运气很好，在我换工作还不到 3 个月的时候，华为还收我。</p>\n<p>我遇到了很好的主管，起码在工作时间，感觉跟兄长一样指导、帮助我；</p>\n<p>分配给我的导师，是我工作以来认识到技术实力最厉害的人，定位问题思路清晰，编码实力强悍，全局思考问题、制定方案……</p>\n<p>小组、部门的同学都很 nice，9 个多月里，我基本每天都跟打了鸡血一样，现在想想，也不知道当时为什么会那么积极有干劲 😂</p>\n<p>从个人能力上来讲，我是进不去华为的（心里还是有点数的 😂）。正是有了 OD 这个渠道，才有机会切身感受华为的工作氛围，也学到了很多软技能：</p>\n<ul>\n<li>积极主动，勇于承担尝试，好工作要抢过来自己做；</li>\n<li>及时同步工作进展，包括已完成、待完成，存在的风险困难等内容，要让领导知道你的工作情况；</li>\n<li>勤于总结提炼输出，形成个人 DNA，利人利己；</li>\n<li>有不懂的可以随时找人问，脸皮要厚，虚心求教；</li>\n<li>不管多忙，所有的会议，不论大小，都要有会议纪要，邮件发给相关人……</li>\n</ul>\n<p>再次感谢，大家都加油，向很牛掰很牛掰前进 💪</p>\n<h2>投简历，找面试官求虐</h2>\n<p>20 年 11 月初的一天，在同事们讨论“某某被其他公司高薪挖去了，钱景无限”的消息。</p>\n<p>我忽然惊觉，自己来到华为半年多，除了熟悉内部的系统和流程，好像没有什么成长和进步？</p>\n<p>不禁反思：只有厉害的人才会被挖，现在这个状态的我，在市场上值几个钱？</p>\n<p>刚好想起了之前的一个同事在离职聚会上分享的经验：</p>\n<blockquote>\n<p>技术人不能闭门造车，要多交流，多看看外面的动态。</p>\n<p>如果感觉自己太安逸了，那就把简历挂出去，去了解其他公司用的是什么技术，他们更关注哪些痛点？面几次你就有方向了。</p>\n</blockquote>\n<p>这时候起了个念头：找面试官求虐，以此来鞭策自己，进而更好地制定学习方向。</p>\n<p>于是我重新下载了某聘软件，在首页推荐里投了几家公司。</p>\n<h2>开始面试</h2>\n<p>11 月 10 号投的简历，当天就有 2 家预约了 11 号下午的线上面试，其中就有鹅厂 🐧</p>\n<p>好巧不巧，10 号晚上要双十一业务保障，一直到第二天凌晨 2 点半才下班。</p>\n<p>熬夜太伤身，还好能申请调休一天，也省去了找借口请假 🙊</p>\n<p>这段时间集中面了 3 家：</p>\n<blockquote>\n<p>第 1 个是广州的公司，11 号当晚就完成了 2 轮线上面试，开得有点低，就婉拒了；\n第 2 个就是本文的重点——鹅厂；\n第 3 个是做跨境电商的公司，一面就跪（恭喜它荣升为“在我有限的工作经历中，面试体验最差的 2 家公司之一”🙂️）</p>\n</blockquote>\n<h2>鹅厂，去还是不去？</h2>\n<p>一直有一个大厂梦，奈何菜鸟一枚，之前试过好几次，都跪在技术面了。</p>\n<p>所以想了个曲线救国的方法：先在其他单位积累着，有机会了再争取大厂的机会 💪</p>\n<p>很幸运，也很猝不及防，这次竟然通过了鹅厂的所有面试。</p>\n<p>虽然已到年底，但是要是错过这么难得的机会，下次就不知道什么时候才能再通关了。</p>\n<p>所以，<strong>年后拿到年终再跳槽 vs 已到手的鹅厂 Offer，我选择了后者 😄</strong></p>\n<h2>我的鹅厂面试</h2>\n<p>如本文标题所说，16 天通关五轮面试，第 17 天，我终于收到了期盼已久的鹅厂 Offer。</p>\n<p>做技术的同学，可能会对鹅厂的面试很好奇，他们都会问哪些问题呢？</p>\n<p>我应聘的是大数据开发（Java）岗位，接下来对我的面试做个梳理，也给想来鹅厂的同学们一个参考 😊</p>\n<blockquote>\n<p>几乎所有问题都能在网络上找到很详细的答案。\n篇幅有限，这里只写题目和一些引申的问题。</p>\n</blockquote>\n<h3>技术一面</h3>\n<h4>Java 语言相关</h4>\n<p>1、对 Java 的类加载器有没有了解？如何自定义类加载器？</p>\n<blockquote>\n<p>引申：一个类能被加载多次吗？<code>java/javax</code> 包下的类会被加载多次吗？</p>\n</blockquote>\n<p>2、Java 中要怎么创建一个对象 🐘？</p>\n<p>3、对多线程有了解吗？在什么场景下需要使用多线程？</p>\n<blockquote>\n<p>引申：对 <strong>线程安全</strong> 的认识；对线程池的了解，以及各个线程池的适用场景。</p>\n</blockquote>\n<p>4、对垃圾回收的了解？</p>\n<p>5、对 JVM 分代的了解？</p>\n<p>6、NIO 的了解？用过 RandomAccessFile 吗？</p>\n<blockquote>\n<p>引申：对 <strong>同步、异步，阻塞、非阻塞</strong> 的理解？</p>\n<p>多路复用 IO 的优势？</p>\n</blockquote>\n<p>7、ArrayList 和 LinkedList 的区别？各自的适用场景？</p>\n<p>8、实现一个 Hash 集合，需要考虑哪些因素？</p>\n<blockquote>\n<p>引申：JDK 对 HashMap 的设计关键点，比如初识容量，扩所容，链表转红黑树，以及 JDK 7 和 JDK 8 的区别等等。</p>\n</blockquote>\n<h4>通用学科相关</h4>\n<p>1、TCP 的三次握手；</p>\n<p>2、Linux 的常用命令，比如：</p>\n<blockquote>\n<div class=\"language-bash\" data-ext=\"sh\" data-title=\"sh\"><pre class=\"language-bash\"><code><span class=\"token function\">ps</span> aux / <span class=\"token function\">ps</span> -ef、top C\n<span class=\"token function\">df</span> -h、du <span class=\"token parameter variable\">-sh</span> *、free <span class=\"token parameter variable\">-g</span>\nvmstat、mpstat、iostat、netstat\n</code></pre></div></blockquote>\n<h4>项目框架相关</h4>\n<p>1、Kafka 和其他 MQ 的区别？它的吞吐量为什么高？</p>\n<blockquote>\n<p>消费者主动 pull 数据，目的是：控制消费节奏，还可以重复消费；</p>\n<p>吞吐量高：各 partition 顺序写 IO，批量刷新到磁盘（OS 的 pageCache 负责刷盘，Kafka 不用管），比随机 IO 快；读取数据基于 sendfile 的 Zero Copy；批量数据压缩……</p>\n</blockquote>\n<p>2、Hive 和 SparkSQL 的区别？</p>\n<p>3、Ranger 的权限模型、权限对象，鉴权过程，策略如何刷新……</p>\n<h4>问题定位方法</h4>\n<p>1、ssh 连接失败，如何定位？</p>\n<blockquote>\n<p>是否能 ping 通（DNS 是否正确）、对端端口是否开了防火墙、对端服务是否正常……</p>\n</blockquote>\n<p>2、运行 Java 程序的服务器，CPU 使用率达到 100%，如何定位？</p>\n<blockquote>\n<p><code>ps aux | grep xxx</code> 或 <code>jps</code> 命令找到 Java 的进程号 <code>pid</code>，</p>\n<p>然后用 <code>top -Hp pid</code> 命令查看其阻塞的线程序号，<strong>将其转换为 16 进制</strong>；</p>\n<p>再通过 <code>jstack pid</code> 命令跟踪此 Java 进程的堆栈，搜索上述转换来的 16 进制线程号，即可找到对应的线程名及其堆栈信息……</p>\n</blockquote>\n<p>3、Java 程序发生了内存溢出，如何定位？</p>\n<blockquote>\n<p><code>jmap</code> 工具查看堆栈信息，看 Eden、Old 区的变化……</p>\n</blockquote>\n<h3>技术二面</h3>\n<p>二面主要是过往项目相关的问题：</p>\n<p>1、Solr 和 Elasticsearch 的区别 / 优劣？</p>\n<p>2、对 Elasticsearch 的优化，它的索引过程，选主过程等问题……</p>\n<p>3、项目中遇到的难题，如何解决的？</p>\n<p>blabla 有少量的基础问题和一面有重复，还有几个和大数据相关的问题，记不太清了 😅</p>\n<h3>技术三面</h3>\n<p>这一面是总监面，更多是个人关于职业发展的一些想法，以及在之前公司的成长和收获、对下一份工作的期望等问题。</p>\n<p>但也问了几个技术问题。印象比较深的是这个：</p>\n<blockquote>\n<p>1 个 1TB 的大文件，每行都只是 1 个数字，无重复，8GB 内存，要怎么对这个文件进行排序？</p>\n</blockquote>\n<p>首先想到的是 MapReduce 的思路，拆分小文件，分批排序，最后合并。</p>\n<p><strong>此时连环追问来了：</strong></p>\n<blockquote>\n<p>Q：如何尽可能多的利用内存呢？</p>\n<p>A：用位图法的思路，对数字按顺序映射。（对映射方法要有基本的了解）</p>\n<p>Q：如果在排好序之后，还需要快速查找呢？</p>\n<p>A：可以做索引，类似 Redis 的跳表，通过多级索引提高查找速度。</p>\n<p>Q：索引查找的还是文件。要如何才能更多地利用内存呢？</p>\n<p>A：那就要添加缓存了，把读取过的数字缓存到内存中。</p>\n<p>Q：缓存应该满足什么特点呢？</p>\n<p>A：应该使用 LRU 型的缓存。</p>\n</blockquote>\n<p>呼。。。总算是追问完了这道题 😂</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124231550508-1315720640.jpg",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "滴滴和头条两年后端工作经验分享",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao.html",
      "summary": "推荐语：很实用的工作经验分享，看完之后十分受用！ 内容概览： 要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。 积极学习，保持技术热情。如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？ 在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：很实用的工作经验分享，看完之后十分受用！</p>\n<p><strong>内容概览</strong>：</p>\n<ul>\n<li>要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</li>\n<li>积极学习，保持技术热情。如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？</li>\n<li>在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。</li>\n<li>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</li>\n<li>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</li>\n<li>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</li>\n<li>平时积极总结沉淀，多跟别人交流，形成方法论。</li>\n<li>......</li>\n</ul>\n<p><strong>原文地址</strong>：https://www.nowcoder.com/discuss/351805</p>\n</blockquote>\n<p>先简单交代一下背景吧，某不知名 985 的本硕，17 年毕业加入滴滴，当时找工作时候也是在牛客这里跟大家一起奋战的。今年下半年跳槽到了头条，一直从事后端研发相关的工作。之前没有实习经历，算是两年半的工作经验吧。这两年半之间完成了一次晋升，换了一家公司，有过开心满足的时光，也有过迷茫挣扎的日子，不过还算顺利地从一只职场小菜鸟转变为了一名资深划水员。在这个过程中，总结出了一些还算实用的划水经验，有些是自己领悟到的，有些是跟别人交流学到的，在这里跟大家分享一下。</p>\n<h2>学会深入思考，总结沉淀</h2>\n<p><strong>我想说的第一条就是要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</strong></p>\n<p><strong>先来说深入思考。</strong> 在程序员这个圈子里，常能听到一些言论：<em>“我这个工作一点技术含量都没有，每天就 CRUD，再写写 if-else，这 TM 能让我学到什么东西？”</em></p>\n<p>抛开一部分调侃和戏谑的论调不谈，这可能确实是一部分同学的真实想法，至少曾经的我，就这么认为过。后来随着工作经验的积累，加上和一些高 level 的同学交流探讨之后，我发现这个想法其实是非常错误的。之所以出现没什么可学的这样的看法，基本上是思维懒惰的结果。<strong>任何一件看起来很不起眼的小事，只要进行深入思考，稍微纵向挖深或者横向拓宽一下，都是足以让人沉溺的知识海洋。</strong></p>\n<p>举一个例子。某次有个同学跟我说，这周有个服务 OOM 了，查了一周发现有个地方 defer 写的有问题，改了几行代码上线修复了，周报都没法写。可能大家也遇到过这样的场景，还算是有一定的代表性。其实就查 bug 这件事来说，是一个发现问题，排查问题，解决问题的过程，包含了触发、定位、复现、根因、修复、复盘等诸多步骤，花了一周来做这件事，一定有不断尝试与纠错的过程，这里面其实就有很多思考的空间。比如说定位，如何缩小范围的？走了哪些弯路？用了哪些分析工具？比如说根因，可以研究的点起码有 linux 的 OOM，k8s 的 OOM，go 的内存管理，defer 机制，函数闭包的原理等等。如果这些真的都不涉及，仍然花了一周时间做这件事，那复盘应该会有很多思考，提出来几十个 WHY 没问题吧...</p>\n<p><strong>再来说下总结沉淀。</strong> 这个我觉得也是大多数程序员比较欠缺的地方，只顾埋头干活，可以把一件事做的很好。但是几乎从来不做抽象总结，以至于工作好几年了，所掌握的知识还是零星的几点，不成体系，不仅容易遗忘，而且造成自己视野比较窄，看问题比较局限。适时地做一些总结沉淀是很重要的，这是一个从术到道的过程，会让自己看问题的角度更广，层次更高。遇到同类型的问题，可以按照总结好的方法论，系统化、层次化地推进和解决。</p>\n<p>还是举一个例子。做后台服务，今天优化了 1G 内存，明天优化了 50%的读写耗时，是不是可以做一下性能优化的总结？比如说在应用层，可以管理服务对接的应用方，梳理他们访问的合理性；在架构层，可以做缓存、预处理、读写分离、异步、并行等等；在代码层，可以做的事情更多了，资源池化、对象复用、无锁化设计、大 key 拆分、延迟处理、编码压缩、gc 调优还有各种语言相关的高性能实践...等下次再遇到需要性能优化的场景，一整套思路立马就能套用过来了，剩下的就是工具和实操的事儿了。</p>\n<p>还有的同学说了，我就每天跟 PM 撕撕逼，做做需求，也不做性能优化啊。先不讨论是否可以搞性能优化，单就做业务需求来讲，也有可以总结的地方。比如说，如何做系统建设？系统核心能力，系统边界，系统瓶颈，服务分层拆分，服务治理这些问题有思考过吗？每天跟 PM 讨论需求，那作为技术同学该如何培养产品思维，引导产品走向，如何做到架构先行于业务，这些问题也是可以思考和总结的吧。就想一下，连接手维护别人烂代码这种蛋疼的事情，都能让 Martin Fowler 整出来一套重构理论，还显得那么高大上，我们确实也没啥必要对自己的工作妄自菲薄...</p>\n<p>所以说：<strong>学习和成长是一个自驱的过程，如果觉得没什么可学的，大概率并不是真的没什么可学的，而是因为自己太懒了，不仅是行动上太懒了，思维上也太懒了。可以多写技术文章，多分享，强迫自己去思考和总结，毕竟如果文章深度不够，大家也不好意思公开分享。</strong></p>\n<h2>积极学习，保持技术热情</h2>\n<p>最近两年在互联网圈里广泛传播的一种焦虑论叫做 35 岁程序员现象，大意是说程序员这个行业干到 35 岁就基本等着被裁员了。不可否认，互联网行业在这一点上确实不如公务员等体制内职业。但是，这个问题里 35 岁程序员并不是绝对生理意义上的 35 岁，应该是指那些工作十几年和工作两三年没什么太大区别的程序员。后面的工作基本是在吃老本，没有主动学习与充电，35 岁和 25 岁差不多，而且没有了 25 岁时对学习成长的渴望，反而添了家庭生活的诸多琐事，薪资要求往往也较高，在企业看来这确实是没什么竞争力。</p>\n<p><strong>如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？</strong> 但是，<strong>学习这件事，其实是一个反人类的过程，这就需要我们强迫自己跳出自己的安逸区，主动学习，保持技术热情。</strong> 在滴滴时有一句话大概是，<strong>主动跳出自己的舒适区，感到挣扎与压力的时候，往往是黎明前的黑暗，那才是成长最快的时候。相反如果感觉自己每天都过得很安逸，工作只是在混时长，那可能真的是温水煮青蛙了。</strong></p>\n<p>刚毕业的这段时间，往往空闲时间还比较多，正是努力学习技术的好时候。借助这段时间夯实基础，培养出良好的学习习惯，保持积极的学习态度，应该是受益终身的。至于如何高效率学习，网上有很多大牛写这样的帖子，到了公司后内网也能找到很多这样的分享，我就不多谈了。</p>\n<p><strong><em>可以加入学习小组和技术社区，公司内和公司外的都可以，关注前沿技术。</em></strong></p>\n<h2>主动承担，及时交流反馈</h2>\n<p>前两条还是从个人的角度出发来说的，希望大家可以提升个人能力，保持核心竞争力，但从公司角度来讲，公司招聘员工入职，最重要的是让员工创造出业务价值，为公司服务。虽然对于校招生一般都会有一定的培养体系，但实际上公司确实没有帮助我们成长的义务。</p>\n<p><strong>在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。</strong></p>\n<p>我当初刚入职的时候，基本就是 leader 给分配什么任务就把本职工作做好，然后就干自己的事了，几乎从来不主动去跟别人交流或者主动去思考些能帮助项目发展的点子。自以为把本职工作保质保量完成就行了，后来发现这么做其实是非常不够的，这只是最基本的要求。而有些同学的做法则是 leader 只需要同步一下最近要做什么方向，下面的一系列事情基本不需要 leader 操心了 ，这样的同学我是 leader 我也喜欢啊。入职后经常会听到的一个词叫 owner 意识，大概就是这个意思吧。</p>\n<p>在这个过程中，另外很重要的一点就是及时向上沟通反馈。项目进展不顺利，遇到什么问题，及时跟 leader 同步，技术方案拿捏不准可以跟 leader 探讨，一些资源协调不了可以找 leader 帮忙，不要有太多顾忌，认为这些会太麻烦，leader 其实就是干这个事的。。如果项目进展比较顺利，确实也不需要 leader 介入，那也需要及时把项目的进度，取得的收益及时反馈，自己有什么想法也提出来探讨，问问 leader 对当前进展的建议，还有哪些地方需要改进，消除信息误差。做这些事一方面是合理利用 leader 的各种资源，另一方面也可以让 leader 了解到自己的工作量，对项目整体有所把控，毕竟 leader 也有 leader，也是要汇报的。可能算是大家比较反感的向上管理吧，有内味了，这个其实我也做得不好。但是最基本的一点，不要接了一个任务闷着头干活甚至与世隔绝了，一个月了也没跟 leader 同步过，想着憋个大招之类的，那基本凉凉。</p>\n<p><strong>一定要主动，可以先从强迫自己在各种公开场合发言开始，有问题或想法及时 one-one。</strong></p>\n<p>除了以上几点，还有一些小点我觉得也是比较重要的，列在下面：</p>\n<h2>第一件事建立信任</h2>\n<p>无论是校招还是社招，刚入职的第一件事是非常重要的，直接决定了 leader 和同事对自己的第一印象。入职后要做的第一件事一定要做好，最起码的要顺利完成而且不能出线上事故。这件事的目的就是为了建立信任，让团队觉得自己起码是靠谱的。如果这件事做得比较好，后面一路都会比较顺利。如果这件事就搞杂了，可能有的 leader 还会给第二次机会，再搞不好，后面就很难了，这一条对于社招来说更为重要。</p>\n<p>而刚入职，公司技术栈不熟练，业务繁杂很难理清什么头绪，压力确实比较大。这时候一方面需要自己投入更多的精力，另一方面要多跟组内的同学交流，不懂就问。<strong>最有效率的学习方式，我觉得不是什么看书啊学习视频啊，而是直接去找对应的人聊，让别人讲一遍自己基本就全懂了，这效率比看文档看代码快多了，不仅省去了过滤无用信息的过程，还了解到了业务的演变历史。当然，这需要一定的沟通技巧，毕竟同事们也都很忙。</strong></p>\n<p><strong>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</strong></p>\n<h2>超出预期</h2>\n<p>超出预期这个词的外延范围很广，比如 leader 让去做个值周，解答用户群里大家的问题，结果不仅解答了大家的问题，还收集了这些问题进行分类，进而做了一个智能问答机器人解放了值周的人力，这可以算超出预期。比如 leader 让给运营做一个小工具，结果建设了一系列的工具甚至发展成了一个平台，成为了一个完整的项目，这也算超出预期。超出预期要求我们有把事情做大的能力，也就是想到了 leader 没想到的地方，并且创造了实际价值，拿到了业务收益。这个能力其实也比较重要，在工作中发现，有的人能把一个小盘子越做越大，而有的人恰好反之，那么那些有创新能力，经常超出预期的同学发展空间显然就更大一点。</p>\n<p><strong>这块其实比较看个人能力，暂时没想到什么太好的捷径，多想一步吧。</strong></p>\n<h2>体系化思考，系统化建设</h2>\n<p>这句话是晋升时候总结出来的，大意就是做系统建设要有全局视野，不要局限于某一个小点，应该有良好的规划能力和清晰的演进蓝图。比如，今天加了一个监控，明天加一个报警，这些事不应该成为一个个孤岛，而是属于稳定性建设一期其中的一小步。这一期稳定性建设要做的工作是报警配置和监控梳理，包括机器监控、系统监控、业务监控、数据监控等，预期能拿到 XXX 的收益。这个工作还有后续的 roadmap，稳定性建设二期要做容量规划，接入压测，三期要做降级演练，多活容灾，四期要做...给人的感觉就是这个人思考非常全面，办事有体系有规划。</p>\n<p><strong>平时积极总结沉淀，多跟别人交流，形成方法论。</strong></p>\n<h2>提升自己的软素质能力</h2>\n<p>这里的软素质能力其实想说的就是 PPT、沟通、表达、时间管理、设计、文档等方面的能力。说实话，我觉得我当时能晋升就是因为 PPT 做的好了一点...可能大家平时对这些能力都不怎么关注，以前我也不重视，觉得比较简单，用时候直接上就行了，但事实可能并不像想象得那样简单。比如晋升时候 PPT+演讲+答辩这个工作，其实有很多细节的思考在里面，内容如何选取，排版怎么设计，怎样引导听众的情绪，如何回答评委的问题等等。晋升时候我见过很多同学 PPT 内容编排杂乱无章，演讲过程也不流畅自然，虽然确实做了很多实际工作，但在表达上欠缺了很多，属于会做不会说，如果再遇到不了解实际情况的外部门评委，吃亏是可以预见的。</p>\n<p><strong><em>公司内网一般都会有一些软素质培训课程，可以找一些场合刻意训练。</em></strong></p>\n<p>以上都是这些分享还都算比较伟光正，但是社会吧也不全是那么美好的。。下面这些内容有负能量倾向，三观特别正的同学以及观感不适者建议跳过。</p>\n<h2>拍马屁是真的香</h2>\n<p>拍马屁这东西入职前我是很反感的，我最初想加入互联网公司的原因就是觉得互联网公司的人情世故没那么多，事实证明，我错了...入职前几天，部门群里大 leader 发了一条消息，后面几十条带着大拇指的消息立马跟上，学习了，点赞，真不错，优秀，那场面，说是红旗招展锣鼓喧天鞭炮齐鸣一点也不过分。除了惊叹大家超强的信息接收能力和处理速度外，更进一步我还发现，连拍马屁都是有队形的，一级部门 leader 发消息，几个二级部门 leader 跟上，后面各组长跟上，最后是大家的狂欢，让我一度怀疑拍马屁的速度就决定了职业生涯的发展前景（没错，现在我已经不怀疑了）。</p>\n<p>坦诚地说，我到现在也没习惯在群里拍马屁，但也不反感了，可以说把这个事当成一乐了。倒不是说我没有那个口才和能力（事实上也不需要什么口才，大家都简单直接），在某些场合，为活跃气氛的需要，我也能小嘴儿抹了蜜，甚至能把古诗文彩虹屁给 leader 安排上。而是我发现我的直属 leader 也不怎么在群里拍马屁，所以我表面上不公开拍马屁其实属于暗地里事实上迎合了 leader 的喜好...</p>\n<p>但是拍马屁这个事只要掌握好度，整体来说还是香的，最多是没用，至少不会有什么坏处嘛。大家能力都差不多，每一次在群里拍马屁的机会就是一次露脸的机会，按某个同事的说法，这就叫打造个人技术影响力...</p>\n<p><strong>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</strong></p>\n<h2>永不缺席的撕逼甩锅实战</h2>\n<p>有人的地方，就有江湖。虽然搞技术的大多城府也不深，但撕逼甩锅邀功抢活这些闹心的事儿基本也不会缺席，甚至我还见到过公开群发邮件撕逼的...这部分话题涉及到一些敏感信息就不多说了，而且我们低职级的遇到这些事儿的机会也不会太多。只是给大家提个醒，在工作的时候迟早都会吃到这方面的瓜，到时候留个心眼。</p>\n<p><strong>稍微注意一下，咱不会去欺负别人，但也不能轻易让别人给欺负了。</strong></p>\n<h2>不要被画饼蒙蔽了双眼</h2>\n<p>说实话，我个人是比较反感灌鸡汤、打鸡血、谈梦想、讲奋斗这一类行为的，9102 年都快过完了，这一套***治还在大行其道，真不知道是该可笑还是可悲。当然，这些词本身并没有什么问题，但是这些东西应该是自驱的，而不应该成为外界的一种强 push。『我必须努力奋斗』这个句式我觉得是正常的，但是『你必须努力奋斗』这种话多少感觉有点诡异，努力奋斗所以让公司的股东们发家致富？尤其在钱没给够的情况下，这些行为无异于耍流氓。我们需要对 leader 的这些画饼操作保持清醒的认知，理性分析，作出决策。比如感觉钱没给够（或者职级太低，同理）的时候，可能有以下几种情况：</p>\n<ol>\n<li>leader 并没有注意到你薪资较低这一事实</li>\n<li>leader 知道这个事实，但是不知道你有多强烈的涨薪需求</li>\n<li>leader 知道你有涨薪的需求，但他觉得你能力还不够</li>\n<li>leader 知道你有涨薪的需求，能力也够，但是他不想给你涨</li>\n<li>leader 想给你涨，也向上反馈和争取了，但是没有资源</li>\n</ol>\n<p>这时候我们需要做的是向上反馈，跟 leader 沟通确认。如果是 1 和 2，那么通过沟通可以消除信息误差。如果是 3，需要分情况讨论。如果是 4 和 5，已经可以考虑撤退了。对于这些事儿，也没必要抱怨，抱怨解决不了任何问题。我们要做的就是努力提升好个人能力，保持个人竞争力，等一个合适的时机，跳槽就完事了。</p>\n<p><strong>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</strong></p>\n<h2>学会包装</h2>\n<p>这一条说白了就是，要会吹。忘了从哪儿看到的了，能说、会写、善做是对职场人的三大要求。能说是很重要的，能说才能要来项目，拉来资源，招来人。同样一件事，不同的人能说出来完全不一样的效果。比如我做了个小工具上线了，我就只能说出来基本事实，而让 leader 描述一下，这就成了，打造了 XXX 的工具抓手，改进了 XXX 的完整生态，形成了 XXX 的业务闭环。老哥，我服了，硬币全给你还不行嘛。据我的观察，每个互联网公司都有这么几个词，抓手、生态、闭环、拉齐、梳理、迭代、owner 意识等等等等，我们需要做的就是熟读并背诵全文，啊不，是牢记并熟练使用。</p>\n<p>这是对事情的包装，对人的包装也是一样的，尤其是在晋升和面试这样的应试型场合，特点是流程短一锤子买卖，包装显得尤为重要。晋升和面试这里就不展开说了，这里面的道和术太多了。。下面的场景提炼自面试过程中和某公司面试官的谈话，大家可以感受一下：</p>\n<ol>\n<li>我们背后是一个四五百亿美金的市场...</li>\n<li>我负责过每天千亿级别访问量的系统...</li>\n<li>工作两年能达到这个程度挺不错的...</li>\n<li>贵司技术氛围挺好的，业务发展前景也很广阔...</li>\n<li>啊，彼此彼此...</li>\n<li>嗯，久仰久仰...</li>\n</ol>\n<p>人生如戏，全靠演技</p>\n<p><strong>可以多看 leader 的 PPT，多听老板的向上汇报和宣讲会。</strong></p>\n<h2>选择和努力哪个更重要？</h2>\n<p>这还用问么，当然是选择。在完美的选择面前，努力显得一文不值，我有个多年没联系的高中同学今年已经在时代广场敲钟了...但是这样的案例太少了，做出完美选择的随机成本太高，不确定性太大。对于大多数刚毕业的同学，对行业的判断力还不够成熟，对自身能力和创业难度把握得也不够精准，此时拉几个人去创业，显得风险太高。我觉得更为稳妥的一条路是，先加入规模稍大一点的公司，找一个好 leader，抱好大腿，提升自己的个人能力。好平台加上大腿，再加上个人努力，这个起飞速度已经可以了。等后面积累了一定人脉和资金，深刻理解了市场和需求，对自己有信心了，可以再去考虑创业的事。</p>\n<h2>后记</h2>\n<p>本来还想分享一些生活方面的故事，发现已经这么长了，那就先这样叭。上面写的一些总结和建议我自己做的也不是很好，还需要继续加油，和大家共勉。另外，其中某些观点，由于个人视角的局限性也不保证是普适和正确的，可能再工作几年这些观点也会发生改变，欢迎大家跟我交流~（甩锅成功）</p>\n<p>最后祝大家都能找到心仪的工作，快乐工作，幸福生活，广阔天地，大有作为。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "程序员高效出书避坑和实践指南",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide.html",
      "summary": "推荐语：详细介绍了程序员出书的一些常见问题，强烈建议有出书想法的朋友看看这篇文章。 原文地址：https://www.cnblogs.com/JavaArchitect/p/14128202.html 古有三不朽， 所谓立德、立功、立言。程序员出一本属于自己的书，如果说是立言，可能过于高大上，但终究也算一件雅事。 出书其实不挣钱，而且从写作到最终拿钱的...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：详细介绍了程序员出书的一些常见问题，强烈建议有出书想法的朋友看看这篇文章。</p>\n<br>\n<p><strong>原文地址</strong>：https://www.cnblogs.com/JavaArchitect/p/14128202.html</p>\n</blockquote>\n<p>古有三不朽， 所谓立德、立功、立言。程序员出一本属于自己的书，如果说是立言，可能过于高大上，但终究也算一件雅事。</p>\n<p>出书其实不挣钱，而且从写作到最终拿钱的周期也不短。但程序员如果有一本属于自己的技术书，那至少在面试中能很好地证明自己，也能渐渐地在业内积累自己的名气，面试和做其它事情时也能有不少底气。在本文里，本人就将结合自己的经验和自己踩过的坑，和大家聊聊程序员出书的那些事。</p>\n<h2>1.出书的稿酬收益和所需要的时间</h2>\n<p>先说下出书的收益和需要付出的代价，这里姑且先不谈“出书带来的无形资产”，先谈下真金白银的稿酬。</p>\n<p>如果直接和出版社联系，一般稿酬是版税，是书价格的 8%乘以印刷数（或者实际销售数），如果你是大牛的话，还可以往上加，不过一般版税估计也就 10%到 12%。请注意这里的价格是书的全价，不是打折后的价格。</p>\n<p>比如一本书全价是 70 块，在京东等地打 7 折销售，那么版税是 70 块的 8%，也就是说卖出一本作者能有 5.6 的收益，当然真实拿到手以后还再要扣税。</p>\n<p>同时也请注意合同的约定是支付稿酬的方式是印刷数还是实际销售数，我和出版社谈的，一般是印刷数量，这有什么差别呢？现在计算机类的图书一般是首印 2500 册，那么实际拿到手的钱数是 70*8%*2500，当然还要扣税。但如果是按实际销售数量算的话，如果首印才销了 1800 本的话，那么就得按这个数量算钱了。</p>\n<p>现在一本 300 页的书，定价一般在 70 左右，按版税 8%和 2500 册算的话，税前收益是 14000，税后估计是 12000 左右，对新手作者的话，300 的书至少要写 8 个月，由此大家可以算下平均每个月的收益，算下来其实每月也就 1500 的收益，真不多。</p>\n<p>别人的情况我不敢说，但我出书以后，除了稿酬，还有哪些其它的收益呢？</p>\n<ul>\n<li>在当下和之前的公司面试时，告诉面试官我在相关方面出过书以后，面试官就直接会认为我很资深，帮我省了不少事情。</li>\n<li>我还在做线下的培训，我就直接拿我最近出的 Python 书做教材了，省得我再备课了。</li>\n<li>和别人谈项目，能用我的书证明自己的技术实力，如果是第一次和别人打交道，那么这种证明能立杆见效。</li>\n</ul>\n<p>尤其是第一点，其实对一些小公司或者是一些外派开发岗而言，如果候选人在这个方面出过书，甚至都有可能免面试直接录取，本人之前面试过一个大公司的外派岗，就得到过这种待遇。</p>\n<h2>2.支付稿酬的时间点和加印后的收益</h2>\n<p>我是和出版社直接联系出书，支付稿酬的时间点一般是在首印后的 3 个月内拿到首印部分稿酬的一部分（具体是 50%到 90%），然后在图书出版后的一年后再拿到其它部分的稿酬。当下有不少书，能销掉首印的册数就不错了，不过也有不少书能加印，甚至出第二和第三版，一般加印册数的版税会在加印后的半年到一年内结清。</p>\n<p>从支付稿酬的时间点上来，对作者确实会有延迟，外加上稿酬也不算高，相对于作者的辛勤劳动，所以出书真不是挣钱的事，而且拿钱的周期还长。如果个别图书公司工作人员一方面在出书阶段对作者没什么帮助， 另一方面还要在中间再挣个差价，那么真有些作践作者的辛勤劳动了。</p>\n<h2>3.同图书公司打交道的所见所闻</h2>\n<p>在和出版社编辑沟通前，我也和图书公司的工作人员交流过，不少工作人员对我也是比较尊重，交流虽然不算深入，但也算客气。不过最终对比出版社给出的稿酬等条件，我还是没有通过图书公司出书，这也是比较可惜的事情。下面我给出些具体的经历。</p>\n<ul>\n<li>我经常在博客园等地收到一些图书公司工作人员的留言，问要不要出书，一般我不问，他们不会说自己是出版社编辑还是图书公司的工作人员。有个别图书公司的工作人员，会向作者，尤其是新手作者，说些“出版社编辑一般不会直接和作者联系”，以及“出书一般是通过图书公司”等的话。其实这些话不能算错，比如你不联系出版社编辑，那么对方自然不会直接联系你，但相反如果作者直接和出版社编辑联系，第一没难度，第二可能更直接。</li>\n<li>我和出版社编辑交流大纲时，即使大纲有不足，他们也能直接给出具体的修改意见，比如某个章节该写什么，某个小节的大纲该怎么写。而我和个别图书公司的工作人员交流过大纲时，得到的反馈大多是“要重写”，怎么个重写法？这些工作人员可能只能给出抽象的意见，什么都要我自己琢磨。在我之前的博文<a href=\"./how-do-programmers-publish-a-technical-book\">程序员怎样出版一本技术书</a>里，我就给出过具体的经历。</li>\n<li>由于交流不深，所以我没有和图书公司签订过出书协议，但我知道，只有出版社能出书。由于没有经历过，所以我也不知道图书公司在合同里是否有避规风险等条款，但我见过一位图书公司人员人员给出的一些退稿案例，并隐约流露出对作者的责备之意。细思感觉不妥，对接的工作人员第一不能在出问题的第一时间及时发现并向作者反馈，第二在出问题之后不能对应协调最终导致退稿，第三在退稿之后，作者在付出劳动的情况下图书公司不仅不用承担任何风险，并还能指摘作者。对此，退稿固然有作者的因素，但同是作者的我未免有兔死狐悲之谈。而我在出版社出书时，编辑有时候甚至会主动关心，主动给素材，哪怕有问题也会第一时间修改，所以甚至大范围修改稿件的情况都基本没有出现。</li>\n<li>再说下图书公司给作者的稿酬。我见过按页给钱，比如一页 30 到 50 块，并卖断版权，即书重印后作者也无法再得到稿酬，如果是按版税给钱，我也见过给 6%，至于图书公司能否给到 8 个点甚至更高，我没见到过，所以不知道，也不敢擅拟。</li>\n</ul>\n<p>我交流过的图书公司工作人员不多，交流也不深，因为我现在主要是和出版社的编辑交流。所以以上只是我对个别图书公司编辑的感受，我无意以偏概全，而和我交流的一些图书公司工作人员至少态度上对我很尊重。所以大家也可以对比尝试下和图书公司以及出版社合作的不同方式。不管怎样，你在写书甚至在签出书协议前，你需要问清楚如下的事项，并且对方有义务让你了解如下的事实。</p>\n<ul>\n<li>你得问清楚，对方的身份是出版社编辑还是图书公司工作人员，这其实应当是对方主动告之。</li>\n<li>你的书在哪个出版社出版？这点需要在出书协议里明确给出，不能是先完稿再定出版社。而且，最终能出版书的，一定是出版社，而不是图书公司。</li>\n<li>稿酬的支付方式，哪怕图书公司中间可能挣差价，但至少你得了解出版社能给到的稿酬。如果你是通过图书公司出的书，不管图书公司怎么和你谈的，但出版社给图书公司的钱一分不会少，中间部分应该就是图书公司的盈利。</li>\n<li>最终和你签订出书合同的，是图书公司还是出版社，这一定得在你签字前搞明白，哪怕你最终是和图书公司签协议，但至少得知道你还能直接和出版社签协议。</li>\n<li>你不能存有“在图书公司出书要求低”的想法，更不应该存有“我能力一般，所以只能在图书公司出书”的想法。图书公司自己是没有资格出书的，所以他们也是会把稿件交给出版社，所以该有的要求一点也不会低。你的大纲在出版社编辑那边通不过，那么在图书公司的工作人员那边同样通不过，哪怕你索要的稿酬少，图书公司方面对应的要求一定也不会降低。</li>\n</ul>\n<p>如果你明知“图书公司和出版社的差别”，并还是和图书公司合作，这个是两厢情愿的事情。但如果对方“不主动告知”，而你在不了解两者差异的基础上同图书公司合作，那么对方也无可指摘。不过兼听则明，大家如果要出书，不妨和出版社和图书公司都去打打交道对比下。</p>\n<h2>4.如何直接同国内计算机图书的知名出版社编辑联系</h2>\n<p>我在清华大学出版社、机械工业出版社、北京大学出版社和电子工业出版社出过书，出书流程也比较顺畅，和编辑打交道也比较愉快。我个人无意把国内出版社划分成三六九等，但计算机行业，比较知名的出版社有清华、机工、电子工业和人邮这四家，当然其它出版社在计算机方面也出版过精品书。</p>\n<p>如何同这些知名出版社的编辑直接打交道？</p>\n<ul>\n<li>直接到官网，一般官网上都直接有联系方式。</li>\n<li>你在博客园等地发表文章，会有人找你出书，其中除了图书公司的工作人员外，也有出版社编辑，一般出版社的编辑会直接说明身份，比如我是 xx 出版社的编辑 xx。</li>\n<li>本人也和些出版社的编辑联系过，大家如果要，我可以给。</li>\n</ul>\n<p>那怎么去找图书公司的工作人员？一般不用主动找，你发表若干博文后，他们会主动找你。如果你细问，“您是出版社编辑还是图书公司的编辑”，他们会表明身份，如果你再细问，那么他们可能会站在图书公司的立场上解释出版社和图书公司的差异。</p>\n<p>从中大家可以看到，不管你最终是否写成书，但去找知名出版社的编辑，并不难。并且，你找到后，他们还会进一步和你交流选题。</p>\n<h2>5.定选题和出书的流程</h2>\n<p>这里给出我和出版社编辑交流合作，最终出书的流程。</p>\n<p>第一，联系上出版社编辑后，先讨论选题，你可以选择一个你比较熟悉的方向，或者你愿意专攻的方向，这个方向可以是 java 分布式组件，Spring cloud 全家桶，微服务，或者是 Python 数据分析，机器学习或深度学习等。这方面你如果有扎实的项目经验那最好，如果你当下虽然不熟悉，但你有毅力经过短时间的系统学习确保你写的内容能成系统或者能帮到别人，那么你也可以在这方面出书。</p>\n<p>第二，定好选题方向后，你可以先列出大纲，比如以 Python 数据分析为例，你可以定 12 个章节，第一章讲语法，第二章讲 numpy 类等等，以此类推，你定大纲的时候，可以参考别人书的目录，从而制定你的写作内容。定好大纲以后，你可以和编辑交流，当编辑也认可这个大纲以后，就可以定出版协议。</p>\n<p>对一般作者而言，出版协议其实差不多，稿酬一般是 8 个点，写作周期是和出版社协商，支付周期可能也大同小异，然后出版社会买断这本书的电子以及各种文字的版权。但如果作者是大牛，那么这些细节都可以和出版社协商。</p>\n<p>然后是写书，这是很枯燥的，尤其是写最后几章的时候。我一般是工作日每天用半小时，两天周末周末用 4,5 个小时写，这样一般半年能写完一本 300 页的书，关于高效写书的技巧，后文会详细提及。</p>\n<p>在写书时，一般建议每写好一个章节就交给编辑审阅，这样就不会导致太大问题的出现，而且如果是新手作者，刚开始的措辞和写作技巧都需要积累，这样出版社的编辑在开始阶段也能及时帮到作者。</p>\n<p>当你写完把稿件交到编辑以后，可能会有三校三审的事情，在其中同我合作的编辑会帮助我修改语法和错别字等问题，然后会形成一个修改意见让我确认和修改。我了解下来，如果在图书公司出书，退稿的风险一般就发生在这个阶段，因为图书公司可能是会一次性地把稿件提交给出版社。但由于我会把每个章节都直接提交给出版社编辑审阅，所以即使有大问题，那么在写开始几个章节时都已经暴露并修改，所以最后的修改意见一般不会太长。也就是说，如果是直接和出版社沟通，在三校三审阶段，工作量可能未必大，我一般是在提交一本书以后，由编辑做这个事情，然后我就继续策划并开始写后一本书。</p>\n<p>最后就是拿稿酬，之前已经说了，作者其实不应该对稿酬有太大的期望，也就是聊胜于无。但如果一不小心写了本销量在 5000 乃至 10000 本左右的畅销书，那么可能在一年内也能有 5 万左右的额外收益，并能在业内积累些名气。</p>\n<h2>6.出案例书比出经验书要快</h2>\n<p>对一些作者而言，尤其是新手作者，出书不容易，往往是开始几个章节干劲十足，后面发现问题越积越多，外加工作一忙，就不了了之了，或者用 1 年以上的时间才能完成一本书。对此，我的感受是，一本 300 到 400 书的写作周期最长是 8 个月。为了能在这个时间段里完成一本书，我对应给出的建议是，新手作者可以写案例书，别先写介绍经验类的书。</p>\n<p>什么叫案例书？比如一本书里用一个大案例贯穿，系统介绍一个知识点，比如小程序开发，或者全栈开发等。或者一本书一个章节放一个案例，在一本书里给出 10 个左右 Python 深度学习方面的案例。什么叫经验类书呢？比如介绍面试经验的书就属于这这种，或者一些技术大牛写的介绍分布式高并发开发经验的书也算经验类书。</p>\n<p>请注意这里并没有区分两类书的差异，只是对新手作者而言，案例书好写。因为在其中，更多的是看图说话，先给出案例（比如 Python 深度学习里的图像识别案例），然后通过案例介绍 API 的用法（比如 Python 对应库的用法），以及技术的综合要点（比如如何用 Python 库综合实现图像识别功能）。并且案例书里需要作者主观发挥的点比较少，作者无需用自己的话整理相关的经验。对新手作者而言，在组织文字介绍经验时，可能会有自己明白但说不上来的感觉，这样一方面就无法达到预期的效果，另一方面还有可能因为无法有效表述而导致进度的延迟。</p>\n<p>但相反对于案例书，第一案例一般可以借鉴别人的，第二介绍现存的技术总比介绍自己的经验要容易，第三一般还有同类的书可以供作者参考，所以作者不大需要斟酌措辞，新手作者用半年到八个月的时间也有可能写完一本。当作者通过写几本书积累一定经验后，再去挑战经验类书，在这种情况下，写出来的经验类书就有可能畅销了。</p>\n<p>那么具体而言，怎么高效出一本案例书呢？</p>\n<ul>\n<li>对整本书而言，先用少量章节介绍搭建环境和通用基本语法的内容。</li>\n<li>在写每个章节案例时，用到总分总的结构，先总体介绍下你这个案例的需求功能，以及要用的技术点，再分开介绍每个功能点的代码实现，最后再总结下这些功能点的使用要点。</li>\n<li>在介绍案例中具体代码时，也可以用到总分总的结构，即先总体介绍下这段代码的结构，再分别给出关键代码的说明，最后再给出运行效果并综述其中技术的实现要点。</li>\n</ul>\n<p>这样的话，刚开始可以是 1 个月一个章节，写到后面熟练以后估计一个月能写两个章节，这样 8 个月完成一本书，也就不是不可能了。</p>\n<h2>7.如何在参考现有内容的基础上避免版权问题</h2>\n<p>写书时，一般多少都需要参考现有的代码和现有的书，但这绝不是重复劳动。比如某位作者整合了不同网站上多个案例，然后系统地讲述了 Python 数据分析，这样虽然现成资料都有，但对读者来说，就能一站式学习。同样地，比如在 Python 神经网络方面，现有 2,3 本书分别给出了若干人脸识别等若干案例，但如果你有效整合到一起，并加他人的基础上加上你的功能，那对读者来说也是有价值的。</p>\n<p>这里就涉及到版权问题，先要说明，作者不能抱有任何幻想，如果出了版权问题，书没出版还好，如果已经出版了，作者不仅要赔钱，而且在业内就会有不好的名声，可谓身败名裂。但其实要避免版权问题一点也不难。</p>\n<ul>\n<li>不能抄袭网上现有的内容，哪怕一句也不行。对此，作者可以在理解人家语句含义的基础上改写。不能抄袭人家书上现有的目录，更不能抄袭人家书上的话，同样一句也不行，对应的解决方法同样是在理解的基础上改写。</li>\n<li>不能抄袭 GitHub 上或者任何地方别人的代码，哪怕这个代码是开源的。对此，你可以在理解对方代码的基础上，先运行通，然后一定得自己新建一个项目，在你的项目里参考别人的代码实现你的功能，在这个过程中不能有大段的复制粘贴操作。也就是说，你的代码和别人的代码，在注释，变量命名，类名和方法名上不能有雷同的地方，当然你还可以额外加上你自己的功能。</li>\n<li>至于在写技术和案例介绍时，你就可以用你自己的话来说，这样也不会出现版权问题。</li>\n</ul>\n<p>用了上述办法以后，作者就可以在参考现有资料的基础上，充分加上属于你的功能，写上你独到的理解，从而高效地出版属于你自己的书。</p>\n<h2>8.新手作者需要着着重避免的问题</h2>\n<p>在上文里详细给出了出书的流程，并通过案例书，给出了具体的习作方法，这里就特别针对新手作者，给出些需要注意的实践要点。</p>\n<ul>\n<li>技术书不同于文艺书，在其中首先要确保把技能知识点讲清楚，然后再此基础上可以适当加上些风趣生动的措辞。所以对新手作者而言，甚至可以直接用朴素的文字介绍案例技术，而无需过多考虑文字上的生动性。</li>\n<li>内容需要针对初学者，在介绍技术时，从最基本的零基础讲起，别讲太深的。这里以 Python 机器学习为例，可以从什么是机器学习以及 Python 如何实现机器学习讲起，但如果首先就讲机器学习里的实践经验，就未必能确保初学者能学会。</li>\n<li>新手作者恨不得把自己知道的都写出来。这种态度非常好，但需要考虑读者的客观接受水平所以需要在写书前设置个预期效果，比如零基础的 Python 开发人员读了我的书以后至少能干活。这个预期效果别不可行，比如不能是“零基础的 Python 开发人员读了我书以后能达到 3 年开发的水准”。这样就可以根据预先制定的效果，制定写作内容，从在你的书就能更着重讲基础知识，这样读者就能有真正有收获。</li>\n</ul>\n<p>不过话说回来，如果新手作者直接和出版社编辑联系，找个热门点的方向，并根据案例仔细讲解技术，甚至都有可能写出销量过万的畅销书。</p>\n<h2>9.总结：在国内知名出版社出书，其实是个体力活</h2>\n<p>可能当下，写公众号和录视频等的方式，挣钱收益要高于出书，不过话可以这样说，经营公众号和录制视频也是个长期的事情，在短时间里可能未必有收益，如果不是系统地发表内容的话，可能甚至不会有收益。所以出书可能是个非常好的前期准备工作，你靠出书系统积累了素材，靠出书整合了你的知识体系，那么在此基础上，靠公众号或者录视频挣钱可能就会事半功倍。</p>\n<p>从上文里大家可以看到，在出书前期，联系出版社编辑和定选题并不难，如果要写案例书，那么在参考别人内容的基础上，要写完一般书可能也不是高不可攀的事情。甚至可以这样说，出书是个体力活，只要坚持，要出本书并不难，只是你愿不愿意坚持下去的问题。但一旦你有了属于自己的技术书，那么在找工作时，你就能自信地和面试官说你是这方面的专家，在你的视频、公众号和文字里，你也能正大光明地说，你是计算机图书的作者。更为重要的是，和名校、大厂经历一样，属于你的技术书同样是证明程序员能力的重要证据，当你通过出书有效整合了相关方面的知识体系后，那么在这方面，不管是找工作，或者是干私活，或者是接项目做，你都能理直气壮地和别人说：我能行！</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "hsm_computer"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "程序员怎样出版一本技术书",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book.html",
      "summary": "推荐语：详细介绍了程序员应该如何从头开始出一本自己的书籍。 原文地址：https://www.cnblogs.com/JavaArchitect/p/12195219.html 在面试或联系副业的时候，如果能令人信服地证明自己的实力，那么很有可能事半功倍。如何证明自己的实力？最有信服力的是大公司职位背景背书，没有之一，比如在 BAT 担任资深架构，那么...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：详细介绍了程序员应该如何从头开始出一本自己的书籍。</p>\n<br>\n<p><strong>原文地址</strong>：https://www.cnblogs.com/JavaArchitect/p/12195219.html</p>\n</blockquote>\n<p>在面试或联系副业的时候，如果能令人信服地证明自己的实力，那么很有可能事半功倍。如何证明自己的实力？最有信服力的是大公司职位背景背书，没有之一，比如在 BAT 担任资深架构，那么其它话甚至都不用讲了。</p>\n<p>不过，不是每个人入职后马上就是大公司架构师，在上进的路上，还可以通过公众号，专栏博文，GitHub 代码量和出书出视频等方式来证明自己。和其它方式相比，属于自己的技术图书由于经过了国家级出版社的加持，相对更能让别人认可自己的实力，而对于一些小公司而言，一本属于自己的书甚至可以说是免面试的通行证。所以在本文里，就将和广大程序员朋友聊聊出版技术书的那些事。</p>\n<h2>1.不是有能力了再出书，而是在出书过程中升能力</h2>\n<p>我知道的不少朋友，是在工作 3 年内出了第一本书，有些优秀的，甚至在校阶段就出书了。</p>\n<p>与之相比还有另外一种态度，不少同学可能想，要等到技术积累到一定程度再写。其实这或许就不怎么积极了，边写书，边升技术，而且写出的书对人还有帮助，这绝对可以做到的。</p>\n<p>比如有同学向深入了解最近比较热门的 Python 数据分析和机器学习，那么就可以在系统性的学习之后，整理之前学习到的爬虫，数据分析和机器学习的案例，根据自己的理解，用适合于初学者的方式整理一下，然后就能出书了。这种书，对资深的人帮助未必大，但由于包含案例，对入门级的读者绝对有帮助，因为这属于现身说法。而且话说回来，如果没有出书这个动力，或者学习过程也就是浅尝辄止，或者未必能全身心地投入，有了出书这个目标，更能保证学习的效果。</p>\n<h2>2.适合初级开发，高级开发和架构师写的书</h2>\n<p>之前也提到了，初级开发适合写案例书，就拿 Python 爬虫数据分析机器学习题材为例，可以先找几本这方面现成的书，这些书里，或者章节内容不同，但一起集成看的话，应该可以包含这方面的内容。然后就参考别人书的思路，比如一章写爬虫，一章写 pandas，一章写 matplotlib 等等，整合起来，就可以用 若干个章节构成一本书了。总之，别人书里包含什么内容，你别照抄，但可以参考别人写哪些技术点。</p>\n<p>定好章节后，再定下每个章节的小节，比如第三章讲爬虫案例，那么可以定 3.1 讲爬虫概念，3.2 讲如何搭建 Scrapy 库，3.3 讲如何开发 Scrapy 爬虫案例，通过先章再节的次序，就可以定好一本书的框架。由于是案例书，所以是先给运行通的代码，再用这些代码案例教别人入门，所以案例未必很深，但需要让初学者看了就能懂，而且按照你给出的知识体系逐步学习之后，能理解这个主题的内容。并且，能在看完你这本书以后，能通过调通你给出的爬虫，机器学习等的案例，掌握这一领域的知识，并能从事这方面的基本开发。这个目标，对初级开发而言，稍微用点心，费点时间，应该不难达到。</p>\n<p>而对于高级开发和架构师而言，除了写存粹案例书以外，还可以在书里给出你在大公司里总结出来的开发经验，也就是所谓踩过的坑，比如 Python 在用 matplotlib 会图例时，在设置坐标轴方面有哪些技巧，设置时会遇到哪些常见问题，如果在书里大量包含这种经验，你的书含金量更高。</p>\n<p>此外，高级开发和架构师还可以写一些技术含量更高的书，比如就讲高并发场景下的实践经验，或者 k8s+docker 应对高并发的经验，这种书里，可以给出代码，更可以给出实施方案和架构实施技巧，比如就讲高并发场景里，缓存该如何选型，如何避免击穿，雪崩等场景，如何排查线上 redis 问题，如何设计故障应对预案。除了这条路之外，还可以深入细节，比如通过讲 dubbo 底层代码，告诉大家如何高效配置 dubbo，出了问题该如何排查。如果架构师或高级开发有这类书作为背书，外带大厂工作经验，那么就更可以打出自己的知名度。</p>\n<h2>3.可以直接找出版社，也可以找出版公司</h2>\n<p>在我的这篇博文里，<a href=\"https://www.cnblogs.com/JavaArchitect/p/11616906.html\" target=\"_blank\" rel=\"noopener noreferrer\">程序员副业那些事：聊聊出书和录视频</a>，给出了通过出版社出书和图书公司出书的差别，供大家参考，大家看了以后可以自行决定出书方式。</p>\n<p>不过不管怎么选，在出书前你得搞明白一些事，或许个别图书出版公司的工作人员不会主动说，这需要你自己问清楚。</p>\n<ul>\n<li>你的合作方是谁？图书出版公司还是出版社？</li>\n<li>你的书将在哪个出版社出版？国内比较有名的是清华，人邮，电子和机械，同时其它出版社不能说不好，但业内比较认这四个。</li>\n<li>和你沟通的人，是最终有决定权的图书编辑吗？还是图书公司里的工作人员？再啰嗦下，最后能决定书能否出版，以及确定修改意见的，是出版社的编辑。</li>\n</ul>\n<p>通过对比出版社和图书出版公司，在搞清楚诸多细节后，大家可以自己斟酌考虑合作的方式。而且，出版社和图书公司的联系方式，在官网上都有，大家可以自行通过邮件等方式联系。</p>\n<h2>4.如果别人拿你做试错对象，或有不尊重，赶紧止损</h2>\n<p>我之前看到有图书出版公司招募面向 Java 初学者图书的作者，并且也主动联系过相关人员，得到的反馈大多是：“要重写”。</p>\n<p>比如我列了大纲发过去，反馈是“要重写”，原因是对方没学过 Java，但作为零基础的人看了我的大纲，发现学不会。至于要重写成什么样子 ，对方也说不上来，总之让我再给个大纲，再给一版后，同样没过，这次好些，给了我几本其它类似书的大纲，让我自行看别人有什么好的点。总之不提（或者说提不出）具体的改进点，要我自行尝试各种改进点，试到对方感觉可以为止。</p>\n<p>相比我和几位出版社专业的编辑沟通时，哪怕大纲或稿件有问题，对方会指明到点，并给出具体的修改意见。我不知道图书出版公司里的组织结构，但出版社里，计算机图书有专门的部门，专门的编辑，对方提出的意见都是比较专业，且修改起来很有操作性。</p>\n<p>另外，我在各种渠道，时不时看到有图书出版公司的人员，晒出别人交付的稿件，在众目睽睽之下，说其中有什么问题，意思让大家引以为戒。姑且不论这样做的动机，并且这位工作人员也涂掉了能表面作者身份的信息。但作者出于信任把稿件交到你手上，在不征得作者同意就公开稿件，说“不把作者当回事”，这并不为过。不然，完全可以用私信的方式和作者交流，而不是把作者无心之过公示于众。</p>\n<p>我在和出版社合作时，这类事绝没发生过，而且我认识的出版社编辑，都对各位作者保持着足够的尊重。而且我和我的朋友和多位图书出版公司的朋友交流时，也能得到尊重和礼遇。所以，如果大家在写书时，尤其在写第一本书时，如果遇到被试错，或者从言辞等方面感觉对方不把你当会事，那么可以当即止损。其实也没有什么“损失”，你把当前的大纲和稿件再和出版社编辑交流时，或许你的收益还能提升。</p>\n<h2>5.如何写好 30 页篇幅的章节？</h2>\n<p>在和出版社定好写作合同后，就可以创作了。书是由章节构成，这里讲下如何构思并创作一个章节。</p>\n<p>比如写爬虫章节，大概 30 页，先定节和目，比如 3.1 搭建爬虫环境是小节，3.1.1 下载 Python Scrapy 包，则是目。先定要写的内容，具体到爬虫小节，可以写 3.1 搭建环境，3.2 Scrapy 的重要模块，3.3 如何开发 Scrapy 爬虫，3.4 开发好以后如何运行，3.5 如何把爬到的信息放入数据库，这些都是小节。</p>\n<p>再具体到目，比如 3.5 里，3.5.1 里写如何搭建数据库环境 3.5.2 里写如何在 Scrapy 里连接数据库 3.5.3 里给出实际案例 3.5.4 里给出运行步骤和示例效果。</p>\n<p>这样可以搭建好一个章的框架，在每个小节里，先给出可以运行通的，而且能说明问题的代码，再给出对代码的说明，再写下代码如何配置，开发时该注意哪些问题，必要时用表格和图来说明，用这样的条理，最多 3 个星期可以完成一个章节，快的话一周半就一个章节。</p>\n<p>以此类推，一本书大概有 12 个章节，第一章可以讲如何安装环境，以及基础语法，后面就可以由浅入深，一个章节一个主题，比如讲 Python 爬虫，第二章可以是讲基础语法，第三章讲 http 协议以及爬虫知识点，以此深入，讲全爬虫，数据分析，数据展示和机器学习等技能。</p>\n<p>按这样算，如果出第一本书，平均下来一个月 2 个章节，大概半年到八个月可以完成一本书，思路就是先搭建书的知识体系，写每个章节时再搭建某个知识点的框架，在小节和目里，用代码结合说明的方式，这样从简到难，大家就可以完成第一本属于自己的书了。</p>\n<h2>6.如何写出一本销量过 5 千的书</h2>\n<p>目前纸质书一般一次印刷在 2500 册，大多数书一般就一次印刷，买完为止。如果能销调 5000 本，就属于受欢迎了，如果销量过万，就可以说是大神级书的。这里先不论大神级书，就说下如何写一本过 5000 的畅销书。</p>\n<p>1 最好贴近热点，比如当前热点是全栈开发和机器学习等，如何找热点，就到京东等处去看热销书的关键字。具体操作起来，多和出版社编辑沟通，或许作者更多是从技术角度分析，但出版社的编辑是从市场角度来考虑问题。</p>\n<p>2 如果你的书能被培训机构用作教材，那想不热都不行。培训机构一般用哪些教材呢？第一面向初学者，第二代码全面，第三在这个领域里涵盖知识点全。如果要达成这点，大家可以和出版社的编辑直接沟通，问下相关细节。</p>\n<p>3 可以文字生动，但不能用过于花哨的文字来掩盖书的内涵不足，也就是说畅销书一定要有干货，能解决初学者实际问题，比如 Python 机器学习方向，就写一本用案例涵盖目前常用的机器学习算法，一个章节一种算法，并且案例中有可视化，数据分析，爬虫等要素，可视化的效果如果再吸引人，这本书畅销的可能性也很大。</p>\n<p>4 一定不能心存敷衍，代码调通不算，更力求简洁，说明文字多面向读者，内容上，确保读者一看就会，而且看了有收获，或许这点说起来很抽象，但我写了几本书以后切身体会，要做到这很难，同时做到了，书哪怕不畅想，但至少不误人子弟。</p>\n<h2>7.总结，出书仅是一个里程碑，程序员在上进路上应永不停息</h2>\n<p>出书不简单，因为不是每个人都愿意在半年到八个月里，每个晚上每个周末都费时费力写书。但出书也不难，毕竟时间用上去了，出书也只是调试代码加写文字的活，最多再外加些和人沟通的成本。</p>\n<p>其实出书收益并不高，算下来月入大概能在 3k 左右，如果是和图书出版公司合作，估计更少，但这好歹能证明自己的实力。不过在出书后不能止步于此，因为在大厂里有太多的牛人，甚至不用靠出书来证明自己的实力。</p>\n<p>那么如何让出书带来的利益最大化呢？第一可以靠这进大厂，面试时有自己的书绝对是加分项。第二可以用这个去各大网站开专栏，录视频，或者开公众号，毕竟有出版社的背书，能更让别人信服你的能力。第三更得用写书时积累的学习方法和上进的态势继续专研更高深技术，技术有了，不仅能到大厂挣更多的钱，还能通过企业培训等方式更高效地挣钱。</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [
        {
          "name": "hsm_computer"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "32条总结教你提升职场经验",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/work/32-tips-improving-career.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/work/32-tips-improving-career.html",
      "summary": "推荐语：阿里开发者的一篇职场经验的分享。 原文地址： https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g 成长的捷径 入职伊始谦逊的态度是好的，但不要把“我是新人”作为心理安全线； 写一篇技术博客大概需要两周左右，但可能是最快的成长方式； 一定要读两本书：金字塔原理、高效能人士的七个习惯（这本书名字像成功...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：阿里开发者的一篇职场经验的分享。</p>\n<p><strong>原文地址：</strong> <a href=\"https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g</a></p>\n</blockquote>\n<h2>成长的捷径</h2>\n<ul>\n<li>入职伊始谦逊的态度是好的，但不要把“我是新人”作为心理安全线；</li>\n<li>写一篇技术博客大概需要两周左右，但可能是最快的成长方式；</li>\n<li>一定要读两本书：金字塔原理、高效能人士的七个习惯（这本书名字像成功学，实际讲的是如何塑造性格）；</li>\n<li>多问是什么、为什么，追本溯源把问题解决掉，试图绕过的问题永远会在下个路口等着你；</li>\n<li>不要沉迷于忙碌带来的虚假安全感中，目标的确定和追逐才是最真实的安全；</li>\n<li>不用过于计较一时的得失，在公平的环境中，吃亏是福不是鸡汤；</li>\n<li>思维和技能不要受限于前端、后端、测试等角色，把自己定位成业务域问题的终结者；</li>\n<li>好奇和热爱是成长最大的捷径，长期主义者会认同自己的工作价值，甚至要高于组织当下给的认同（KPI）。</li>\n</ul>\n<h2>功夫在日常</h2>\n<ul>\n<li>每行代码要代表自己当下的最高水平，你觉得无所谓的小细节，有可能就是在晋升场上伤害你的暗箭；</li>\n<li>双周报不是工作日志流水账，不要被时间推着走，最起码要知道下次双周报里会有什么（小目标驱动）；</li>\n<li>觉得日常都是琐碎工作、不技术、给师兄打杂等，可以尝试对手头事情做一下分类，想象成每个分类都是个小格子，这些格子连起来的终点就是自己的目标，这样每天不再是机械的做需求，而是有规划的填格子、为目标努力，甚至会给自己加需求，因为自己看清楚了要去哪里；</li>\n<li>日常的言行举止是能力的显微镜，大部分人可能意识不到，自己的强大和虚弱是那么的明显，不要无谓的试图掩盖，更不存在蒙混过关。</li>\n</ul>\n<blockquote>\n<p>最后一条大概意思就是有时候我们会在意自己在聚光灯下（述职、晋升、周报、汇报等）的表现，以为大家会根据这个评价自己。实际上日常是怎么完成业务需求、帮助身边同学、创造价值的，才是大家评价自己的依据，而且每个人是什么样的特质，合作过三次的伙伴就可以精准评价，在聚光灯下的表演只能骗自己。</p>\n</blockquote>\n<h2>学会被管理</h2>\n<blockquote>\n<p>上级、主管是泛指，开发对口的 PD 主管等也在范围内。</p>\n</blockquote>\n<ul>\n<li>\n<p>不要传播负面情绪，不要总是抱怨；</p>\n</li>\n<li>\n<p>对上级不卑不亢更容易获得尊重，但不要当众反驳对方观点，分歧私下沟通；</p>\n</li>\n<li>\n<p>好好做向上管理，尤其是对齐预期，沟通绩效出现 Surprise 双方其实都有责任，但倒霉的是自己；</p>\n</li>\n<li>\n<p>尽量站在主管角度想问题：</p>\n</li>\n<li>\n<ul>\n<li>这样能理解很多过去感觉匪夷所思的决策；</li>\n<li>不要在意谁执行、功劳是谁的等，为团队分忧赢得主管信任的重要性远远高于这些；</li>\n<li>不要把这个原则理解为唯上，这种最让人不齿。</li>\n</ul>\n</li>\n</ul>\n<h2>思维转换</h2>\n<ul>\n<li>定义问题是个高阶能力，尽早形成 发现问题-&gt;定义问题-&gt;解决问题-&gt;消灭问题 的思维闭环；</li>\n<li>定事情价值导向，做事情结果导向，讲事情问题导向；</li>\n<li>讲不清楚，大概率不是因为自己是实干型，而是没想清楚，在晋升场更加明显；</li>\n<li>当一个人擅长解决某一场景的问题的时候，时间越久也许越离不开这个场景（被人贴上一个标签很难，撕掉一个标签更难）。</li>\n</ul>\n<h2>要栓住情绪</h2>\n<ul>\n<li>学会控制情绪，没人会认真听一个愤怒的人在说什么；</li>\n<li>再委屈、再愤怒也要保持理智，不要让自己成为需要被哄着的那种人；</li>\n<li>足够自信的人才会坦率的承认自己的问题，很多时候我们被激怒了，只是因为对方指出了自己藏在深处的自卑；</li>\n<li>伤害我们最深的既不是别人的所作所为，也不是自己犯的错误，而是我们对错误的回应。</li>\n</ul>\n<h2>成为 Leader</h2>\n<blockquote>\n<p>Manager 有下属，Leader 有追随者，管理者不需要很多，但人人都可以是 Leader。</p>\n</blockquote>\n<ul>\n<li>让你信服、愿意追随的人不是职务上的 Manager，而是在帮助自己的那个人，自己想服众的话道理一样；</li>\n<li>不要轻易对人做负面评价，片面认知下的评价可能不准确，不经意的传播更是会给对方带来极大的困扰；</li>\n<li>Leader 如果不认同公司的使命、愿景、价值观，会过的特别痛苦；</li>\n<li>困难时候不要否定自己的队友，多给及时、正向的反馈；</li>\n<li>船长最重要的事情不是造船，而是激发水手对大海的向往；</li>\n<li>Leader 的天然职责是让团队活下去，唯一的途径是实现上级、老板、公司经营者的目标，越是艰难的时候越明显；</li>\n<li>Leader 的重要职责是识别团队需要被做的事情，并坚定信念，使众人行，越是艰难的时候越要坚定；</li>\n<li>Leader 应该让自己遇到的每个人都感觉自己很重要、被需要。</li>\n</ul>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "聊聊大厂的绩效考核",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/work/employee-performance.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/work/employee-performance.html",
      "summary": "内容概览： 在大部分公司，绩效跟你的年终奖、职级晋升、薪水涨幅等等福利是直接相关的。 你的上级、上上级对你的绩效拥有绝对的话语权，这是潜规则，放到任何公司都是。成年人的世界，没有绝对的公平，绩效考核尤为明显。 提升绩效的打法： 短期打法：找出 1-2 件事，体现出你的独特价值（抓关键事件）。 长期打法：通过一步步信任的建立，成为团队的核心人员或者是老板...",
      "content_html": "<blockquote>\n<p><strong>内容概览</strong>：</p>\n<ul>\n<li>在大部分公司，绩效跟你的年终奖、职级晋升、薪水涨幅等等福利是直接相关的。</li>\n<li>你的上级、上上级对你的绩效拥有绝对的话语权，这是潜规则，放到任何公司都是。成年人的世界，没有绝对的公平，绩效考核尤为明显。</li>\n<li>提升绩效的打法：\n<ul>\n<li>短期打法：找出 1-2 件事，体现出你的独特价值（抓关键事件）。</li>\n<li>长期打法：通过一步步信任的建立，成为团队的核心人员或者是老板的心腹，具备不可替代性。</li>\n</ul>\n</li>\n</ul>\n<br>\n<p><strong>原文地址</strong>：https://mp.weixin.qq.com/s/D1s8p7z8Sp60c-ndGyh2yQ</p>\n</blockquote>\n<p>在新公司度过了一个完整的 Q3 季度，被打了绩效，也给下属打了绩效，感慨颇深。</p>\n<p>今天就好好聊聊<strong>大厂打工人最最关心的「绩效考核」</strong>，谈谈它背后的逻辑以及潜规则，摸清楚了它，你在大厂这片丛林里才能更好的生存下去。</p>\n<h2>大厂的绩效到底有多重要？</h2>\n<p>先从公司角度，谈谈为什么需要绩效考核？</p>\n<p>有一个著名的管理者言论，即：企业战略的上三路和下三路。</p>\n<blockquote>\n<p>上三路是使命、愿景、价值观，下三路是组织、人才、KPI。下三路需要确保上三路能执行下去，否则便是空谈。那怎么才能达成呢？</p>\n</blockquote>\n<p>马老板在湖畔大学的课堂上，对底下众多 CEO 学员说，“只能靠 KPI。没有 KPI，一切都是空话，组织和公司是不会进步的”。</p>\n<p>所以，KPI 一般是用来承接企业战略的。身处大厂的打工者们，也能深深感受到：每个季度的 KPI 是如何从大 Boss、到 Boss、再到基层，一层层拆解下来的，最终让所有人朝着一个方向行动，这便是 KPI 对于公司的意义。</p>\n<p>然鹅，并非每个员工都会站在 CEO 的高度去理解 KPI 的价值，大家更关注的是 KPI 对于我个人来说到底有什么意义？</p>\n<p>在互联网大厂，每家公司都会设定一套绩效考核体系，字节用的是 OKR，阿里用的是 KPI，通常都是「271」 制度，即：</p>\n<blockquote>\n<p>20% 的比例是 A+ 和 A，对应明星员工。</p>\n<p>70% 的比例是 B，对应普通员工。</p>\n<p>10% 的比例是 C 和 C-，对应需要绩效改进或者淘汰的员工。</p>\n</blockquote>\n<p>有了三六九等，然后才有了利益分配。</p>\n<p><strong>在大厂，绩效结果跟奖金、晋升、薪水涨幅、股票授予是直接相关的。在内卷的今天，甚至可以直接划上等号。</strong></p>\n<p>绩效好的员工，奖金必然多，一年可能调薪两次，晋升答辩时能 PK 掉绩效一般的人，职级低的人甚至可以晋升免试。</p>\n<p>而绩效差的人，有可能一年白干，甚至走人（大厂的末尾淘汰是不成文的规定）。</p>\n<p>总之，你能想到的直接利益都和「绩效」息息相关。所以，在大厂这片高手众多的丛林里，多琢磨下绩效背后的逻辑，既是生存之道，更是一技之长。</p>\n<h2>你是怎么看待绩效的？</h2>\n<p>凡是用来考核人的规则，大部分人在潜意识里都想去突破它，而不是被束缚。</p>\n<p>至少在我刚工作的前几年，看着身边有些同事因为背个 C 黯然离开的时候，觉得绩效考核就是一个冷血的管理工具。</p>\n<p>尤其遇到自己看不上的领导时，对于他给我打的绩效，其实也是很不屑的。</p>\n<p>到今天，实在见过太多的反面案例了，自己也踩过一些坑，逐渐认识到：当初的想法除了让自己心里爽一点，好像起不到任何作用，甚至会让我的工作方式变形。</p>\n<p>当思维方式变了，也就改变了我对绩效的态度，至少有两点我认为是打工人需要看清的。</p>\n<p><strong>第一，你的上级、上上级对你的绩效拥有绝对的话语权，这是潜规则，放到任何公司都是。</strong></p>\n<p>大家可以去看看身边发展特别好的人，除了有很强的个人能力以外，几乎都是善于利用规则，而不是去挑战规则的人。</p>\n<p>当然，我并不是说你要一味地去跪舔你的领导，而是表达：工作中不要站在领导的对立面去做对抗，如果领导做法很过分，要么直接沟通去影响他，要么选择离开。</p>\n<p><strong>第二，成年人的世界，没有绝对的公平，绩效考核尤为明显。</strong></p>\n<p>我所待过的团队，绩效考核还是相对公平的，虽然也存在受照顾的情况，但都是个例。</p>\n<p>另外就是，技术岗的绩效考核不同于销售或者运营岗，很容易指标化。</p>\n<p>需求吞吐量、BUG 数、线上事故... 的确有一大堆研发效能指标，但这些指标在绩效考核时是否会被参考？具体又该如何分配比重？本身就是一个扯不清楚的难题。</p>\n<p>最终决定你绩效结果的还是你领导的主观判断。你所见到的 360 环评，以及弄一些指标排序，这些都只是将绩效结果合理化的一种方式，并非关键所在。</p>\n<p>因此，多琢磨如何去影响你的领导？站在他的视角去审视他在绩效考核时到底关注哪些核心点？这才是至关重要的。</p>\n<p>上面讲了一堆潜规则，是不是意味着绩效考核是可以投机取巧，完全不看工作业绩呢，当然不是。</p>\n<p>“你的努力不一定会被看见”、“你的努力应该有的放矢”，大家先记住这两条。</p>\n<p>下面我再展开聊聊，大家最最关心的 A 和 C，它们背后的逻辑。</p>\n<h2>绩效被打 A 和 C 的逻辑是什么？</h2>\n<p>“铆足了劲拿不到 A，一不留神居然拿了个 C”，这是绝大多数打工人最真实的职场现状。</p>\n<p>A 和 C 属于绩效的两个极端，背后的逻辑类似，反着理解即可，下面我详细分析下 C。</p>\n<p>先从我身边人的情况说起，我所看到的案例绝大多数都属于：绩效被打了 C，完全没有任何预感，主管跟他沟通结果时，还是一脸懵逼，“为什么会给我打 C？一定是黑我呀！”。</p>\n<p>前阵子听公司一位大佬分享，用他的话说，这种人就是没有「角色认知」，他不知道他所处的角色和职级该做好哪些事？做成什么样才算「做好了」？被打 C 后自然觉得是在背锅。</p>\n<p>所以，务必确保你对于当前角色是认知到位的，这样才称得上进入了「工作状态」，否则你的一次松懈，一段不太好的表现，很可能导致 C 落在你的头上，岗位越高，摔得越重。</p>\n<p>有了角色认知，再说下对绩效的认知。</p>\n<p>第一，团队很优秀，是不是不用背 C？不是！大厂的 C 都是强制分配的，再优秀的团队也会有 C。所以团队越厉害，竞争越惨烈。</p>\n<p>第二，完成了 KPI，没有工作失误，是不是就万事大吉，不用背 C？不是，绩效是相对的，你必须清楚你在团队所处的位置，你在老板眼中的排序，慢慢练出这种嗅觉。</p>\n<p>懂了上面这些道理，很自然就能知道打 C 的逻辑，C 会集中在两类人上：</p>\n<blockquote>\n<p>1、工作表现称不上角色要求的人。</p>\n<p>2、在老板眼里排序靠后，就算离开，对团队影响也很小的人。</p>\n</blockquote>\n<p>要规避 C，有两种打法。</p>\n<p>第 1 种是短期打法：抓关键事件，能不能找出 1-2 件事，体现出你的独特价值（比如本身影响力很大的项目，或者是领导最重视的事），相当于让你的排序有了最基本的保障。</p>\n<p>这种打法，你不能等到评价时再去改变，一定是在前期就抓住机会，承担起最有挑战的任务，然后全力以赴，做好了拿 A，不弄砸也不至于背 C，就怕静水潜流，躺平了去工作。</p>\n<p>第 2 种是长期打法：通过一步步信任的建立，成为团队的核心人员或者是老板的心腹，具备不可替代性。</p>\n<p>上面两种打法都是大的思路，还有很多锦上添花的技巧，比如：加强主动汇报（抹平领导的信息差）、让关键干系人给你点赞（能影响到你领导做出绩效决策的人）。</p>\n<h2>写在最后</h2>\n<p>有人的地方就有江湖，有江湖就一定有规则，大厂平面看似平静，其实在绩效考核、晋升等利益点面前，都是一场厮杀。</p>\n<p>当大家攻山头的能力都很强时，**到底做成什么样才算做好了？**当你弄清楚了这个玄机，职场也就看透了。</p>\n<p>如果这篇文章让你有一点启发，来个点赞和在看呀！我是武哥，我们下期见！</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "新入职一家公司如何快速进入工作状态",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company.html",
      "summary": "推荐语：强烈建议每一位即将入职/在职的小伙伴看看这篇文章，看完之后可以帮助你少踩很多坑。整篇文章逻辑清晰，内容全面！ 原文地址：https://www.cnblogs.com/hunternet/p/14675348.html 新入职一家公司如何快速进入状态新入职一家公司如何快速进入状态 一年一度的金三银四跳槽大戏即将落幕，相信很多跳槽的小伙伴们已经找...",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：强烈建议每一位即将入职/在职的小伙伴看看这篇文章，看完之后可以帮助你少踩很多坑。整篇文章逻辑清晰，内容全面！</p>\n<br>\n<p><strong>原文地址</strong>：https://www.cnblogs.com/hunternet/p/14675348.html</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/work/新入职一家公司如何快速进入状态.png\" alt=\"新入职一家公司如何快速进入状态\" tabindex=\"0\"><figcaption>新入职一家公司如何快速进入状态</figcaption></figure>\n<p>一年一度的金三银四跳槽大戏即将落幕，相信很多跳槽的小伙伴们已经找到了心仪的工作，即将或已经有了新的开始。</p>\n<p>相信有过跳槽经验的小伙伴们都知道，每到一个新的公司面临的可能都是新的业务、新的技术、新的团队......这些可能会打破你原来工作思维、编码习惯、合作方式......</p>\n<p>而于公司而言，又不能给你几个月的时间去慢慢的熟悉。这个时候，如何快速进入工作状态，尽快发挥自己的价值是非常重要的。</p>\n<p>有些人可能会很幸运，入职的公司会有完善的流程与机制，通过一带一、各种培训等方式可以在短时间内快速的让新人进入工作状态。有些人可能就没有那么幸运了，就比如我在几年前跳槽进入某厂的时候，当时还没有像我们现在这么完善的带新人融入的机制，又赶上团队最忙的一段时间，刚一入职的当天下午就让给了我几个线上问题去排查，也没有任何的文档和培训。遇到情况，很多人可能会因为难以快速适应，最终承受不起压力而萌生退意。</p>\n<figure><img src=\"https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/bad175e3a380bea..jpg\" alt=\"bad175e3a380bea.\" tabindex=\"0\"><figcaption>bad175e3a380bea.</figcaption></figure>\n<p>那么，<strong>我们应该如何去快速的让自己进入工作状态，适应新的工作节奏呢？</strong></p>\n<p>新的工作面对着一堆的代码仓库，很多人常常感觉无从下手。但回顾一下自己过往的工作与项目的经验，我们可以发现它们有着异曲同工之处。当开始一个新的项目，一般会经历几个步骤：需求-&gt;设计-&gt;开发-&gt;测试-&gt;发布，就这么循环往复，我们完成了一个又一个的项目。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/work/image-20220704191430466.png\" alt=\"项目流程\" tabindex=\"0\"><figcaption>项目流程</figcaption></figure>\n<p>而在这个过程中主要有四个方面的知识那就是业务、技术、项目与团队贯穿始终。新入职一家公司，我们第一阶段的目标就是要具备能够跟着团队做项目的能力，因此我们所应尽快掌握的知识点也要从这四个方面入手。</p>\n<h2>业务</h2>\n<p>很多人可能会认为作为一个技术人，最应该了解的不应该是技术吗？于是他们在进入一家公司后，就迫不及待的研究起来了一些技术文档，系统架构，甚至抱起来源代码就开始“啃”，如果你也是这么做的，那就大错特错了！在几乎所有的公司里，技术都是作为一个工具存在的，虽然它很重要，但是它也是为了承载业务所存在的，技术解决了如何做的问题，而业务却告诉我们，做什么，为什么做。一旦脱离了业务，那么技术的存在将毫无意义。</p>\n<p>想要了解业务，有两个非常重要的方式</p>\n<p><strong>一是靠问</strong></p>\n<p>如果你加入的团队，有着完善的业务培训机制，详尽的需求文档，也许你不需要过多的询问就可以了解业务，但这只是理想中的情况，大多数公司是没有这个条件的。因此我们只能靠问。</p>\n<p>这里不得不提的是，作为一个新人一定要有一定的脸皮厚度，不懂就要问。我见过很多新人会因为内向、腼腆，遇到疑问总是不好意思去问，这导致他们很长一段时间都难以融入团队、承担更重要的责任。不怕要怕挨训、怕被怼，而且我相信绝对多数的程序员还是很好沟通的！</p>\n<p><strong>二是靠测试</strong></p>\n<p>我认为测试绝对是一个人快速了解团队业务的方式。通过测试我们可以走一走自己团队所负责项目的整体流程，如果遇到自己走不下去或想不通的地方及时去问，在这个过程中我们自然而然的就可以快速的了解到核心的业务流程。</p>\n<p>在了解业务的过程中，我们应该注意的是不要让自己过多的去追求细节，我们的目的是先能够整体了解业务流程，我们面向哪些用户，提供了哪些服务......</p>\n<h2>技术</h2>\n<p>在我们初步了解完业务之后，就该到技术了，也许你已经按捺不住翻开源代码的准备了，但还是要先提醒你一句先不要着急。</p>\n<p>这个时候我们应该先按照自己了解到的业务，结合自己过往的工作经验去思考一下如果是自己去实现这个系统，应该如何去做？这一步很重要，它可以在后面我们具体去了解系统的技术实现的时候去对比一下与自己的实现思路有哪些差异，为什么会有这些差异，哪些更好，哪些不好，对于不好我们可以提出自己的意见，对于更好的我们可以吸收学习为己用！</p>\n<p>接下来，我们就是要了解技术了，但也不是一上来就去翻源代码。 <strong>应该按照从宏观到细节，由外而内逐步地对系统进行分析。</strong></p>\n<p>首先，我们应该简单的了解一下 <strong>自己团队/项目的所用到的技术栈</strong> ，Java 还是.NET、亦或是多种语言并存，项目是前后端分离还是服务端全包，使用的数据库是 MySQL 还是 PostgreSQL......，这样我们可能会对所用到的技术和框架，以及自己所负责的内容有一定的预期，这一点有的人可能在面试的时候就会简单了解过。</p>\n<p>下一步，我们应该了解的是 <strong>系统的宏观业务架构</strong> 。自己的团队主要负责哪些系统，每个系统又主要包含哪些模块，又与哪些外部系统进行交互......对于这些，最好可以通过流程图或者思维导图等方式整理出来。</p>\n<p>然后，我们要做的是看一下 <strong>自己的团队提供了哪些对外的接口或者服务</strong> 。每个接口和服务所提供功能是什么。这一点我们可以继续去测试自己的系统，这个时候我们要看一看主要流程中主要包含了哪些页面，每个页面又调用了后端的哪些接口，每个后端接口又对应着哪个代码仓库。(如果是单纯做后端服务的，可以看一下我们提供了哪些服务，又有哪些上游服务，每个上游服务调用自己团队的哪些服务......)，同样我们应该用画图的形式整理出来。</p>\n<p>接着，我们要了解一下 <strong>自己的系统或服务又依赖了哪些外部服务</strong> ，也就是说需要哪些外部系统的支持，这些服务也许是团队之外、公司之外，也可能是其他公司提供的。这个时候我们可以简单的进入代码看一下与外部系统的交互是怎么做的，包括通讯框架(REST、RPC)、通讯协议......</p>\n<p>到了代码层面，我们首先应该了解每个模块代码的层次结构，一个模块分了多少层，每个层次的职责是什么，了解了这个就对系统的整个设计有了初步的概念，紧接着就是代码的目录结构、配置文件的位置。</p>\n<p>最后，我们可以寻找一个示例，可以是一个接口，一个页面，让我们的思路跟随者代码的运行的路线，从入参到出参，完整的走一遍来验证一下我们之前的了解。</p>\n<p>到了这里我们对于技术层面的了解就可以先告一段落了，我们的目的知识对系统有一个初步的认知，更细节的东西，后面我们会有大把的时间去了解</p>\n<h2>项目与团队</h2>\n<p>上面我们提到，新入职一家公司，第一阶段的目标是有跟着团队做项目的能力，接下来我们要了解的就是项目是如何运作的。</p>\n<p>我们应该把握从需求设计到代码编写入库最终到发布上线的整个过程中的一些关键点。例如项目采用敏捷还是瀑布的模式，一个迭代周期是多长，需求的来源以及展现形式，有没有需求评审，代码的编写规范是什么，编写完成后如何构建，如何入库，有没有提交规范，如何交付测试，发布前的准备是什么，发布工具如何使用......</p>\n<p>关于项目我们只需要观察同事，或者自己亲身经历一个迭代的开发，就能够大概了解清楚。</p>\n<p>在了解项目运作的同时，我们还应该去了解团队，同样我们应该先从外部开始，我们对接了哪些外部团队，比如需求从哪里来，是否对接公司外部的团队，提供服务的上游团队有哪些，依赖的下游团队有哪些，团队之间如何沟通，常用的沟通方式是什么.......</p>\n<p>接下来则是团队内部，团队中有哪些角色，每个人的职责是什么，这样遇到问题我们也可以清楚的找到对应的同事寻求帮助。是否有一些定期的活动与会议，例如每日站会、周例会，是否有一些约定俗成的规矩，是否有一些内部评审，分享机制......</p>\n<h2>总结</h2>\n<p>新入职一家公司，面临新的工作挑战，能够尽快进入工作状态，实现自己的价值，将会给你带来一个好的开始。</p>\n<p>作为一个程序员，能够尽快进入工作状态，意味着我们首先应该具备跟着团队做项目的能力，这里我站在了一个后端开发的角度上从业务、技术、项目与团队四个方面总结了一些方法和经验。</p>\n<p>关于如何快速进入工作状态，如果你有好的方法与建议，欢迎在评论区留言。</p>\n<p>最后我们用一张思维导图来回顾一下这篇文章的内容。如果你觉得这篇文章对你有所帮助，可以关注文末公众号，我会经常分享一些自己成长过程中的经验与心得，与大家一起学习与进步。</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/work/%E6%96%B0%E5%85%A5%E8%81%8C%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%8A%B6%E6%80%81.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "为什么使用单线程？",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/interview-shorthand/redis/why-use-single-thread.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/interview-shorthand/redis/why-use-single-thread.html",
      "summary": "Redis是单线程？ 实际上，Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。 在6.0后，Redis的网络请求模块也使用了多线程，其实在4.0时对部分命令做了多线程化，如新增命令了unlink，实际上是del的异步版本 为什么数据的操作模块设计成单线程的？ 多线程的目的，就是通过并发的方式来提...",
      "content_html": "<h2>Redis是单线程？</h2>\n<p>实际上，Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。\n在6.0后，Redis的网络请求模块也使用了多线程，其实在4.0时对部分命令做了多线程化，如新增命令了unlink，实际上是del的异步版本</p>\n<h2>为什么数据的操作模块设计成单线程的？</h2>\n<p>多线程的目的，就是通过并发的方式来提升I/O的利用率和CPU的利用率。\nRedis不需要提升CPU利用率，因为Redis的操作基本都是基于内存的，计算操作较少，CPU资源不是Redis的性能瓶颈。</p>\n<p>那么为什么不用多线程来提升I/O利用率呢？\nRedis确实是一个I/O操作密集的框架，他的数据操作过程中，会有大量的网络I/O和磁盘I/O的发生。要想提升Redis的性能，是一定要提升Redis的I/O利用率的，这一点毋庸置疑。</p>\n<p>但是，提升I/O利用率，并不是只有采用多线程技术这一条路可以走！</p>\n<h2>为什么单线程也能那么快？</h2>\n<ol>\n<li>基于内存</li>\n<li>单线程模型：不需要进行线程切换和上下文切换。</li>\n<li>多路复用 I/O 模型：采用了I/O 多路复用技术，实现了单个线程同时处理多个客户端连接的能力，从而提高了 Redis 的并发性能。</li>\n<li>高效的数据结构：哈希表、有序集合、列表等，这些数据结构都被实现得非常高效，能够在 O(1) 的时间复杂度内完成数据读写操作，这也是\nRedis 能够快速处理数据请求的重要因素之一。</li>\n<li>多线程的引入：在Redis 6.0中引入了多线程的机制，使得网络处理的请求并发进行，就可以大大的提升性能。多线程除了可以减少由于网络\nI/O 等待造成的影响，还可以充分利用 CPU 的多核优势。</li>\n</ol>\n<h2>6.0为什么引入多线程</h2>\n<p>Redis 6.0中的多线程，只是针对处理网络请求过程采用了多线程，而数据的读写命令，仍然是单线程处理的。</p>\n<p><strong>Redis不是号称单线程也有很高的性能吗？不是说IO多路复用已经大大提升了IO利用率吗？为什么还需要多线程？</strong></p>\n<p>随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的\nQPS。为了提升QPS，很多公司的做法是部署Redis集群，并且尽可能提升Redis机器数。但是这种做法的资源消耗是巨大的。</p>\n<p>而经过分析，限制Redis的性能的主要瓶颈出现在网络IO的处理上，并且多路复用的IO模型本质上仍然是同步阻塞型IO模型。</p>\n<p>在多路复用的IO模型中，在处理网络请求时，调用 select （其他函数同理）的过程是阻塞的，也就是说这个过程会阻塞线程，如果并发量很高，此处可能会成为瓶颈。</p>\n<p>多线程除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势。（网络IO中也需要用到CPU）</p>\n<p><strong>会有并发问题吗？</strong></p>\n<p>不会，因为数据读写的操作还是单线程来完成的</p>\n",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "Redis"
      ]
    },
    {
      "title": "BigDecimal 详解",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/java/basis/bigdecimal.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/java/basis/bigdecimal.html",
      "summary": "《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 BigDecimal 来进行浮点数的运算”。 浮点数的运算竟然还会有精度丢失的风险吗？确实会！ 示例代码： 为什么浮点数 float 或 double 运算的时候会有精度丢失的风险呢？ 这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度...",
      "content_html": "<p>《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 <code>BigDecimal</code> 来进行浮点数的运算”。</p>\n<p>浮点数的运算竟然还会有精度丢失的风险吗？确实会！</p>\n<p>示例代码：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">float</span> a <span class=\"token operator\">=</span> <span class=\"token number\">2.0f</span> <span class=\"token operator\">-</span> <span class=\"token number\">1.9f</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">float</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1.8f</span> <span class=\"token operator\">-</span> <span class=\"token number\">1.7f</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 0.100000024</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 0.099999905</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">==</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// false</span>\n</code></pre></div><p><strong>为什么浮点数 <code>float</code> 或 <code>double</code> 运算的时候会有精度丢失的风险呢？</strong></p>\n<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>\n<p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span>\n<span class=\"token comment\">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span>\n<span class=\"token number\">0.2</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">0.4</span> <span class=\"token operator\">-&gt;</span> <span class=\"token number\">0</span>\n<span class=\"token number\">0.4</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">0.8</span> <span class=\"token operator\">-&gt;</span> <span class=\"token number\">0</span>\n<span class=\"token number\">0.8</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">1.6</span> <span class=\"token operator\">-&gt;</span> <span class=\"token number\">1</span>\n<span class=\"token number\">0.6</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">1.2</span> <span class=\"token operator\">-&gt;</span> <span class=\"token number\">1</span>\n<span class=\"token number\">0.2</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">0.4</span> <span class=\"token operator\">-&gt;</span> <span class=\"token number\">0</span>（发生循环）\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n</code></pre></div><p>关于浮点数的更多内容，建议看一下<a href=\"http://kaito-kidd.com/2018/08/08/computer-system-float-point/\" target=\"_blank\" rel=\"noopener noreferrer\">计算机系统基础（四）浮点数</a>这篇文章。</p>\n<h2>BigDecimal 介绍</h2>\n<p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。</p>\n<p>通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>\n<p>《阿里巴巴 Java 开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/image-20211213101646884.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>具体原因我们在上面已经详细介绍了，这里就不多提了。</p>\n<p>想要解决浮点数运算精度丢失这个问题，可以直接使用 <code>BigDecimal</code> 来定义浮点数的值，然后再进行浮点数的运算操作即可。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">BigDecimal</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1.0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigDecimal</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0.9\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigDecimal</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0.8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">BigDecimal</span> x <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigDecimal</span> y <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 0</span>\n</code></pre></div><h2>BigDecimal 常见方法</h2>\n<h3>创建</h3>\n<p>我们在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p>\n<p>《阿里巴巴 Java 开发手册》对这部分内容也有提到，如下图所示。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/image-20211213102222601.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>加减乘除</h3>\n<p><code>add</code> 方法用于将两个 <code>BigDecimal</code> 对象相加，<code>subtract</code> 方法用于将两个 <code>BigDecimal</code> 对象相减。<code>multiply</code> 方法用于将两个 <code>BigDecimal</code> 对象相乘，<code>divide</code> 方法用于将两个 <code>BigDecimal</code> 对象相除。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">BigDecimal</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1.0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigDecimal</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0.9\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 1.9</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 0.1</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">multiply</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 0.90</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">divide</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 无法除尽，抛出 ArithmeticException 异常</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">divide</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">RoundingMode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">HALF_UP</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 1.11</span>\n</code></pre></div><p>这里需要注意的是，在我们使用 <code>divide</code> 方法的时候尽量使用 3 个参数版本，并且<code>RoundingMode</code> 不要选择 <code>UNNECESSARY</code>，否则很可能会遇到 <code>ArithmeticException</code>（无法除尽出现无限循环小数的时候），其中 <code>scale</code> 表示要保留几位小数，<code>roundingMode</code> 代表保留规则。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token class-name\">BigDecimal</span> <span class=\"token function\">divide</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BigDecimal</span> divisor<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> scale<span class=\"token punctuation\">,</span> <span class=\"token class-name\">RoundingMode</span> roundingMode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">divide</span><span class=\"token punctuation\">(</span>divisor<span class=\"token punctuation\">,</span> scale<span class=\"token punctuation\">,</span> roundingMode<span class=\"token punctuation\">.</span>oldMode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>保留规则非常多，这里列举几种:</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">RoundingMode</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span>\n   <span class=\"token comment\">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span>\n\t\t\t <span class=\"token function\">UP</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token constant\">ROUND_UP</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n   <span class=\"token comment\">// 2.5 -&gt; 2 , 1.6 -&gt; 1</span>\n   <span class=\"token comment\">// -1.6 -&gt; -1 , -2.5 -&gt; -2</span>\n\t\t\t <span class=\"token function\">DOWN</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token constant\">ROUND_DOWN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\t\t\t <span class=\"token comment\">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span>\n   <span class=\"token comment\">// -1.6 -&gt; -1 , -2.5 -&gt; -2</span>\n\t\t\t <span class=\"token function\">CEILING</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token constant\">ROUND_CEILING</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\t\t\t <span class=\"token comment\">// 2.5 -&gt; 2 , 1.6 -&gt; 1</span>\n   <span class=\"token comment\">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span>\n\t\t\t <span class=\"token function\">FLOOR</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token constant\">ROUND_FLOOR</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n   \t<span class=\"token comment\">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span>\n   <span class=\"token comment\">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span>\n\t\t\t <span class=\"token function\">HALF_UP</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token constant\">ROUND_HALF_UP</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n   <span class=\"token comment\">//......</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><h3>大小比较</h3>\n<p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1 表示 <code>a</code> 大于 <code>b</code>。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">BigDecimal</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1.0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigDecimal</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0.9\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 1</span>\n</code></pre></div><h3>保留几位小数</h3>\n<p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA 会提示。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">BigDecimal</span> m <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1.255433\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigDecimal</span> n <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span><span class=\"token function\">setScale</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">RoundingMode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">HALF_DOWN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 1.255</span>\n</code></pre></div><h2>BigDecimal 等值比较问题</h2>\n<p>《阿里巴巴 Java 开发手册》中提到：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/image-20220714161315993.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>BigDecimal</code> 使用 <code>equals()</code> 方法进行等值比较出现问题的代码示例：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">BigDecimal</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigDecimal</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1.0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//false</span>\n</code></pre></div><p>这是因为 <code>equals()</code> 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 <code>compareTo()</code> 方法比较的时候会忽略精度。</p>\n<p>1.0 的 scale 是 1，1 的 scale 是 0，因此 <code>a.equals(b)</code> 的结果是 false。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/image-20220714164706390.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>compareTo()</code> 方法可以比较两个 <code>BigDecimal</code> 的值，如果相等就返回 0，如果第 1 个数比第 2 个数大则返回 1，反之返回-1。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">BigDecimal</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigDecimal</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1.0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//0</span>\n</code></pre></div><h2>BigDecimal 工具类分享</h2>\n<p>网上有一个使用人数比较多的 <code>BigDecimal</code> 工具类，提供了多个静态方法来简化 <code>BigDecimal</code> 的操作。</p>\n<p>我对其进行了简单改进，分享一下源码：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>math<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BigDecimal</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>math<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">RoundingMode</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token doc-comment comment\">/**\n * 简化BigDecimal计算的小工具类\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BigDecimalUtil</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 默认除法运算精度\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">DEF_DIV_SCALE</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">BigDecimalUtil</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 提供精确的加法运算。\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v1</span> 被加数\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v2</span> 加数\n     * <span class=\"token keyword\">@return</span> 两个参数的和\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">double</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">BigDecimal</span> b1 <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">BigDecimal</span> b2 <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>b2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">doubleValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 提供精确的减法运算。\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v1</span> 被减数\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v2</span> 减数\n     * <span class=\"token keyword\">@return</span> 两个参数的差\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">double</span> <span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">BigDecimal</span> b1 <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">BigDecimal</span> b2 <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b1<span class=\"token punctuation\">.</span><span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span>b2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">doubleValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 提供精确的乘法运算。\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v1</span> 被乘数\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v2</span> 乘数\n     * <span class=\"token keyword\">@return</span> 两个参数的积\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">double</span> <span class=\"token function\">multiply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">BigDecimal</span> b1 <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">BigDecimal</span> b2 <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b1<span class=\"token punctuation\">.</span><span class=\"token function\">multiply</span><span class=\"token punctuation\">(</span>b2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">doubleValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到\n     * 小数点以后10位，以后的数字四舍五入。\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v1</span> 被除数\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v2</span> 除数\n     * <span class=\"token keyword\">@return</span> 两个参数的商\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">double</span> <span class=\"token function\">divide</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">divide</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">,</span> <span class=\"token constant\">DEF_DIV_SCALE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指\n     * 定精度，以后的数字四舍五入。\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v1</span>    被除数\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v2</span>    除数\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">scale</span> 表示表示需要精确到小数点以后几位。\n     * <span class=\"token keyword\">@return</span> 两个参数的商\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">double</span> <span class=\"token function\">divide</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> scale<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>scale <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span>\n                    <span class=\"token string\">\"The scale must be a positive integer or zero\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token class-name\">BigDecimal</span> b1 <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">BigDecimal</span> b2 <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b1<span class=\"token punctuation\">.</span><span class=\"token function\">divide</span><span class=\"token punctuation\">(</span>b2<span class=\"token punctuation\">,</span> scale<span class=\"token punctuation\">,</span> <span class=\"token class-name\">RoundingMode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">HALF_UP</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">doubleValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 提供精确的小数位四舍五入处理。\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v</span>     需要四舍五入的数字\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">scale</span> 小数点后保留几位\n     * <span class=\"token keyword\">@return</span> 四舍五入后的结果\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">double</span> <span class=\"token function\">round</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> scale<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>scale <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span>\n                    <span class=\"token string\">\"The scale must be a positive integer or zero\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token class-name\">BigDecimal</span> b <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">BigDecimal</span> one <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">divide</span><span class=\"token punctuation\">(</span>one<span class=\"token punctuation\">,</span> scale<span class=\"token punctuation\">,</span> <span class=\"token class-name\">RoundingMode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">HALF_UP</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">doubleValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 提供精确的类型转换(Float)\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v</span> 需要被转换的数字\n     * <span class=\"token keyword\">@return</span> 返回转换结果\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">float</span> <span class=\"token function\">convertToFloat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">BigDecimal</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">floatValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 提供精确的类型转换(Int)不进行四舍五入\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v</span> 需要被转换的数字\n     * <span class=\"token keyword\">@return</span> 返回转换结果\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">convertsToInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">BigDecimal</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">intValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 提供精确的类型转换(Long)\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v</span> 需要被转换的数字\n     * <span class=\"token keyword\">@return</span> 返回转换结果\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">long</span> <span class=\"token function\">convertsToLong</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">BigDecimal</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">longValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 返回两个数中大的一个值\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v1</span> 需要被对比的第一个数\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v2</span> 需要被对比的第二个数\n     * <span class=\"token keyword\">@return</span> 返回两个数中大的一个值\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">double</span> <span class=\"token function\">returnMax</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">BigDecimal</span> b1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">BigDecimal</span> b2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span>v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b1<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>b2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">doubleValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 返回两个数中小的一个值\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v1</span> 需要被对比的第一个数\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v2</span> 需要被对比的第二个数\n     * <span class=\"token keyword\">@return</span> 返回两个数中小的一个值\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">double</span> <span class=\"token function\">returnMin</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">BigDecimal</span> b1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">BigDecimal</span> b2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span>v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b1<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>b2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">doubleValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token doc-comment comment\">/**\n     * 精确对比两个数字\n     *\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v1</span> 需要被对比的第一个数\n     * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">v2</span> 需要被对比的第二个数\n     * <span class=\"token keyword\">@return</span> 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">BigDecimal</span> b1 <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">BigDecimal</span> b2 <span class=\"token operator\">=</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> b1<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>b2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre></div><h2>总结</h2>\n<p>浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。</p>\n<p>不过，Java 提供了<code>BigDecimal</code> 来操作浮点数。<code>BigDecimal</code> 的实现利用到了 <code>BigInteger</code> （用来操作大整数）, 所不同的是 <code>BigDecimal</code> 加入了小数位的概念。</p>\n",
      "image": "https://oss.javaguide.cn/javaguide/image-20211213101646884.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java基础常见面试题总结(上)",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/java/basis/java-basic-questions-01.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/java/basis/java-basic-questions-01.html",
      "summary": "基础概念与常识 Java 语言有哪些特点? 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 可靠性（具备异常处理和自动内存管理机制）； 安全性（Java 语言本身的...",
      "content_html": "<h2>基础概念与常识</h2>\n<h3>Java 语言有哪些特点?</h3>\n<ol>\n<li>简单易学；</li>\n<li>面向对象（封装，继承，多态）；</li>\n<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>\n<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>\n<li>可靠性（具备异常处理和自动内存管理机制）；</li>\n<li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；</li>\n<li>高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）；</li>\n<li>支持网络编程并且很方便；</li>\n<li>编译与解释并存；</li>\n<li>......</li>\n</ol>\n<blockquote>\n<p><strong>🐛 修正（参见：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/544\" target=\"_blank\" rel=\"noopener noreferrer\">issue#544</a>）</strong>：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread</p>\n</blockquote>\n<p>🌈 拓展一下：</p>\n<p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！</p>\n<h3>JVM vs JDK vs JRE</h3>\n<h4>JVM</h4>\n<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png\" alt=\"运行在 Java 虚拟机之上的编程语言\" tabindex=\"0\"><figcaption>运行在 Java 虚拟机之上的编程语言</figcaption></figure>\n<p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p>\n<p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比：<a href=\"https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines\" target=\"_blank\" rel=\"noopener noreferrer\">Comparison of Java virtual machines</a> ，感兴趣的可以去看看。并且，你可以在 <a href=\"https://docs.oracle.com/javase/specs/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java SE Specifications</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/JavaSeSpecifications.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h4>JDK 和 JRE</h4>\n<p>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用的，能够创建和编译 Java 程序。他包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p>\n<p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p>\n<p>也就是说，JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。而 JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/jdk-include-jre.png\" alt=\"JDK 包含 JRE\" tabindex=\"0\"><figcaption>JDK 包含 JRE</figcaption></figure>\n<h3>什么是字节码?采用字节码的好处是什么?</h3>\n<p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>\n<p><strong>Java 程序从源代码到运行的过程如下图所示</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png\" alt=\"Java程序转变为机器代码的过程\" tabindex=\"0\"><figcaption>Java程序转变为机器代码的过程</figcaption></figure>\n<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code-with-jit.png\" alt=\"Java程序转变为机器代码的过程\" tabindex=\"0\"><figcaption>Java程序转变为机器代码的过程</figcaption></figure>\n<blockquote>\n<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p>\n</blockquote>\n<p>JDK、JRE、JVM、JIT 这四者的关系如下图所示。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png\" alt=\"JDK、JRE、JVM、JIT 这四者的关系\" tabindex=\"0\"><figcaption>JDK、JRE、JVM、JIT 这四者的关系</figcaption></figure>\n<p>下面这张图是 JVM 的大致结构模型。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/jvm-rough-structure-model.png\" alt=\"JVM 的大致结构模型\" tabindex=\"0\"><figcaption>JVM 的大致结构模型</figcaption></figure>\n<h3>为什么不全部使用 AOT 呢？</h3>\n<p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p>\n<p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>\n<h3>为什么说 Java 语言“编译与解释并存”？</h3>\n<p>其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。</p>\n<p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>\n<ul>\n<li><strong>编译型</strong>：<a href=\"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80\" target=\"_blank\" rel=\"noopener noreferrer\">编译型语言</a> 会通过<a href=\"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8\" target=\"_blank\" rel=\"noopener noreferrer\">编译器</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>\n<li><strong>解释型</strong>：<a href=\"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80\" target=\"_blank\" rel=\"noopener noreferrer\">解释型语言</a>会通过<a href=\"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8\" target=\"_blank\" rel=\"noopener noreferrer\">解释器</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/compiled-and-interpreted-languages.png\" alt=\"编译型语言和解释型语言\" tabindex=\"0\"><figcaption>编译型语言和解释型语言</figcaption></figure>\n<p>根据维基百科介绍：</p>\n<blockquote>\n<p>为了改善编译语言的效率而发展出的<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF\" target=\"_blank\" rel=\"noopener noreferrer\">即时编译</a>技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成<a href=\"https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81\" target=\"_blank\" rel=\"noopener noreferrer\">字节码</a>。到执行期时，再将字节码直译，之后执行。<a href=\"https://zh.wikipedia.org/wiki/Java\" target=\"_blank\" rel=\"noopener noreferrer\">Java</a>与<a href=\"https://zh.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener noreferrer\">LLVM</a>是这种技术的代表产物。</p>\n<p>相关阅读：<a href=\"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html\" target=\"_blank\" rel=\"noopener noreferrer\">基本功 | Java 即时编译器原理解析及实践</a></p>\n</blockquote>\n<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>\n<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>\n<h3>Oracle JDK vs OpenJDK</h3>\n<p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p>\n<p>首先，2006 年 SUN 公司将 Java 开源，也就有了 OpenJDK。2009 年 Oracle 收购了 Sun 公司，于是自己在 OpenJDK 的基础上搞了一个 Oracle JDK。Oracle JDK 是不开源的，并且刚开始的几个版本（Java8 ~ Java11）还会相比于 OpenJDK 添加一些特有的功能和工具。</p>\n<p>其次，对于 Java 7 而言，OpenJDK 和 Oracle JDK 是十分接近的。 Oracle JDK 是基于 OpenJDK 7 构建的，只添加了一些小功能，由 Oracle 工程师参与维护。</p>\n<p>下面这段话摘自 Oracle 官方在 2012 年发表的一个博客：</p>\n<blockquote>\n<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>\n<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>\n</blockquote>\n<p>最后，简单总结一下 Oracle JDK 和 OpenJDK 的区别：</p>\n<ol>\n<li><strong>是否开源</strong>：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引起很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）OpenJDK 开源项目：<a href=\"https://github.com/openjdk/jdk\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/openjdk/jdk</a> 。</li>\n<li><strong>是否免费</strong>：Oracle JDK 会提供免费版本，但一般有时间限制。JDK17 之后的版本可以免费分发和商用，但是仅有 3 年时间，3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。OpenJDK 是完全免费的。</li>\n<li><strong>功能性</strong>：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。</li>\n<li><strong>稳定性</strong>：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版。因此，两者稳定性其实也是差不多的。</li>\n<li><strong>协议</strong>：Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>\n</ol>\n<blockquote>\n<p>既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？</p>\n<p>答：</p>\n<ol>\n<li>\n<p>OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 Dragonwell8：<a href=\"https://github.com/alibaba/dragonwell8\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/alibaba/dragonwell8</a></p>\n</li>\n<li>\n<p>OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。</p>\n</li>\n<li>\n<p>OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）</p>\n</li>\n</ol>\n<p>基于以上这些原因，OpenJDK 还是有存在的必要的！</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/oracle-jdk-release-cadence.jpg\" alt=\"oracle jdk release cadence\" tabindex=\"0\"><figcaption>oracle jdk release cadence</figcaption></figure>\n<p><strong>Oracle JDK 和 OpenJDK 如何选择？</strong></p>\n<p>建议选择 OpenJDK 或者基于 OpenJDK 的发行版，比如 AWS 的 Amazon Corretto，阿里巴巴的 Alibaba Dragonwell。</p>\n<p>🌈 拓展一下：</p>\n<ul>\n<li>BCL 协议（Oracle Binary Code License Agreement）：可以使用 JDK（支持商用），但是不能进行修改。</li>\n<li>OTN 协议（Oracle Technology Network License Agreement）：11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。</li>\n</ul>\n<figure><img src=\"https://oscimg.oschina.net/oscnet/up-5babce06ef8fad5c4df5d7a6cf53d4a7901.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>Java 和 C++ 的区别?</h3>\n<p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。</p>\n<p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p>\n<ul>\n<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>\n<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>\n<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>\n<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>\n<li>......</li>\n</ul>\n<h2>基本语法</h2>\n<h3>注释有哪几种形式？</h3>\n<p>Java 中的注释有三种：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/java-annotation-types.png\" alt=\"Java 注释类型总结\" tabindex=\"0\"><figcaption>Java 注释类型总结</figcaption></figure>\n<ol>\n<li>\n<p><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</p>\n</li>\n<li>\n<p><strong>多行注释</strong>：通常用于解释一段代码的作用。</p>\n</li>\n<li>\n<p><strong>文档注释</strong>：通常用于生成 Java 开发文档。</p>\n</li>\n</ol>\n<p>用的比较多的还是单行注释和文档注释，多行注释在实际开发中使用的相对较少。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/image-20220714112336911.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。</p>\n<p>《Clean Code》这本书明确指出：</p>\n<blockquote>\n<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p>\n<p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p>\n<p>举个例子：</p>\n<p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// check to see if the employee is eligible for full benefits</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>employee<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">&amp;</span> <span class=\"token constant\">HOURLY_FLAG</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>employee<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&gt;</span> <span class=\"token number\">65</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre></div><p>应替换为</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>employee<span class=\"token punctuation\">.</span><span class=\"token function\">isEligibleForFullBenefits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre></div></blockquote>\n<h3>标识符和关键字的区别是什么？</h3>\n<p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p>\n<p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识</strong>符 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。</p>\n<h3>Java 语言关键字有哪些？</h3>\n<p>| 分类                 | 关键字   |            |          |              |            |           |        |\n| :</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java基础常见面试题总结(中)",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/java/basis/java-basic-questions-02.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/java/basis/java-basic-questions-02.html",
      "summary": "面向对象基础 面向对象和面向过程的区别 两者的主要区别在于解决问题的方式不同： 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。 另外，面向对象开发的程序一般更易维护、易复用、易扩展。 相关 issue : 面向过程：面向过程性能比面向对象高？？ 。 下面是一个求圆的面积...",
      "content_html": "<h2>面向对象基础</h2>\n<h3>面向对象和面向过程的区别</h3>\n<p>两者的主要区别在于解决问题的方式不同：</p>\n<ul>\n<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>\n<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>\n</ul>\n<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>\n<p>相关 issue : <a href=\"https://github.com/Snailclimb/JavaGuide/issues/431\" target=\"_blank\" rel=\"noopener noreferrer\">面向过程：面向过程性能比面向对象高？？</a> 。</p>\n<p>下面是一个求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案。</p>\n<p><strong>面向对象</strong>：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Circle</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 定义圆的半径</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> radius<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 构造函数</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Circle</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> radius<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>radius <span class=\"token operator\">=</span> radius<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 计算圆的面积</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PI</span> <span class=\"token operator\">*</span> radius <span class=\"token operator\">*</span> radius<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 计算圆的周长</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPerimeter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PI</span> <span class=\"token operator\">*</span> radius<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 创建一个半径为3的圆</span>\n        <span class=\"token class-name\">Circle</span> circle <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Circle</span><span class=\"token punctuation\">(</span><span class=\"token number\">3.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 输出圆的面积和周长</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"圆的面积为：\"</span> <span class=\"token operator\">+</span> circle<span class=\"token punctuation\">.</span><span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"圆的周长为：\"</span> <span class=\"token operator\">+</span> circle<span class=\"token punctuation\">.</span><span class=\"token function\">getPerimeter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>我们定义了一个 <code>Circle</code> 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。</p>\n<p><strong>面向过程</strong>：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 定义圆的半径</span>\n        <span class=\"token keyword\">double</span> radius <span class=\"token operator\">=</span> <span class=\"token number\">3.0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 计算圆的面积和周长</span>\n        <span class=\"token keyword\">double</span> area <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PI</span> <span class=\"token operator\">*</span> radius <span class=\"token operator\">*</span> radius<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">double</span> perimeter <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PI</span> <span class=\"token operator\">*</span> radius<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 输出圆的面积和周长</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"圆的面积为：\"</span> <span class=\"token operator\">+</span> area<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"圆的周长为：\"</span> <span class=\"token operator\">+</span> perimeter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>我们直接定义了圆的半径，并使用该半径直接计算出圆的面积和周长。</p>\n<h3>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3>\n<p>new 运算符，new 创建对象实例（对象实例在\n内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>\n<ul>\n<li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li>\n<li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li>\n</ul>\n<h3>对象的相等和引用相等的区别</h3>\n<ul>\n<li>对象的相等一般比较的是内存中存放的内容是否相等。</li>\n<li>引用相等一般比较的是他们指向的内存地址是否相等。</li>\n</ul>\n<p>这里举一个例子：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str3 <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 使用 == 比较字符串的引用相等</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str1 <span class=\"token operator\">==</span> str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str1 <span class=\"token operator\">==</span> str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 使用 equals 方法比较字符串的相等</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n</code></pre></div><p>输出结果：</p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>false\ntrue\ntrue\ntrue\n</code></pre></div><p>从上面的代码输出结果可以看出：</p>\n<ul>\n<li><code>str1</code> 和 <code>str2</code> 不相等，而 <code>str1</code> 和 <code>str3</code> 相等。这是因为 <code>==</code> 运算符比较的是字符串的引用是否相等。</li>\n<li><code>str1</code>、 <code>str2</code>、<code>str3</code> 三者的内容都相等。这是因为<code>equals</code> 方法比较的是字符串的内容，即使这些字符串的对象引用不同，只要它们的内容相等，就认为它们是相等的。</li>\n</ul>\n<h3>如果一个类没有声明构造方法，该程序能正确执行吗?</h3>\n<p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p>\n<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</p>\n<p>我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>\n<h3>构造方法有哪些特点？是否可被 override?</h3>\n<p>构造方法特点如下：</p>\n<ul>\n<li>名字与类名相同。</li>\n<li>没有返回值，但不能用 void 声明构造函数。</li>\n<li>生成类的对象时自动执行，无需调用。</li>\n</ul>\n<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>\n<h3>面向对象三大特征</h3>\n<h4>封装</h4>\n<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> id<span class=\"token punctuation\">;</span><span class=\"token comment\">//id属性私有化</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span><span class=\"token comment\">//name属性私有化</span>\n\n    <span class=\"token comment\">//获取id的方法</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">//设置id的方法</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setId</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">//获取name的方法</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">//设置name的方法</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><h4>继承</h4>\n<p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>\n<p><strong>关于继承如下 3 点请记住：</strong></p>\n<ol>\n<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>\n<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>\n<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>\n</ol>\n<h4>多态</h4>\n<p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>\n<p><strong>多态的特点:</strong></p>\n<ul>\n<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>\n<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>\n<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>\n<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>\n</ul>\n<h3>接口和抽象类有什么共同点和区别？</h3>\n<p><strong>共同点</strong>：</p>\n<ul>\n<li>都不能被实例化。</li>\n<li>都可以包含抽象方法。</li>\n<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>\n</ul>\n<p><strong>区别</strong>：</p>\n<ul>\n<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>\n<li>一个类只能继承一个类，但是可以实现多个接口。</li>\n<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>\n</ul>\n<h3>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3>\n<p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>\n<ul>\n<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>\n<li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>\n</ul>\n<p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p>\n<h4>浅拷贝</h4>\n<p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p>\n<p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Address</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Cloneable</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 省略构造函数、Getter&amp;Setter方法</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Address</span> <span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Address</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">CloneNotSupportedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AssertionError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Cloneable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Address</span> address<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 省略构造函数、Getter&amp;Setter方法</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span> <span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> person<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">CloneNotSupportedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AssertionError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>测试：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">Person</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Address</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"武汉\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Person</span> person1Copy <span class=\"token operator\">=</span> person1<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// true</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span><span class=\"token function\">getAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> person1Copy<span class=\"token punctuation\">.</span><span class=\"token function\">getAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>\n<h4>深拷贝</h4>\n<p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span> <span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        person<span class=\"token punctuation\">.</span><span class=\"token function\">setAddress</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span><span class=\"token function\">getAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> person<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">CloneNotSupportedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AssertionError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>测试：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">Person</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Address</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"武汉\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Person</span> person1Copy <span class=\"token operator\">=</span> person1<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// false</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span><span class=\"token function\">getAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> person1Copy<span class=\"token punctuation\">.</span><span class=\"token function\">getAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>从输出结构就可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>\n<p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>\n<p>我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/shallow&amp;deep-copy.png\" alt=\"浅拷贝、深拷贝、引用拷贝示意图\" tabindex=\"0\"><figcaption>浅拷贝、深拷贝、引用拷贝示意图</figcaption></figure>\n<h2>Object</h2>\n<h3>Object 类的常见方法有哪些？</h3>\n<p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token doc-comment comment\">/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">native</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token doc-comment comment\">/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token doc-comment comment\">/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token doc-comment comment\">/**\n * native 方法，用于创建并返回当前对象的一份拷贝。\n */</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">native</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">CloneNotSupportedException</span>\n<span class=\"token doc-comment comment\">/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token doc-comment comment\">/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">void</span> <span class=\"token function\">notify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token doc-comment comment\">/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">void</span> <span class=\"token function\">notifyAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token doc-comment comment\">/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">void</span> <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> timeout<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span>\n<span class=\"token doc-comment comment\">/**\n * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> timeout<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> nanos<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span>\n<span class=\"token doc-comment comment\">/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span>\n<span class=\"token doc-comment comment\">/**\n * 实例被垃圾回收器回收的时候触发的操作\n */</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">finalize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Throwable</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n</code></pre></div><h3>== 和 equals() 的区别</h3>\n<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>\n<ul>\n<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>\n<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>\n</ul>\n<blockquote>\n<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>\n</blockquote>\n<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>\n<p><code>Object</code> 类 <code>equals()</code> 方法：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><code>equals()</code> 方法存在两种使用情况：</p>\n<ul>\n<li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>\n<li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>\n</ul>\n<p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 <code>==</code> 换成 <code>equals()</code> ）：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">String</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// a 为一个引用</span>\n<span class=\"token class-name\">String</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// b为另一个引用,对象的内容一样</span>\n<span class=\"token class-name\">String</span> aa <span class=\"token operator\">=</span> <span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 放在常量池中</span>\n<span class=\"token class-name\">String</span> bb <span class=\"token operator\">=</span> <span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 从常量池中查找</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>aa <span class=\"token operator\">==</span> bb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// true</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">==</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// false</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// true</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span> <span class=\"token operator\">==</span> <span class=\"token number\">42.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// true</span>\n</code></pre></div><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>\n<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>\n<p><code>String</code>类<code>equals()</code>方法：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> anObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> anObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>anObject <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">String</span> anotherString <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span>anObject<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> value<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> anotherString<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">char</span> v1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">char</span> v2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> anotherString<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">--</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> v2<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><h3>hashCode() 有什么用？</h3>\n<p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/java-hashcode-method.png\" alt=\"hashCode() 方法\" tabindex=\"0\"><figcaption>hashCode() 方法</figcaption></figure>\n<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>\n<blockquote>\n<p>⚠️ 注意：该方法在 <strong>Oracle OpenJDK8</strong> 中默认是 \"使用线程局部状态来实现 Marsaglia's xor-shift 随机数生成\", 并不是 \"地址\" 或者 \"地址转换而来\", 不同 JDK/VM 可能不同在 <strong>Oracle OpenJDK8</strong> 中有六种生成方式 (其中第五种是返回地址), 通过添加 VM 参数: -XX:hashCode=4 启用第五种。参考源码:</p>\n<ul>\n<li>https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/globals.hpp（1127行）</li>\n<li>https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp（537行开始）</li>\n</ul>\n</blockquote>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>\n<h3>为什么要有 hashCode？</h3>\n<p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p>\n<p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p>\n<blockquote>\n<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>\n</blockquote>\n<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>\n<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>\n<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p>\n<p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>\n<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>\n<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>\n<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>\n<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>\n<p>总结下来就是：</p>\n<ul>\n<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>\n<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>\n<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>\n</ul>\n<p>相信大家看了我前面对 <code>hashCode()</code> 和 <code>equals()</code> 的介绍之后，下面这个问题已经难不倒你们了。</p>\n<h3>为什么重写 equals() 时必须重写 hashCode() 方法？</h3>\n<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>\n<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>\n<p><strong>思考</strong>：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p>\n<p><strong>总结</strong>：</p>\n<ul>\n<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>\n<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>\n</ul>\n<p>更多关于 <code>hashCode()</code> 和 <code>equals()</code> 的内容可以查看：<a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java hashCode() 和 equals()的若干问题解答</a></p>\n<h2>String</h2>\n<h3>String、StringBuffer、StringBuilder 的区别？</h3>\n<p><strong>可变性</strong></p>\n<p><code>String</code> 是不可变的（后面会详细分析原因）。</p>\n<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractStringBuilder</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Appendable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">CharSequence</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> value<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">AbstractStringBuilder</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>str <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">appendNull</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">ensureCapacityInternal</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        str<span class=\"token punctuation\">.</span><span class=\"token function\">getChars</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        count <span class=\"token operator\">+=</span> len<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  \t<span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><strong>线程安全性</strong></p>\n<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>\n<p><strong>性能</strong></p>\n<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n<p><strong>对于三者使用的总结：</strong></p>\n<ol>\n<li>操作少量的数据: 适用 <code>String</code></li>\n<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>\n<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>\n</ol>\n<h3>String 为什么是不可变的?</h3>\n<p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<s>所以<code>String</code> 对象是不可变的。</s></p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">String</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span>Serializable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Comparable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">CharSequence</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">char</span> value<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><blockquote>\n<p>🐛 修正：我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>\n<p><code>String</code> 真正不可变有下面几点原因：</p>\n<ol>\n<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>\n<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>\n</ol>\n<p>相关阅读：<a href=\"https://www.zhihu.com/question/20618891/answer/114125846\" target=\"_blank\" rel=\"noopener noreferrer\">如何理解 String 类型值的不可变？ - 知乎提问</a></p>\n<p>补充（来自<a href=\"https://github.com/Snailclimb/JavaGuide/issues/675\" target=\"_blank\" rel=\"noopener noreferrer\">issue 675</a>）：在 Java 9 之后，<code>String</code>、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">String</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span>Serializable</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">Comparable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">CharSequence</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span>\n    <span class=\"token annotation punctuation\">@Stable</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractStringBuilder</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Appendable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">CharSequence</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> value<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p>\n<p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p>\n<p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/jdk9-string-latin1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。</p>\n<p>这是官方的介绍：https://openjdk.java.net/jeps/254 。</p>\n</blockquote>\n<h3>字符串拼接用“+” 还是 StringBuilder?</h3>\n<p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"he\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"llo\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str3 <span class=\"token operator\">=</span> <span class=\"token string\">\"world\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str4 <span class=\"token operator\">=</span> str1 <span class=\"token operator\">+</span> str2 <span class=\"token operator\">+</span> str3<span class=\"token punctuation\">;</span>\n</code></pre></div><p>上面的代码对应的字节码如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/image-20220422161637929.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>\n<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"he\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"llo\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"world\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    s <span class=\"token operator\">+=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/image-20220422161320823.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"he\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"llo\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"world\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">StringBuilder</span> s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> value <span class=\"token operator\">:</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/image-20220422162327415.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。</p>\n<p>不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。这个改进是 JDK9 的 <a href=\"https://openjdk.org/jeps/280\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 280</a> 提出的，这也意味着 JDK 9 之后，你可以放心使用“+” 进行字符串拼接了。关于这部分改进的详细介绍，推荐阅读这篇文章：还在无脑用 <a href=\"https://juejin.cn/post/7182872058743750715\" target=\"_blank\" rel=\"noopener noreferrer\">StringBuilder？来重温一下字符串拼接吧</a> 。</p>\n<h3>String#equals() 和 Object#equals() 有何区别？</h3>\n<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>\n<h3>字符串常量池的作用了解吗？</h3>\n<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 在堆中创建字符串对象”ab“</span>\n<span class=\"token comment\">// 将字符串对象”ab“的引用保存在字符串常量池中</span>\n<span class=\"token class-name\">String</span> aa <span class=\"token operator\">=</span> <span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 直接返回字符串常量池中字符串对象”ab“的引用</span>\n<span class=\"token class-name\">String</span> bb <span class=\"token operator\">=</span> <span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>aa<span class=\"token operator\">==</span>bb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// true</span>\n</code></pre></div><p>更多关于字符串常量池的介绍可以看一下 <a href=\"https://javaguide.cn/java/jvm/memory-area.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 内存区域详解</a> 这篇文章。</p>\n<h3>String s1 = new String(\"abc\");这句话创建了几个字符串对象？</h3>\n<p>会创建 1 或 2 个字符串对象。</p>\n<p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</p>\n<p>示例代码（JDK 1.8）：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">String</span> s1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>对应的字节码：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/open-source-project/image-20220413175809959.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p>\n<p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>\n<p>示例代码（JDK 1.8）：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 字符串常量池中已存在字符串对象“abc”的引用</span>\n<span class=\"token class-name\">String</span> s1 <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 下面这段代码只会在堆中创建 1 个字符串对象“abc”</span>\n<span class=\"token class-name\">String</span> s2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>对应的字节码：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/open-source-project/image-20220413180021072.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这里就不对上面的字节码进行详细注释了，7 这个位置的 <code>ldc</code> 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 <code>ldc</code> 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 <code>ldc</code> 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。</p>\n<h3>String#intern 方法有什么作用?</h3>\n<p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>\n<ul>\n<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>\n<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>\n</ul>\n<p>示例代码（JDK 1.8） :</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 在堆中创建字符串对象”Java“</span>\n<span class=\"token comment\">// 将字符串对象”Java“的引用保存在字符串常量池中</span>\n<span class=\"token class-name\">String</span> s1 <span class=\"token operator\">=</span> <span class=\"token string\">\"Java\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span>\n<span class=\"token class-name\">String</span> s2 <span class=\"token operator\">=</span> s1<span class=\"token punctuation\">.</span><span class=\"token function\">intern</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 会在堆中在单独创建一个字符串对象</span>\n<span class=\"token class-name\">String</span> s3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Java\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span>\n<span class=\"token class-name\">String</span> s4 <span class=\"token operator\">=</span> s3<span class=\"token punctuation\">.</span><span class=\"token function\">intern</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// s1 和 s2 指向的是堆中的同一个对象</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s1 <span class=\"token operator\">==</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// s3 和 s4 指向的是堆中不同的对象</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s3 <span class=\"token operator\">==</span> s4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n<span class=\"token comment\">// s1 和 s4 指向的是堆中的同一个对象</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s1 <span class=\"token operator\">==</span> s4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//true</span>\n</code></pre></div><h3>String 类型的变量和常量做“+”运算时发生了什么？</h3>\n<p>先来看字符串不加 <code>final</code> 关键字拼接的情况（JDK1.8）：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"str\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"ing\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str3 <span class=\"token operator\">=</span> <span class=\"token string\">\"str\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"ing\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str4 <span class=\"token operator\">=</span> str1 <span class=\"token operator\">+</span> str2<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str5 <span class=\"token operator\">=</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str3 <span class=\"token operator\">==</span> str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//false</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str3 <span class=\"token operator\">==</span> str5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//true</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str4 <span class=\"token operator\">==</span> str5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//false</span>\n</code></pre></div><blockquote>\n<p><strong>注意</strong>：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/image-20210817123252441.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>\n<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/image-20210817142715396.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>\n<p>对于 <code>String str3 = \"str\" + \"ing\";</code> 编译器会给你优化成 <code>String str3 = \"string\";</code> 。</p>\n<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>\n<ul>\n<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>\n<li><code>final</code> 修饰的基本数据类型和字符串变量</li>\n<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>\n</ul>\n<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>\n<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">String</span> str4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>\n<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>\n<p>示例代码：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"str\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"ing\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 下面两个表达式其实是等价的</span>\n<span class=\"token class-name\">String</span> c <span class=\"token operator\">=</span> <span class=\"token string\">\"str\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"ing\"</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 常量池中的对象</span>\n<span class=\"token class-name\">String</span> d <span class=\"token operator\">=</span> str1 <span class=\"token operator\">+</span> str2<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 常量池中的对象</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// true</span>\n</code></pre></div><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>\n<p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p>\n<p>示例代码（<code>str2</code> 在运行时才能确定其值）：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"str\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token function\">getStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> c <span class=\"token operator\">=</span> <span class=\"token string\">\"str\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"ing\"</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 常量池中的对象</span>\n<span class=\"token class-name\">String</span> d <span class=\"token operator\">=</span> str1 <span class=\"token operator\">+</span> str2<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 在堆上创建的新的对象</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// false</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">\"ing\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><h2>参考</h2>\n<ul>\n<li>深入解析 String#intern：<a href=\"https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li>\n<li>R 大（RednaxelaFX）关于常量折叠的回答：https://www.zhihu.com/question/55976094/answer/147302764</li>\n</ul>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java基础常见面试题总结(下)",
      "url": "https://hollowlatte.github.io/Note-Book/Note-Book/java/basis/java-basic-questions-03.html",
      "id": "https://hollowlatte.github.io/Note-Book/Note-Book/java/basis/java-basic-questions-03.html",
      "summary": "异常 Java 异常类层次结构图概览： Java 异常类层次结构图Java 异常类层次结构图 Exception 和 Error 有什么区别？ 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类: Exception :程序本身可以处理的异常，可以通过 catch ...",
      "content_html": "<h2>异常</h2>\n<p><strong>Java 异常类层次结构图概览</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/types-of-exceptions-in-java.png\" alt=\"Java 异常类层次结构图\" tabindex=\"0\"><figcaption>Java 异常类层次结构图</figcaption></figure>\n<h3>Exception 和 Error 有什么区别？</h3>\n<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>\n<ul>\n<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>\n<li><strong><code>Error</code></strong>：<code>Error</code> 属于程序无法处理的错误 ，<s>我们没办法通过 <code>catch</code> 来进行捕获</s>不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>\n</ul>\n<h3>Checked Exception 和 Unchecked Exception 有什么区别？</h3>\n<p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p>\n<p>比如下面这段 IO 操作的代码：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/checked-exception.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>...。</p>\n<p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>\n<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>\n<ul>\n<li><code>NullPointerException</code>(空指针错误)</li>\n<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>\n<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li>\n<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>\n<li><code>ClassCastException</code>（类型转换错误）</li>\n<li><code>ArithmeticException</code>（算术错误）</li>\n<li><code>SecurityException</code> （安全错误比如权限不够）</li>\n<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>\n<li>......</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unchecked-exception.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>Throwable 类常用方法有哪些？</h3>\n<ul>\n<li><code>String getMessage()</code>: 返回异常发生时的简要描述</li>\n<li><code>String toString()</code>: 返回异常发生时的详细信息</li>\n<li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>\n<li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>\n</ul>\n<h3>try-catch-finally 如何使用？</h3>\n<ul>\n<li><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>\n<li><code>catch</code>块：用于处理 try 捕获到的异常。</li>\n<li><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>\n</ul>\n<p>代码示例：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Try to do something\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"RuntimeException\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Catch Exception -&gt; \"</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Finally\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>输出：</p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>Try to do something\nCatch Exception -&gt; RuntimeException\nFinally\n</code></pre></div><p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.10.2.5\" target=\"_blank\" rel=\"noopener noreferrer\">jvm 官方文档</a>中有明确提到：</p>\n<blockquote>\n<p>If the <code>try</code> clause executes a <em>return</em>, the compiled code does the following:</p>\n<ol>\n<li>Saves the return value (if any) in a local variable.</li>\n<li>Executes a <em>jsr</em> to the code for the <code>finally</code> clause.</li>\n<li>Upon return from the <code>finally</code> clause, returns the value saved in the local variable.</li>\n</ol>\n</blockquote>\n<p>代码示例：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> value <span class=\"token operator\">*</span> value<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>输出：</p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>0\n</code></pre></div><h3>finally 中的代码一定会执行吗？</h3>\n<p>不一定的！在某些情况下，finally 中的代码不会被执行。</p>\n<p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Try to do something\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"RuntimeException\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Catch Exception -&gt; \"</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 终止当前正在运行的Java虚拟机</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Finally\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>输出：</p>\n<div class=\"language-text\" data-ext=\"text\" data-title=\"text\"><pre class=\"language-text\"><code>Try to do something\nCatch Exception -&gt; RuntimeException\n</code></pre></div><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p>\n<ol>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。</li>\n</ol>\n<p>相关 issue：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/190\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Snailclimb/JavaGuide/issues/190</a>。</p>\n<p>🧗🏻 进阶一下：从字节码角度分析<code>try catch finally</code>这个语法糖背后的实现原理。</p>\n<h3>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h3>\n<ol>\n<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>\n<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>\n</ol>\n<p>《Effective Java》中明确指出：</p>\n<blockquote>\n<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>\n</blockquote>\n<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">//读取文本文件的内容</span>\n<span class=\"token class-name\">Scanner</span> scanner <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    scanner <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Scanner</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D://read.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>scanner<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>scanner<span class=\"token punctuation\">.</span><span class=\"token function\">nextLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FileNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>scanner <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        scanner<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Scanner</span> scanner <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Scanner</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>scanner<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>scanner<span class=\"token punctuation\">.</span><span class=\"token function\">nextLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FileNotFoundException</span> fnfe<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fnfe<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>\n<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BufferedInputStream</span> bin <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedInputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token class-name\">BufferedOutputStream</span> bout <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"out.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">=</span> bin<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        bout<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><h3>异常使用有哪些需要注意的地方？</h3>\n<ul>\n<li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>\n<li>抛出的异常信息一定要有意义。</li>\n<li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li>\n<li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li>\n<li>......</li>\n</ul>\n<h2>泛型</h2>\n<h3>什么是泛型？有什么作用？</h3>\n<p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p>\n<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre></div><p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p>\n<h3>泛型的使用方式有哪几种？</h3>\n<p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>\n<p><strong>1.泛型类</strong>：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span>\n<span class=\"token comment\">//在实例化泛型类时，必须指定T的具体类型</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Generic</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">T</span> key<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Generic</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">T</span> <span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> key<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>如何实例化泛型类：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">Generic</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">&gt;</span></span> genericInteger <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Generic</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token number\">123456</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><p><strong>2.泛型接口</strong>：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Generator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">T</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>实现泛型接口，不指定类型：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">GeneratorImpl</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Generator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">T</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>实现泛型接口，指定类型：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">GeneratorImpl</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Generator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p><strong>3.泛型方法</strong>：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code>   <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span> <span class=\"token class-name\">E</span> <span class=\"token punctuation\">&gt;</span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">printArray</span><span class=\"token punctuation\">(</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> inputArray <span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token class-name\">E</span> element <span class=\"token operator\">:</span> inputArray <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"%s \"</span><span class=\"token punctuation\">,</span> element <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span>\n         <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre></div><p>使用：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 创建不同类型数组：Integer, Double 和 Character</span>\n<span class=\"token class-name\">Integer</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> intArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> stringArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"World\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printArray</span><span class=\"token punctuation\">(</span> intArray  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printArray</span><span class=\"token punctuation\">(</span> stringArray  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><blockquote>\n<p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p>\n</blockquote>\n<h3>项目中哪里用到了泛型？</h3>\n<ul>\n<li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li>\n<li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li>\n<li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li>\n<li>......</li>\n</ul>\n<h2>反射</h2>\n<p>关于反射的详细解读，请看这篇文章 <a href=\"/Note-Book/java/basis/reflection.html\" target=\"_blank\">Java 反射机制详解</a> 。</p>\n<h3>何谓反射？</h3>\n<p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>\n<h3>反射的优缺点？</h3>\n<p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>\n<p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>\n<p>相关阅读：<a href=\"https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow\" target=\"_blank\" rel=\"noopener noreferrer\">Java Reflection: Why is it so slow?</a> 。</p>\n<h3>反射的应用场景？</h3>\n<p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>\n<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>\n<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DebugInvocationHandler</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">InvocationHandler</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token doc-comment comment\">/**\n     * 代理类中的真实对象\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">DebugInvocationHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> target<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> proxy<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InvocationTargetException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">IllegalAccessException</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"before method \"</span> <span class=\"token operator\">+</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Object</span> result <span class=\"token operator\">=</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"after method \"</span> <span class=\"token operator\">+</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre></div><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>\n<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>\n<p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>\n<h2>注解</h2>\n<h3>何谓注解？</h3>\n<p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>\n<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">METHOD</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RetentionPolicy</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SOURCE</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token annotation punctuation\">@interface</span> <span class=\"token class-name\">Override</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Override</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Annotation</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>JDK 提供了很多内置的注解（比如 <code>@Override</code>、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>\n<h3>注解的解析方法有哪几种？</h3>\n<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>\n<ul>\n<li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>\n<li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>\n</ul>\n<h2>SPI</h2>\n<p>关于 SPI 的详细解读，请看这篇文章 <a href=\"/Note-Book/java/basis/spi.html\" target=\"_blank\">Java SPI 机制详解</a> 。</p>\n<h3>何谓 SPI?</h3>\n<p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>\n<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>\n<p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/spi/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3>SPI 和 API 有什么区别？</h3>\n<p><strong>那 SPI 和 API 有啥区别？</strong></p>\n<p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/spi/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>\n<p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p>\n<p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p>\n<p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>\n<h3>SPI 的优缺点？</h3>\n<p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p>\n<ul>\n<li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li>\n<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li>\n</ul>\n<h2>序列化和反序列化</h2>\n<p>关于序列化和反序列化的详细解读，请看这篇文章 <a href=\"/Note-Book/java/basis/serialization.html\" target=\"_blank\">Java 序列化详解</a> ，里面涉及到的知识点和面试题更全面。</p>\n<h3>什么是序列化?什么是反序列化?</h3>\n<p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>\n<p>简单来说：</p>\n<ul>\n<li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li>\n<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>\n</ul>\n<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>\n<p>下面是序列化和反序列化常见应用场景：</p>\n<ul>\n<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>\n<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>\n<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>\n<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>\n</ul>\n<p>维基百科是如是介绍序列化的：</p>\n<blockquote>\n<p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>\n</blockquote>\n<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/a478c74d-2c48-40ae-9374-87aacf05188c.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p style=\"text-align:right;font-size:13px;color:gray\">https://www.corejavaguru.com/java/serialization/interview-questions-1</p>\n<p><strong>序列化协议对应于 TCP/IP 4 层模型的哪一层？</strong></p>\n<p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？</p>\n<ol>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>网络接口层</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png\" alt=\"TCP/IP 四层模型\" tabindex=\"0\"><figcaption>TCP/IP 四层模型</figcaption></figure>\n<p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p>\n<p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。</p>\n<h3>如果有些字段不想进行序列化怎么办？</h3>\n<p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>\n<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>\n<p>关于 <code>transient</code> 还有几点注意：</p>\n<ul>\n<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>\n<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>\n<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>\n</ul>\n<h3>常见序列化协议有哪些？</h3>\n<p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p>\n<p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p>\n<h3>为什么不推荐使用 JDK 自带的序列化？</h3>\n<p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p>\n<ul>\n<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>\n<li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>\n<li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：<a href=\"https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/\" target=\"_blank\" rel=\"noopener noreferrer\">应用安全：JAVA 反序列化漏洞之殇</a> 。</li>\n</ul>\n<h2>I/O</h2>\n<p>关于 I/O 的详细解读，请看下面这几篇文章，里面涉及到的知识点和面试题更全面。</p>\n<ul>\n<li><a href=\"/Note-Book/java/io/io-basis.html\" target=\"_blank\">Java IO 基础知识总结</a></li>\n<li><a href=\"/Note-Book/java/io/io-design-patterns.html\" target=\"_blank\">Java IO 设计模式总结</a></li>\n<li><a href=\"/Note-Book/java/io/io-model.html\" target=\"_blank\">Java IO 模型详解</a></li>\n</ul>\n<h3>Java IO 流了解吗？</h3>\n<p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>\n<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>\n<ul>\n<li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>\n<li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>\n</ul>\n<h3>I/O 流为什么要分为字节流和字符流呢?</h3>\n<p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>\n<p>个人认为主要有两点原因：</p>\n<ul>\n<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；</li>\n<li>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</li>\n</ul>\n<h3>Java IO 中的设计模式有哪些？</h3>\n<p>参考答案：<a href=\"/Note-Book/java/io/io-design-patterns.html\" target=\"_blank\">Java IO 设计模式总结</a></p>\n<h3>BIO、NIO 和 AIO 的区别？</h3>\n<p>参考答案：<a href=\"/Note-Book/java/io/io-model.html\" target=\"_blank\">Java IO 模型详解</a></p>\n<h2>语法糖</h2>\n<h3>什么是语法糖？</h3>\n<p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>\n<p>举个例子，Java 中的 <code>for-each</code> 就是一个常用的语法糖，其原理其实就是基于普通的 for 循环和迭代器。</p>\n<div class=\"language-java\" data-ext=\"java\" data-title=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> strs <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"JavaGuide\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"公众号：JavaGuide\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"博客：https://javaguide.cn/\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s <span class=\"token operator\">:</span> strs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  \t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>\n<h3>Java 中有哪些常见的语法糖？</h3>\n<p>Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。</p>\n<p>关于这些语法糖的详细解读，请看这篇文章 <a href=\"/Note-Book/java/basis/syntactic-sugar.html\" target=\"_blank\">Java 语法糖详解</a> 。</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/basis/types-of-exceptions-in-java.png",
      "date_published": "2024-03-24T07:11:51.000Z",
      "date_modified": "2024-03-24T07:11:51.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    }
  ]
}